<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>ACES: Galaxy Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020205; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; cursor: none; }
        canvas { display: block; }

        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #hud-top {
            position: absolute; top: 20px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; color: white;
            font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        .hud-box { background: rgba(0, 0, 0, 0.5); padding: 10px 20px; border-radius: 20px; border: 1px solid #444; min-width: 100px; text-align: center; }
        
        #xp-bar-container {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 8px; background: #222; border: 1px solid #555; border-radius: 5px;
        }
        #xp-bar-fill { height: 100%; background: #ffd700; width: 0%; transition: width 0.2s; box-shadow: 0 0 10px #ffd700; }
        #xp-text { text-align: center; color: #ffd700; font-size: 10px; margin-top: 4px; letter-spacing: 2px; }

        /* Timer UI */
        #timer-box {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            color: #00d4ff; font-size: 24px; font-weight: 900; 
            text-shadow: 0 0 10px #00d4ff;
        }

        /* Upgrade Menu */
        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 15, 0.95); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 100; cursor: default;
        }
        #menu-title { color: white; font-size: 40px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 5px; }
        #menu-subtitle { color: #00d4ff; margin-bottom: 30px; font-size: 18px; }
        
        .card-container { display: flex; gap: 30px; }
        .card {
            width: 200px; height: 280px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #444; border-radius: 10px; display: flex; flex-direction: column;
            align-items: center; padding: 15px; cursor: pointer; color: white; transition: 0.3s;
            box-shadow: 0 0 15px rgba(0,0,0,0.5); position: relative; overflow: hidden;
        }
        .card:hover { transform: translateY(-10px); border-color: #00d4ff; box-shadow: 0 0 30px rgba(0, 212, 255, 0.4); }
        .card.minor { border-color: #ffd700; }
        .card.minor:hover { border-color: #ffe600; box-shadow: 0 0 30px rgba(255, 215, 0, 0.4); }
        
        .card-icon { font-size: 50px; margin: 20px 0; }
        .card h2 { color: #fff; margin: 10px 0; font-size: 16px; text-align: center; text-transform: uppercase; }
        .card p { color: #aaa; text-align: center; font-size: 12px; line-height: 1.4; margin-top: auto; margin-bottom: 20px; }

        /* Boss Warning */
        #boss-warning {
            position: absolute; top: 40%; left: 0; width: 100%; text-align: center;
            color: #ff0000; font-size: 60px; font-weight: 900; letter-spacing: 10px;
            text-shadow: 0 0 20px red; display: none; z-index: 50;
            background: rgba(0,0,0,0.5); padding: 20px 0;
        }

        /* Notification */
        #notification {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            color: #ffd700; font-size: 30px; font-weight: 900; opacity: 0;
            text-shadow: 0 0 20px #ffaa00; pointer-events: none; transition: opacity 0.5s;
        }

        /* Start Screen */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050510; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 200; cursor: default;
        }
        .btn {
            padding: 15px 50px; font-size: 24px; background: #00d4ff; border: none;
            color: #000; font-weight: 800; cursor: pointer; border-radius: 5px;
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.5); text-transform: uppercase;
        }
        .btn:hover { background: white; box-shadow: 0 0 40px white; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud-top">
            <div class="hud-box">SCORE <br><span id="score" style="color:#fff">0</span></div>
            <div class="hud-box" style="border-color:#ff4444">INTEGRITY <br><span id="hp" style="color:#ff4444">100%</span></div>
            <div class="hud-box" style="border-color:#00d4ff">WAVE <br><span id="wave" style="color:#00d4ff">1/9</span></div>
        </div>
        
        <div id="xp-bar-container">
            <div id="xp-bar-fill"></div>
            <div id="xp-text">SYSTEM UPDATE PROGRESS</div>
        </div>

        <div id="timer-box">01:30</div>
        <div id="notification">LEVEL UP!</div>
        <div id="boss-warning">‚ö† WARNING: BOSS DETECTED ‚ö†</div>
    </div>

    <div id="start-screen">
        <h1 style="color:#00d4ff; font-size: 80px; margin-bottom: 10px; text-shadow: 0 0 30px #00d4ff;">ACES GALAXY</h1>
        <p style="color:white; font-size: 18px; margin-bottom: 40px;">Survive 9 Waves. Build your Ship. Destroy the Omega.</p>
        <button class="btn" onclick="startGame()">LAUNCH MISSION</button>
    </div>

    <div id="menu-overlay">
        <h1 id="menu-title">WAVE COMPLETE</h1>
        <p id="menu-subtitle">SELECT MAJOR UPGRADE</p>
        <div class="card-container" id="cards-box"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- CONFIGURATIE ---
        let width, height;
        let gameRunning = false;
        let isPaused = false;
        let frameCount = 0;
        let screenShake = 0;
        
        // Game State
        const TOTAL_WAVES = 9;
        const WAVE_DURATION = 90; // Seconds
        let wave = 0; // Starts at 0, becomes 1 on first logic
        let score = 0;
        let waveTimer = 0;
        let xp = 0;
        let xpThreshold = 100;
        let level = 1;
        
        // --- UPGRADE TREES ---
        const UPGRADE_DATA = {
            'SPREAD': {
                name: 'Spread Tech',
                icon: '‚ëÇ',
                tiers: [
                    { name: 'Twin Blaster', desc: 'Fires 2 parallel shots.' },
                    { name: 'Triple Spread', desc: 'Fires 3 shots in a focused arc.' },
                    { name: 'Quad Battery', desc: 'Fires 4 shots. High coverage.' },
                    { name: 'Star Pattern', desc: 'Fires 5 shots in a star shape.' }
                ],
                minors: [
                    { id: 'rate', name: 'Recoil Coolant', desc: '+10% Fire Rate' },
                    { id: 'speed', name: 'Velocity Drive', desc: '+15% Bullet Speed' },
                    { id: 'damage', name: 'Core Amp', desc: '+1 Damage' }
                ]
            },
            'RAPID': {
                name: 'Rapid Tech',
                icon: '‚ö°',
                tiers: [
                    { name: 'Auto-Cannon', desc: 'Full auto. Medium fire rate.' },
                    { name: 'Gatling Gun', desc: 'High fire rate. Low accuracy.' },
                    { name: 'Vulcan', desc: 'Extreme fire rate. Spinning barrel.' },
                    { name: 'Lead Storm', desc: 'A wall of bullets.' }
                ],
                minors: [
                    { id: 'reload', name: 'Belt Feed', desc: '+15% Fire Rate' },
                    { id: 'crit', name: 'Targeting CPU', desc: 'Chance for double damage.' },
                    { id: 'heat', name: 'Heat Sink', desc: 'Prevents overheating (Passive).' }
                ]
            },
            'PLASMA': {
                name: 'Plasma Tech',
                icon: 'üßø',
                tiers: [
                    { name: 'Plasma Bolt', desc: 'Slow, high damage energy ball.' },
                    { name: 'Pulse Cannon', desc: 'Larger projectiles, pushes enemies.' },
                    { name: 'Fusion Orb', desc: 'Passes through small enemies.' },
                    { name: 'Nova Launcher', desc: 'Massive explosive rounds.' }
                ],
                minors: [
                    { id: 'size', name: 'Mag Field', desc: '+20% Projectile Size' },
                    { id: 'dot', name: 'Ion Burn', desc: 'Enemies take burn damage.' },
                    { id: 'damage', name: 'Reactor', desc: '+30% Damage.' }
                ]
            }
        };

        // --- CLASSES ---

        class Star {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.z = Math.random() * 2 + 0.5; // Depth factor
                this.size = Math.random() < 0.1 ? 2 : 1;
                this.brightness = Math.random();
            }
            update() {
                // Parallax: closer stars (higher z) move faster
                this.y += this.z * 1.5; 
                if (this.y > height) {
                    this.y = 0;
                    this.x = Math.random() * width;
                }
                this.brightness = 0.5 + Math.sin(frameCount * 0.05 * this.z) * 0.5;
            }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * (this.z/2), 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Player {
            constructor() {
                this.x = width / 2;
                this.y = height - 100;
                this.size = 25;
                this.hp = 100;
                this.maxHp = 100;
                this.speed = 0.15;
                this.fireRate = 12; // Frames per shot
                
                // Upgrade State
                this.path = 'SPREAD'; // Default
                this.tierLevel = 0;
                this.modifiers = { damage: 1, speed: 1, rate: 1, size: 1 };
            }

            update() {
                this.x += (mouse.x - this.x) * this.speed;
                this.y += (mouse.y - this.y) * this.speed;
                
                // Bounds
                this.x = Math.max(20, Math.min(width-20, this.x));
                this.y = Math.max(20, Math.min(height-20, this.y));

                // Shooting
                let rate = Math.max(2, this.fireRate / this.modifiers.rate);
                if (frameCount % Math.floor(rate) === 0) {
                    this.shoot();
                }
            }

            shoot() {
                const type = UPGRADE_DATA[this.path];
                const tier = this.tierLevel;
                const baseDmg = 10 * this.modifiers.damage;
                const spd = 12 * this.modifiers.speed;
                const color = this.path === 'PLASMA' ? '#00d4ff' : (this.path === 'RAPID' ? '#ffaa00' : '#ffd700');

                // Muzzle flash
                particles.push(new Particle(this.x, this.y - 25, color, 3));

                if (this.path === 'SPREAD') {
                    if (tier === 0) bullets.push(new Bullet(this.x, this.y-20, 0, -spd, color, false, baseDmg));
                    if (tier === 1) { // Twin
                         bullets.push(new Bullet(this.x-10, this.y-20, 0, -spd, color, false, baseDmg));
                         bullets.push(new Bullet(this.x+10, this.y-20, 0, -spd, color, false, baseDmg));
                    }
                    if (tier >= 2) { // Triple
                         bullets.push(new Bullet(this.x, this.y-20, 0, -spd, color, false, baseDmg));
                         bullets.push(new Bullet(this.x-15, this.y-15, -2, -spd*0.9, color, false, baseDmg));
                         bullets.push(new Bullet(this.x+15, this.y-15, 2, -spd*0.9, color, false, baseDmg));
                    }
                    if (tier >= 3) { // Quad
                         bullets.push(new Bullet(this.x-8, this.y-20, -1, -spd, color, false, baseDmg));
                         bullets.push(new Bullet(this.x+8, this.y-20, 1, -spd, color, false, baseDmg));
                         bullets.push(new Bullet(this.x-20, this.y-15, -3, -spd*0.9, color, false, baseDmg));
                         bullets.push(new Bullet(this.x+20, this.y-15, 3, -spd*0.9, color, false, baseDmg));
                    }
                } else if (this.path === 'RAPID') {
                    let spread = (Math.random()-0.5) * (tier >= 1 ? 4 : 1);
                    bullets.push(new Bullet(this.x, this.y-20, spread, -spd * 1.5, color, false, baseDmg * 0.6));
                } else if (this.path === 'PLASMA') {
                    let size = (this.tierLevel + 1) * 1.5 * this.modifiers.size;
                    let b = new Bullet(this.x, this.y-20, 0, -spd * 0.8, color, false, baseDmg * 2.5);
                    b.size = size + 3;
                    b.isPlasma = true;
                    bullets.push(b);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Engine flame
                ctx.fillStyle = '#00d4ff';
                ctx.shadowBlur = 15; ctx.shadowColor = '#00d4ff';
                let flicker = Math.random() * 10;
                ctx.beginPath(); ctx.moveTo(-6, 20); ctx.lineTo(0, 35+flicker); ctx.lineTo(6, 20); ctx.fill();
                ctx.shadowBlur = 0;

                // Ship Body
                let grad = ctx.createLinearGradient(0, -25, 0, 25);
                grad.addColorStop(0, '#eef');
                grad.addColorStop(1, '#556');
                ctx.fillStyle = grad;
                
                // Design based on path
                ctx.beginPath();
                if (this.path === 'SPREAD') {
                    ctx.moveTo(0, -25); ctx.lineTo(25, 15); ctx.lineTo(0, 10); ctx.lineTo(-25, 15);
                } else if (this.path === 'RAPID') {
                    ctx.moveTo(0, -30); ctx.lineTo(10, 20); ctx.lineTo(0, 15); ctx.lineTo(-10, 20);
                } else {
                    ctx.arc(0, 0, 20, 0, Math.PI*2); // Circular plasma ship
                }
                ctx.fill();

                // Cockpit
                ctx.fillStyle = '#111';
                ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(4, 5); ctx.lineTo(-4, 5); ctx.fill();

                ctx.restore();
            }
        }

        class Enemy {
            constructor(type, waveDiff) {
                this.type = type; // 'DRONE', 'KAMIKAZE', 'TANK'
                this.hp = 30 + (waveDiff * 10);
                this.maxHp = this.hp;
                this.x = Math.random() * (width - 60) + 30;
                this.y = -50;
                this.targetY = Math.random() * (height * 0.4) + 50;
                this.vx = 0;
                this.vy = 2;
                
                if (type === 'KAMIKAZE') {
                    this.speed = 4;
                    this.hp = 20 + (waveDiff * 5);
                    this.color = '#ff4444';
                } else if (type === 'TANK') {
                    this.speed = 0.5;
                    this.hp = 150 + (waveDiff * 20);
                    this.color = '#4488ff';
                } else {
                    this.speed = 2;
                    this.color = '#aaaaaa';
                }
                
                this.fireTimer = Math.random() * 100;
            }

            update() {
                if (this.type === 'KAMIKAZE') {
                    this.y += this.speed;
                    this.x += (player.x - this.x) * 0.02; // Track player loosely
                } else {
                    if (this.y < this.targetY) this.y += this.vy;
                    this.x += Math.sin(frameCount * 0.02 + this.y) * 1.5;
                }

                // Shooting Logic
                this.fireTimer--;
                if (this.fireTimer <= 0) {
                    if (this.type === 'DRONE') {
                        this.shoot(0, 5);
                        this.fireTimer = 120;
                    } else if (this.type === 'TANK') {
                        this.shoot(-2, 4); this.shoot(0, 4); this.shoot(2, 4);
                        this.fireTimer = 180;
                    }
                }
            }
            
            shoot(vx, vy) {
                bullets.push(new Bullet(this.x, this.y + 20, vx, vy, '#ff0055', true, 10));
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.PI); // Face down

                ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;

                if (this.type === 'DRONE') {
                    ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(15, 15); ctx.lineTo(-15, 15); ctx.fill();
                } else if (this.type === 'KAMIKAZE') {
                    ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(10, 0); ctx.lineTo(0, 10); ctx.lineTo(-10, 0); ctx.fill();
                } else if (this.type === 'TANK') {
                    ctx.fillRect(-20, -20, 40, 40);
                    ctx.fillStyle = '#000'; ctx.fillRect(-10, -5, 20, 20);
                }

                ctx.restore();
            }
        }

        class Boss {
            constructor(waveNum) {
                this.isBoss = true;
                this.hp = 2000 + (waveNum * 500);
                this.maxHp = this.hp;
                this.x = Math.random() * (width - 200) + 100; // Random top entry
                this.y = -200;
                this.targetY = 120;
                this.phase = 'ENTER'; // ENTER, IDLE, ATTACK_A, ATTACK_B
                this.timer = 0;
                this.waveNum = waveNum;
            }

            update() {
                this.timer++;

                // State Machine
                if (this.phase === 'ENTER') {
                    this.y += (this.targetY - this.y) * 0.02;
                    if (Math.abs(this.y - this.targetY) < 5) this.phase = 'IDLE';
                } 
                else if (this.phase === 'IDLE') {
                    this.x = width/2 + Math.sin(frameCount * 0.01) * (width/3);
                    if (this.timer % 200 === 0) {
                        this.phase = Math.random() > 0.5 ? 'ATTACK_A' : 'ATTACK_B';
                        this.atkTimer = 0;
                    }
                }
                else if (this.phase === 'ATTACK_A') {
                    // Standard Burst
                    this.atkTimer++;
                    if (this.atkTimer % 10 === 0) {
                        let angle = Math.atan2(player.y - this.y, player.x - this.x);
                        bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*6, Math.sin(angle)*6, '#f0f', true, 15));
                    }
                    if (this.atkTimer > 100) this.phase = 'IDLE';
                }
                else if (this.phase === 'ATTACK_B') {
                    // Special
                    this.atkTimer++;
                    if (this.waveNum === 3) { // NOVA
                        if (this.atkTimer % 40 === 0) {
                             for(let i=0; i<12; i++) {
                                let a = (i/12)*Math.PI*2;
                                bullets.push(new Bullet(this.x, this.y, Math.cos(a)*4, Math.sin(a)*4, '#f0f', true, 15));
                             }
                        }
                    } else if (this.waveNum === 6) { // LASER SWEEP
                        if (this.atkTimer % 5 === 0) {
                             let xOff = Math.sin(this.atkTimer * 0.1) * 100;
                             bullets.push(new Bullet(this.x + xOff, this.y+50, 0, 8, '#f0f', true, 15));
                        }
                    } else { // RAIN (Wave 9)
                        if (this.atkTimer % 5 === 0) {
                            bullets.push(new Bullet(Math.random()*width, -50, 0, 6, '#fff', true, 20));
                        }
                    }

                    if (this.atkTimer > 150) this.phase = 'IDLE';
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Boss Visual
                ctx.shadowBlur = 30; ctx.shadowColor = '#ff00ff';
                
                // Rotating Outer Ring
                ctx.save();
                ctx.rotate(frameCount * 0.02);
                ctx.strokeStyle = '#440044'; ctx.lineWidth = 10;
                ctx.beginPath();
                for(let i=0; i<4; i++) {
                    ctx.rotate(Math.PI/2);
                    ctx.moveTo(50,0); ctx.lineTo(80,0);
                }
                ctx.stroke();
                ctx.restore();

                // Core
                let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, 60);
                grad.addColorStop(0, '#ff00ff'); grad.addColorStop(1, '#220022');
                ctx.fillStyle = grad;
                ctx.beginPath(); 
                ctx.moveTo(0, -60); ctx.lineTo(50, 20); ctx.lineTo(0, 80); ctx.lineTo(-50, 20); 
                ctx.fill();

                // HP Bar
                ctx.restore();
                ctx.fillStyle = '#440044'; ctx.fillRect(width/2 - 300, 80, 600, 20);
                ctx.fillStyle = '#ff00ff'; ctx.fillRect(width/2 - 300, 80, 600 * (this.hp/this.maxHp), 20);
                ctx.strokeStyle = '#fff'; ctx.strokeRect(width/2 - 300, 80, 600, 20);
            }
        }

        class Bullet {
            constructor(x, y, vx, vy, color, isEnemy, dmg) {
                this.x = x; this.y = y;
                this.vx = vx; this.vy = vy;
                this.color = color;
                this.isEnemy = isEnemy;
                this.damage = dmg;
                this.marked = false;
                this.size = 5;
                this.isPlasma = false;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (this.x < -50 || this.x > width+50 || this.y < -50 || this.y > height+50) this.marked = true;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                if (this.isPlasma) {
                    ctx.beginPath(); ctx.arc(0,0, this.size, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.fillRect(-this.size/2, -this.size*2, this.size, this.size*4);
                }
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color, speed) {
                this.x = x; this.y = y;
                let angle = Math.random() * Math.PI * 2;
                let spd = Math.random() * speed;
                this.vx = Math.cos(angle) * spd;
                this.vy = Math.sin(angle) * spd;
                this.life = 1.0;
                this.color = color;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= 0.05;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let stars = [];
        let mouse = { x: 0, y: 0 };

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            resize();
            player = new Player();
            bullets = []; enemies = []; particles = [];
            stars = [];
            for(let i=0; i<100; i++) stars.push(new Star());
            
            // Reset State
            score = 0; wave = 0; xp = 0; xpThreshold = 100;
            
            // Immediate Major Upgrade to choose class
            showUpgradeMenu(true);
            gameRunning = true;
            animate();
        }

        function startNextWave() {
            wave++;
            if (wave > TOTAL_WAVES) {
                gameOver(true); // Victory
                return;
            }

            bullets = []; // Clear bullets between waves
            const isBoss = (wave % 3 === 0);
            
            if (isBoss) {
                waveTimer = 9999; // Infinite timer for boss
                document.getElementById('timer-box').style.color = '#ff00ff';
                document.getElementById('timer-box').innerText = "BOSS";
                document.getElementById('boss-warning').style.display = 'block';
                setTimeout(() => document.getElementById('boss-warning').style.display = 'none', 3000);
            } else {
                waveTimer = WAVE_DURATION;
                document.getElementById('timer-box').style.color = '#00d4ff';
            }
            
            isPaused = false;
            updateUI();
        }

        function spawnLogic() {
            const isBossWave = (wave % 3 === 0);
            
            // Boss Spawn
            if (isBossWave) {
                if (enemies.length === 0 && !enemies.some(e => e.isBoss)) {
                    enemies.push(new Boss(wave));
                }
                return;
            }

            // Normal Spawn
            const difficulty = wave;
            const maxEnemies = 4 + wave;
            
            if (enemies.length < maxEnemies && Math.random() < 0.02) {
                let type = 'DRONE';
                if (wave >= 2 && Math.random() > 0.7) type = 'KAMIKAZE';
                if (wave >= 4 && Math.random() > 0.8) type = 'TANK';
                
                enemies.push(new Enemy(type, difficulty));
            }
        }

        function updateTimer() {
            if (isPaused) return;
            const isBossWave = (wave % 3 === 0);
            
            if (!isBossWave) {
                if (frameCount % 60 === 0) { // Approx 1 sec
                    waveTimer--;
                    let m = Math.floor(waveTimer / 60);
                    let s = waveTimer % 60;
                    document.getElementById('timer-box').innerText = `0${m}:${s<10?'0':''}${s}`;
                    
                    if (waveTimer <= 0) {
                        showUpgradeMenu(true); // Major Upgrade at end of wave
                    }
                }
            } else {
                // Boss wave ends when boss dies, logic in killEnemy
            }
        }

        function killEnemy(e) {
            score += e.isBoss ? 5000 : 100;
            
            // Screenshake
            screenShake = e.isBoss ? 20 : 5;
            
            // Particles
            for(let i=0; i<(e.isBoss?50:10); i++) particles.push(new Particle(e.x, e.y, e.color || '#fff', 5));
            
            enemies = enemies.filter(en => en !== e);
            
            // XP Logic
            if (!e.isBoss) {
                xp += 20;
                if (xp >= xpThreshold) {
                    xp = 0;
                    xpThreshold *= 1.2;
                    showUpgradeMenu(false); // Minor Upgrade
                }
            } else {
                // Boss Dead -> Wave Complete
                showUpgradeMenu(true);
            }
            updateUI();
        }

        function showUpgradeMenu(isMajor) {
            isPaused = true;
            const overlay = document.getElementById('menu-overlay');
            const container = document.getElementById('cards-box');
            const title = document.getElementById('menu-title');
            const sub = document.getElementById('menu-subtitle');
            
            overlay.style.display = 'flex';
            container.innerHTML = '';
            
            if (isMajor) {
                // START OF WAVE UPGRADES
                if (wave === 0) {
                    title.innerText = "INITIALIZE SYSTEM";
                    sub.innerText = "SELECT WEAPON CLASS";
                    // Offer 3 base paths
                    ['SPREAD', 'RAPID', 'PLASMA'].forEach(key => createCard(key, UPGRADE_DATA[key], container, true));
                } else {
                    title.innerText = "WAVE COMPLETE";
                    sub.innerText = "UPGRADE WEAPON TIER";
                    // Upgrade current path
                    let nextTierIdx = player.tierLevel + 1;
                    let data = UPGRADE_DATA[player.path];
                    if (nextTierIdx < data.tiers.length) {
                         // Currently only linear vertical upgrades for Major, could branch here too
                         // For now, offer the next Tier
                         let tierInfo = data.tiers[nextTierIdx];
                         let card = document.createElement('div');
                         card.className = 'card';
                         card.innerHTML = `<div class="card-icon">${data.icon}</div><h2>${tierInfo.name}</h2><p>${tierInfo.desc}</p>`;
                         card.onclick = () => { applyUpgrade(true, nextTierIdx); };
                         container.appendChild(card);
                    } else {
                        // Max Tier Reached - Heal
                        let card = document.createElement('div');
                        card.className = 'card';
                        card.innerHTML = `<div class="card-icon">‚ù§</div><h2>REPAIR</h2><p>Full Hull Repair</p>`;
                        card.onclick = () => { player.hp = player.maxHp; resumeGame(); };
                        container.appendChild(card);
                    }
                }
            } else {
                // MINOR UPGRADES (XP)
                title.innerText = "LEVEL UP";
                sub.innerText = "SELECT MODULE";
                let options = UPGRADE_DATA[player.path].minors;
                // Pick 2 random + 1 Heal
                let choices = [...options].sort(() => Math.random() - 0.5).slice(0, 2);
                choices.push({ id: 'heal', name: 'Nanobots', desc: 'Repair 20% HP' });
                
                choices.forEach(opt => {
                    let div = document.createElement('div');
                    div.className = 'card minor';
                    div.innerHTML = `<div class="card-icon">+</div><h2>${opt.name}</h2><p>${opt.desc}</p>`;
                    div.onclick = () => applyUpgrade(false, opt.id);
                    container.appendChild(div);
                });
            }
        }
        
        function createCard(key, data, container, isInit) {
            let div = document.createElement('div');
            div.className = 'card';
            div.innerHTML = `<div class="card-icon">${data.icon}</div><h2>${data.name}</h2><p>${data.tiers[0].desc}</p>`;
            div.onclick = () => {
                if (isInit) {
                    player.path = key;
                    player.tierLevel = 0;
                }
                resumeGame();
            };
            container.appendChild(div);
        }

        function applyUpgrade(isMajor, payload) {
            if (isMajor) {
                // Payload is Tier Index
                player.tierLevel = payload;
                startNextWave(); // Major upgrade triggers next wave
            } else {
                // Payload is ID string
                if (payload === 'heal') player.hp = Math.min(player.maxHp, player.hp + 20);
                if (payload === 'damage') player.modifiers.damage += 0.2;
                if (payload === 'rate' || payload === 'reload') player.modifiers.rate += 0.15;
                if (payload === 'speed') player.modifiers.speed += 0.15;
                if (payload === 'size') player.modifiers.size += 0.2;
                
                resumeGame();
            }
            document.getElementById('menu-overlay').style.display = 'none';
        }

        function resumeGame() {
            document.getElementById('menu-overlay').style.display = 'none';
            isPaused = false;
            // If we just finished wave 0 setup, start wave 1
            if (wave === 0) startNextWave();
            updateUI();
        }

        function checkCollisions() {
            bullets.forEach(b => {
                if (b.marked) return;
                
                if (!b.isEnemy) {
                    enemies.forEach(e => {
                        let hitBox = e.isBoss ? 80 : 25;
                        if (Math.hypot(b.x - e.x, b.y - e.y) < hitBox) {
                            e.hp -= b.damage;
                            b.marked = true;
                            // Small particles on hit
                            particles.push(new Particle(b.x, b.y, '#fff', 2));
                            if (e.hp <= 0) killEnemy(e);
                        }
                    });
                } else {
                    if (Math.hypot(b.x - player.x, b.y - player.y) < player.size - 5) {
                        player.hp -= 10;
                        b.marked = true;
                        screenShake = 5;
                        particles.push(new Particle(player.x, player.y, 'red', 5));
                        updateUI();
                        if (player.hp <= 0) gameOver(false);
                    }
                }
            });
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('hp').innerText = Math.floor(player.hp) + "%";
            document.getElementById('wave').innerText = wave + " / " + TOTAL_WAVES;
            document.getElementById('xp-bar-fill').style.width = (xp / xpThreshold * 100) + "%";
        }
        
        function gameOver(victory) {
            gameRunning = false;
            document.getElementById('start-screen').style.display = 'flex';
            let title = victory ? "MISSION ACCOMPLISHED" : "CRITICAL FAILURE";
            let color = victory ? "#00ff00" : "#ff0000";
            document.querySelector('#start-screen h1').innerText = title;
            document.querySelector('#start-screen h1').style.color = color;
            document.querySelector('#start-screen h1').style.textShadow = `0 0 30px ${color}`;
            document.querySelector('#start-screen p').innerText = "Final Score: " + score;
        }

        function resize() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            width = canvas.width; height = canvas.height;
        }
        window.addEventListener('resize', resize);
        document.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);
            if (isPaused) return;

            frameCount++;
            updateTimer();

            // Shake Logic
            let tx = 0, ty = 0;
            if (screenShake > 0) {
                tx = (Math.random() - 0.5) * screenShake;
                ty = (Math.random() - 0.5) * screenShake;
                screenShake *= 0.9;
                if(screenShake < 0.5) screenShake = 0;
            }

            ctx.save();
            ctx.translate(tx, ty);
            
            // Clear
            ctx.fillStyle = '#020205';
            ctx.fillRect(0, 0, width, height);

            // Background Stars
            stars.forEach(s => { s.update(); s.draw(); });

            spawnLogic();
            player.update();
            player.draw();

            [enemies, bullets, particles].forEach(arr => {
                for (let i = arr.length - 1; i >= 0; i--) {
                    let obj = arr[i];
                    obj.update();
                    obj.draw();
                    if (obj.marked || (obj.life !== undefined && obj.life <= 0)) arr.splice(i, 1);
                }
            });

            checkCollisions();
            ctx.restore(); // Undo shake
        }

    </script>
</body>
</html>