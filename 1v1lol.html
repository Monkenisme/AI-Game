<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>ACES: Galaxy Edition - Update 3</title>
<style>
body { margin: 0; overflow: hidden; background: #020205; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; cursor: none; }
canvas { display: block; }

/* UI Overlay */
#ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
#hud-top { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; color: white; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
.hud-box { background: rgba(0, 0, 0, 0.5); padding: 10px 20px; border-radius: 20px; border: 1px solid #444; }

#damage-display { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 140px; background: rgba(0, 20, 40, 0.8); border: 2px solid #00d4ff; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
#damage-label { color: #00d4ff; font-size: 10px; margin-bottom: 5px; text-transform: uppercase; }
#damage-canvas { width: 80px; height: 100px; }

#xp-bar-container { position: absolute; top: 60px; left: 50%; transform: translateX(-50%); width: 400px; height: 10px; background: #222; border: 1px solid #555; border-radius: 5px; }
#xp-bar-fill { height: 100%; background: #ffd700; width: 0%; transition: width 0.2s; box-shadow: 0 0 10px #ffd700; }
#xp-text { text-align: center; color: #ffd700; font-size: 12px; margin-top: 2px; }

#element-bar-container { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); width: 400px; height: 10px; background: #222; border: 1px solid #555; border-radius: 5px; margin-top: 5px; }
#element-bar-fill { height: 100%; background: linear-gradient(90deg, #ff4444, #4488ff, #44aa44, #88ccff); width: 0%; transition: width 0.2s; }
#element-text { text-align: center; color: #aaa; font-size: 12px; margin-top: 2px; }

#wave-timer-container { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; color: white; }
#wave-timer-bar { width: 200px; height: 6px; background: #222; border: 1px solid #555; border-radius: 3px; margin-top: 5px; }
#wave-timer-fill { height: 100%; background: #00d4ff; width: 100%; }

#cards-display { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; width: 300px; }
.card-slot { width: 80px; height: 100px; background: rgba(0, 0, 0, 0.5); border: 1px solid #444; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-size: 12px; text-align: center; }
.card-slot.empty { border: 1px dashed #666; }
.card-rarity-common { border-top: 3px solid #aaa; }
.card-rarity-rare { border-top: 3px solid #44aaff; }
.card-rarity-epic { border-top: 3px solid #aa44ff; }
.card-rarity-legendary { border-top: 3px solid #ffaa44; }
.card-rarity-mythic { border-top: 3px solid #ff44aa; }

/* Menus */
#wave-menu, #card-pickup, #game-over, #element-selection, #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; cursor: default; }
#wave-menu { background: rgba(10, 10, 25, 0.95); }
#card-pickup { background: rgba(10, 10, 25, 0.95); z-index: 150; }
#game-over { background: rgba(0, 0, 0, 0.9); z-index: 200; color: white;}
#element-selection { background: rgba(10, 10, 25, 0.95); z-index: 150; }
#start-screen { background: #050510; display: flex; z-index: 200; }

.btn { padding: 15px 50px; font-size: 24px; background: #00d4ff; border: none; color: #000; font-weight: 800; cursor: pointer; border-radius: 5px; box-shadow: 0 0 25px rgba(0, 212, 255, 0.5); text-transform: uppercase; margin-top: 20px; }
.btn:hover { background: white; box-shadow: 0 0 40px white; }
.element-option { width: 200px; height: 200px; margin: 20px; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.3s; }
.element-option:hover { transform: scale(1.1); }
.element-fire { background: linear-gradient(135deg, #ff4444, #ff8800); }
.element-water { background: linear-gradient(135deg, #4488ff, #44ccff); }
.element-earth { background: linear-gradient(135deg, #44aa44, #88cc44); }
.element-air { background: linear-gradient(135deg, #88ccff, #ffffff); }
.element-icon { font-size: 60px; margin-bottom: 15px; }
.element-name { font-size: 24px; font-weight: bold; color: white; }

.upgrade-tree { display: flex; flex-direction: column; align-items: center; width: 80%; max-width: 800px; }
.tree-row { display: flex; justify-content: center; flex-wrap: wrap; gap: 30px; margin: 20px 0; }
.tree-node { width: 180px; height: 180px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #00d4ff; border-radius: 15px; display: flex; flex-direction: column; align-items: center; padding: 15px; cursor: pointer; color: white; transition: 0.3s; box-shadow: 0 0 15px rgba(0, 212, 255, 0.2); position: relative; }
.tree-node:hover:not(.purchased):not(.locked) { transform: translateY(-5px); box-shadow: 0 0 25px rgba(0, 212, 255, 0.6); background: #202040; }
.tree-node.locked { opacity: 0.2; cursor: not-allowed; border-color: #555; filter: grayscale(100%); }
.tree-node.locked::after { content: "‚ùå"; position: absolute; top: 5px; right: 5px; font-size: 20px; }
.tree-node.unlocked::after { content: "‚úì"; position: absolute; top: 5px; right: 5px; color: #44ff44; font-size: 20px; font-weight: bold; }
.tree-node.unlocked:not(.purchased) { opacity: 0.85; border-color: #44ff44; background: #112211; }
.tree-node.purchased { filter: grayscale(100%); opacity: 0.4; cursor: not-allowed; border-color: #555; }
.tree-node.purchased::after { content: "üîí"; position: absolute; top: 5px; right: 5px; font-size: 20px; }
.tree-node-icon { font-size: 40px; margin: 10px 0; }
.tree-node h3 { color: #00d4ff; margin: 5px 0; font-size: 16px; text-transform: uppercase; text-align: center; }
.tree-node p { color: #aaa; text-align: center; font-size: 12px; line-height: 1.3; height: 60px; overflow: hidden; }

.card-preview { width: 300px; height: 400px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #ff44aa; border-radius: 15px; display: flex; flex-direction: column; align-items: center; padding: 20px; color: white; box-shadow: 0 0 30px rgba(255, 68, 170, 0.5); }
.card-preview-icon { font-size: 80px; margin: 20px 0; }
.card-preview h2 { color: #ff44aa; margin: 10px 0; font-size: 24px; text-transform: uppercase; }
.card-rarity-tag { padding: 5px 15px; border-radius: 20px; font-weight: bold; margin: 10px 0; background: #333; }
.btn-small { padding: 10px 30px; font-size: 18px; background: #ff44aa; border: none; color: white; font-weight: 800; cursor: pointer; border-radius: 5px; margin-top: 20px; box-shadow: 0 0 15px rgba(255, 68, 170, 0.5); }
#notification { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); color: #ffd700; font-size: 40px; font-weight: 900; opacity: 0; text-shadow: 0 0 20px #ffaa00; pointer-events: none; transition: opacity 0.5s; text-align: center; z-index: 50; }
</style>
</head>
<body>

<div id="ui-layer">
  <div id="hud-top">
    <div class="hud-box">SCORE: <span id="score">0</span></div>
    <div id="wave-timer-container">
      <div style="font-size: 20px; font-weight: bold;">WAVE: <span id="wave">1</span></div>
      <div id="wave-timer-bar"><div id="wave-timer-fill"></div></div>
    </div>
    <div class="hud-box" style="color:#00d4ff">LEVEL: <span id="level">1</span></div>
  </div>
  <div id="xp-bar-container"><div id="xp-bar-fill"></div><div id="xp-text">NEXT UPGRADE</div></div>
  <div id="element-bar-container"><div id="element-bar-fill"></div><div id="element-text">ELEMENT POWER</div></div>
  <div id="damage-display"><div id="damage-label">SHIP STATUS</div><canvas id="damageCanvas" width="80" height="100"></canvas></div>
  <div id="cards-display"><div class="card-slot empty">EMPTY</div><div class="card-slot empty">EMPTY</div><div class="card-slot empty">EMPTY</div></div>
  <div id="notification">SYSTEMS REPAIRED</div>
</div>

<div id="start-screen">
  <div style="text-align: center;">
    <h1 style="color:#00d4ff; font-size: 80px; margin-bottom: 10px; text-shadow: 0 0 30px #00d4ff;">ACES GALAXY</h1>
    <p style="color:white; font-size: 18px; margin-bottom: 40px;">Move with MOUSE. Survive 10 waves!</p>
    <button class="btn" onclick="initGame()">LAUNCH MISSION</button>
  </div>
</div>

<div id="element-selection">
  <h1 style="color:#00d4ff; font-size: 40px; margin-bottom: 30px;">CHOOSE YOUR ELEMENT</h1>
  <div style="display: flex;">
    <div class="element-option element-fire" onclick="selectElement('FIRE')"><div class="element-icon">üî•</div><div class="element-name">FIRE</div></div>
    <div class="element-option element-water" onclick="selectElement('WATER')"><div class="element-icon">üíß</div><div class="element-name">WATER</div></div>
    <div class="element-option element-earth" onclick="selectElement('EARTH')"><div class="element-icon">üåç</div><div class="element-name">EARTH</div></div>
    <div class="element-option element-air" onclick="selectElement('AIR')"><div class="element-icon">üå™Ô∏è</div><div class="element-name">AIR</div></div>
  </div>
</div>

<div id="wave-menu">
  <h1 style="color: #ffd700; font-size: 40px; text-shadow: 0 0 15px #ffaa00;">LEVEL UP!</h1>
  <p style="color: white; margin-bottom: 20px;">CHOOSE YOUR UPGRADE PATH</p>
  <div class="upgrade-tree" id="upgrade-tree"></div>
</div>

<div id="card-pickup">
  <div class="card-preview" id="card-preview">
    <div class="card-preview-icon">?</div><h2 id="card-name">CARD NAME</h2><div class="card-rarity-tag" id="card-rarity">Rarity</div>
    <p id="card-desc">Card description</p><button class="btn-small" onclick="acceptCard()">EQUIP CARD</button>
  </div>
</div>

<div id="game-over">
  <h1 id="end-title" style="color:#ff4444; font-size: 60px;">CRITICAL FAILURE</h1>
  <div id="final-score" style="font-size: 30px; margin: 20px;">FINAL SCORE: 0</div>
  <p id="end-desc" style="color: #aaa; margin-bottom: 30px;">ALL SYSTEMS DESTROYED</p>
  <button id="end-btn" class="btn" onclick="restartGame()">RETRY MISSION</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const dmgCanvas = document.getElementById('damageCanvas');
const dmgCtx = dmgCanvas.getContext('2d');

let width, height, gameRunning = false, isPaused = false, frameCount = 0;
let currentLevel = 1, wave = 1, waveTimer = 0, bossActive = false;
let cardDroppedThisWave = false;
const FRAMES_PER_WAVE = 1800; 

// Intermission vars
let inIntermission = false;
let intermissionTimer = 0;
let intermissionIsBoss = false;

let score = 0, xp = 0, xpNeeded = 2000, elementPower = 0, maxElementPower = 100;
let pendingSupportPasses = 0, supportPassTimer = 0, bossSupportsUsed = 0;
let purchasedUpgrades = new Set();
let playerWeaponBranch = -1; 

const ELEMENTS = { NONE: '#ffffff', FIRE: '#ff4444', WATER: '#4488ff', EARTH: '#44aa44', AIR: '#88ccff' };
const ELEMENT_NAMES = { FIRE: 'Fire', WATER: 'Water', EARTH: 'Earth', AIR: 'Air' };
const RARITIES = ['common', 'rare', 'epic', 'legendary', 'mythic'];
const RARITY_COLORS = { common: '#aaa', rare: '#44aaff', epic: '#aa44ff', legendary: '#ffaa44', mythic: '#ff44aa' };

const ELEMENT_CARDS = {
  FIRE: [
    { name: "Inferno", desc: "+ Damage & Burn enemies", rarity: 'common', effect: 'burn' },
    { name: "Magma Burst", desc: "++ Damage & Explosive shots", rarity: 'rare', effect: 'explosive' },
    { name: "Phoenix", desc: "+++ Damage & Auto-Repair 1 Part", rarity: 'epic', effect: 'revive' },
    { name: "Solar Flare", desc: "++++ Damage & Chain lightning", rarity: 'legendary', effect: 'chain' },
    { name: "Supernova", desc: "MASSIVE Damage & Explosions", rarity: 'mythic', effect: 'supernova' }
  ],
  WATER: [
    { name: "Tidal Wave", desc: "+ Fire Rate & Push enemies", rarity: 'common', effect: 'pushback' },
    { name: "Ice Shard", desc: "++ Fire Rate & Slow enemies", rarity: 'rare', effect: 'slow' },
    { name: "Aqua Shield", desc: "+++ Fire Rate & Absorb Damage", rarity: 'epic', effect: 'shield' },
    { name: "Hydro Vortex", desc: "++++ Fire Rate & Pull enemies", rarity: 'legendary', effect: 'pull' },
    { name: "Ocean's Wrath", desc: "INSANE Fire Rate Boost", rarity: 'mythic', effect: 'minions' }
  ],
  EARTH: [
    { name: "Stone Skin", desc: "+ Defense & Armor", rarity: 'common', effect: 'armor' },
    { name: "Quake", desc: "++ Defense & Stun enemies", rarity: 'rare', effect: 'stun' },
    { name: "Gaia's Blessing", desc: "+++ Defense & Regen HP", rarity: 'epic', effect: 'regen' },
    { name: "Terra Firma", desc: "++++ Defense & Barriers", rarity: 'legendary', effect: 'barrier' },
    { name: "World Tree", desc: "GODLIKE Defense & Structures", rarity: 'mythic', effect: 'turrets' }
  ],
  AIR: [
    { name: "Gale Force", desc: "+ Speed & Maneuver", rarity: 'common', effect: 'speed' },
    { name: "Lightning Strike", desc: "++ Speed & Chain enemies", rarity: 'rare', effect: 'chain' },
    { name: "Storm Eye", desc: "+++ Speed & Dodge chance", rarity: 'epic', effect: 'dodge' },
    { name: "Tempest", desc: "++++ Speed & Wind Blades", rarity: 'legendary', effect: 'blades' },
    { name: "Celestial Wind", desc: "LIGHTSPEED & Teleportation", rarity: 'mythic', effect: 'teleport' }
  ]
};

const UPGRADE_TREE = {
  base: [
    { id: 'sniper', name: 'Sniper', icon: 'üéØ', desc: 'High damage, slow fire rate', unlocked: true, level: 0 },
    { id: 'machinegun', name: 'Machine Gun', icon: 'üî´', desc: 'Rapid continuous fire', unlocked: true, level: 0 },
    { id: 'shotgun', name: 'Shotgun', icon: 'üí•', desc: 'Wide spread, high close damage', unlocked: true, level: 0 }
  ],
  machinegun: {
    tier1: [ { id: 'mg_t1_1', name: 'Double Shot', icon: '‚ôä', desc: 'Fires 2 spread bullets', unlocked: false, level: 1 }, { id: 'mg_t1_2', name: '.50 Cal', icon: 'üß±', desc: 'High damage, slower fire', unlocked: false, level: 1 } ],
    tier2: [ { id: 'mg_t2_1', name: 'Triple Shot', icon: '‚ôà', desc: 'Fires 3 spread bullets', unlocked: false, level: 2 }, { id: 'mg_t2_2', name: '20mm Rounds', icon: 'üéØ', desc: 'Even higher damage', unlocked: false, level: 2 } ],
    tier3: [ { id: 'mg_t3_1', name: 'Cone Shot', icon: 'üåä', desc: '10-shot wide spread', unlocked: false, level: 3 }, { id: 'mg_t3_2', name: 'Max Fire Rate', icon: 'üî•', desc: 'Insane attack speed', unlocked: false, level: 3 } ]
  },
  shotgun: {
    tier1: [ { id: 'sg_t1_1', name: 'More Pellets', icon: 'Èú∞', desc: 'Fires 8 pellets', unlocked: false, level: 1 }, { id: 'sg_t1_2', name: 'Slug Round', icon: '‚òÑÔ∏è', desc: 'Single devastating shot', unlocked: false, level: 1 } ],
    tier2: [ { id: 'sg_t2_1', name: 'Wider & Pierce', icon: '‚ÜîÔ∏è', desc: 'Wider cone, bullets pierce', unlocked: false, level: 2 }, { id: 'sg_t2_2', name: 'Splinter Slug', icon: 'üéÜ', desc: 'Slug shatters into pellets on hit', unlocked: false, level: 2 } ],
    tier3: [ { id: 'sg_t3_1', name: 'Auto-Shotgun', icon: 'üîÑ', desc: 'Extremely fast fire rate', unlocked: false, level: 3 }, { id: 'sg_t3_2', name: 'Heavy Frame', icon: 'üèãÔ∏è', desc: 'Massive slug damage increase', unlocked: false, level: 3 } ]
  },
  sniper: {
    tier1: [ { id: 'sn_t1_1', name: 'Railgun', icon: 'üöÄ', desc: 'Pierce & Plasma Area', unlocked: false, level: 1 }, { id: 'sn_t1_2', name: 'Explosive Shell', icon: 'üí•', desc: 'Explodes on impact', unlocked: false, level: 1 } ],
    tier2: [ { id: 'sn_t2_1', name: 'Fast Charge', icon: '‚ö°', desc: 'Reduced fire delay', unlocked: false, level: 2 }, { id: 'sn_t2_2', name: 'Nuke Shell', icon: 'üçÑ', desc: 'Much larger explosion', unlocked: false, level: 2 } ],
    tier3: [ { id: 'sn_t3_1', name: 'Max Railgun', icon: 'üå†', desc: 'Extreme damage', unlocked: false, level: 3 }, { id: 'sn_t3_2', name: 'Auto-Sniper', icon: 'üîÑ', desc: 'Higher fire rate', unlocked: false, level: 3 } ]
  },
  ship: [
    { id: 'ship_speed', name: 'THRUSTERS', icon: 'üöÄ', desc: '+20% Movement Speed', unlocked: false },
    { id: 'ship_armor', name: 'ALLOY HULL', icon: 'üõ°Ô∏è', desc: 'Permanent +15% Damage Reduction', unlocked: false },
    { id: 'ship_regen', name: 'NANO BOTS', icon: 'üîß', desc: 'Slowly regenerate HP', unlocked: false }
  ]
};

let currentWeapon = null, currentWeaponTier = 0, currentElement = 'NONE';
let equippedCards = [null, null, null], pendingCard = null;

// Audio setup
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let noiseBuffer = null, bgmInterval = null, currentTheme = 'normal';

function initAudio() {
  if (!audioCtx || noiseBuffer) return;
  const bufferSize = audioCtx.sampleRate * 1.0; noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
}

function startBGM(theme = 'normal') {
  if (!audioCtx) return; 
  if (bgmInterval) clearInterval(bgmInterval);
  
  let notes = []; let speed = 220;
  if (theme === 'normal') { notes = [55, 55, 62, 55, 67, 55, 65, 62]; speed = 200; }
  else if (theme === 'boss1') { notes = [70, 71, 70, 65]; speed = 150; }
  else if (theme === 'boss2') { notes = [40, 43, 40, 38]; speed = 140; }
  else if (theme === 'boss3') { notes = [30, 35, 32, 40]; speed = 130; }
  else if (theme === 'secret') { notes = [85, 91, 84, 90, 83]; speed = 100; }
  
  currentTheme = theme;
  let step = 0;
  bgmInterval = setInterval(() => {
      if(!gameRunning) return;
      const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
      osc.type = theme === 'normal' ? 'sawtooth' : 'square'; 
      
      let note = notes[step % notes.length];
      if (theme === 'normal' && Math.random() < 0.25) note += (Math.random() > 0.5 ? 2 : -2); 
      
      osc.frequency.setValueAtTime(note * 1.5, now);
      let baseVolume = theme.startsWith('boss') || theme === 'secret' ? 0.9 : 0.6;
      gain.gain.setValueAtTime(baseVolume, now); 
      gain.gain.exponentialRampToValueAtTime(0.001, now + (speed/1000) * 0.8);
      osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + (speed/1000)); step++;
  }, speed);
}

function playRealisticGun(type) {
  if (!audioCtx || !noiseBuffer) return;
  const now = audioCtx.currentTime; const noiseSource = audioCtx.createBufferSource(); noiseSource.buffer = noiseBuffer;
  const filter = audioCtx.createBiquadFilter(); const gain = audioCtx.createGain();
  if (type === 'machinegun') { filter.type = 'bandpass'; filter.frequency.value = 1800; filter.Q.value = 0.8; gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08); } 
  else if (type === 'shotgun') { filter.type = 'lowpass'; filter.frequency.value = 1200; gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25); } 
  else if (type === 'sniper') { filter.type = 'highpass'; filter.frequency.value = 800; gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); } 
  else if (type === 'support') { filter.type = 'bandpass'; filter.frequency.value = 2200; gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); }
  noiseSource.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); noiseSource.start(now);
}

function playEnemyGun(type) {
  if (!audioCtx || !noiseBuffer) return;
  const now = audioCtx.currentTime; const ns = audioCtx.createBufferSource(); ns.buffer = noiseBuffer;
  const f = audioCtx.createBiquadFilter(); const g = audioCtx.createGain();
  if (type === 'tank') { f.type = 'lowpass'; f.frequency.value = 400; g.gain.setValueAtTime(0.4, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.3); }
  else if (type === 'speedy') { f.type = 'highpass'; f.frequency.value = 2500; g.gain.setValueAtTime(0.1, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.1); }
  else if (type === 'missile') { f.type = 'lowpass'; f.frequency.value = 800; g.gain.setValueAtTime(0.7, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.5); }
  else { f.type = 'bandpass'; f.frequency.value = 1000; g.gain.setValueAtTime(0.2, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.15); }
  ns.connect(f); f.connect(g); g.connect(audioCtx.destination); ns.start(now);
}

function playUpgradeSound() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.type = 'sine'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now + 0.2);
  gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
  osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.5);
}

function playEngineFlyby() {
  if (!audioCtx || !noiseBuffer) return;
  const now = audioCtx.currentTime; const ns = audioCtx.createBufferSource(); ns.buffer = noiseBuffer;
  const f = audioCtx.createBiquadFilter(); const g = audioCtx.createGain();
  f.type = 'lowpass'; f.frequency.setValueAtTime(100, now); f.frequency.linearRampToValueAtTime(800, now + 1.0); f.frequency.linearRampToValueAtTime(100, now + 2.5);
  g.gain.setValueAtTime(0.01, now); g.gain.linearRampToValueAtTime(0.6, now + 1.0); g.gain.linearRampToValueAtTime(0.01, now + 2.5);
  ns.connect(f); f.connect(g); g.connect(audioCtx.destination); ns.start(now);
}

function playImpactSound() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.type = 'square'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
  gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
  osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.1);
}

function drawDamageModel(parts) {
  dmgCtx.clearRect(0, 0, 80, 100);
  const getColor = (hp, max) => {
    if (hp <= 0) return '#000000'; const pct = hp / max;
    if (pct > 0.75) return '#00ff00'; if (pct > 0.5) return '#ffff00'; if (pct > 0.25) return '#ff8800'; return '#ff0000';
  };
  dmgCtx.fillStyle = getColor(parts.body.hp, parts.body.max); dmgCtx.fillRect(25, 20, 30, 40); dmgCtx.strokeStyle = '#005555'; dmgCtx.strokeRect(25, 20, 30, 40);
  dmgCtx.fillStyle = getColor(parts.leftWing.hp, parts.leftWing.max); dmgCtx.beginPath(); dmgCtx.moveTo(25, 35); dmgCtx.lineTo(5, 55); dmgCtx.lineTo(25, 65); dmgCtx.fill(); dmgCtx.stroke();
  dmgCtx.fillStyle = getColor(parts.rightWing.hp, parts.rightWing.max); dmgCtx.beginPath(); dmgCtx.moveTo(55, 35); dmgCtx.lineTo(75, 55); dmgCtx.lineTo(55, 65); dmgCtx.fill(); dmgCtx.stroke();
  dmgCtx.fillStyle = getColor(parts.engine.hp, parts.engine.max); dmgCtx.fillRect(30, 65, 20, 25); dmgCtx.strokeRect(30, 65, 20, 25);
  dmgCtx.fillStyle = getColor(parts.gun.hp, parts.gun.max); dmgCtx.fillRect(35, 12, 10, 12); dmgCtx.strokeRect(35, 12, 10, 12);
}

class Player {
  constructor() {
    this.x = window.innerWidth / 2; this.y = window.innerHeight - 100; this.size = 65; 
    this.parts = { body: { hp: 120, max: 120 }, leftWing: { hp: 80, max: 80 }, rightWing: { hp: 80, max: 80 }, engine: { hp: 100, max: 100 }, gun: { hp: 90, max: 90 } };
    this.speed = 0.3; this.damage = 15; this.fireRate = 8; this.fireTimer = 0; 
    this.element = 'NONE'; this.weaponType = 'base'; this.shotCount = 1; this.spreadAngle = 0;
    this.effects = {}; this.firstShot = true; this.backupGun = false; this.invincibleTimer = 0;
    
    this.damageMultiplier = 1; this.fireRateMultiplier = 1; this.speedMultiplier = 1; this.defenseMultiplier = 1;
  }
  
  isDead() { return this.parts.body.hp <= 0 || this.parts.engine.hp <= 0 || (this.parts.leftWing.hp <= 0 && this.parts.rightWing.hp <= 0); }

  takeDamage(amount, relX, relY) {
      if (this.effects.invincible) return;
      if (this.element === 'AIR' && Math.random() < 0.15) { spawnParticles(this.x, this.y, '#ffffff', 10); return; }
      if (this.effects.dodge && Math.random() < 0.15) { spawnParticles(this.x, this.y, '#ffffff', 10); return; }

      let targetPart = 'body';
      if (relY > 18) targetPart = 'engine'; else if (relX < -18) targetPart = 'leftWing'; else if (relX > 18) targetPart = 'rightWing'; else if (Math.random() < 1) targetPart = 'gun';
      if (targetPart === 'engine' && this.parts.body.hp > 0) amount *= 0.5;
      if (this.parts[targetPart].hp <= 0) { const alive = Object.keys(this.parts).filter(k => this.parts[k].hp > 0); if (alive.length > 0) targetPart = alive[0]; else return; }
      this.parts[targetPart].hp -= amount; drawDamageModel(this.parts); playImpactSound();
  }

  update() {
    let baseSpeed = 0.3; let elementDmgMult = 1.0; let elementFRMult = 1.0;
    
    if (this.element === 'FIRE') elementDmgMult = 1.15; 
    else if (this.element === 'WATER') elementFRMult = 1.15;
    else if (this.element === 'EARTH') { this.effects.elementArmor = true; }
    else if (this.element === 'AIR') { baseSpeed *= 1.25; }

    this.speed = (baseSpeed + (this.effects.speed || 0)) * this.speedMultiplier;
    
    if (this.parts.engine.hp <= 0) { this.speed = 0.08; if (frameCount % 12 === 0) this.parts.body.hp -= 3; }
    if (this.parts.leftWing.hp <= 0 && this.parts.rightWing.hp <= 0) { showGameOver(); return; }
    if (this.parts.leftWing.hp <= 0 || this.parts.rightWing.hp <= 0) this.speed *= 0.65;
    
    let wDamage = 15; let wFireRate = 8; let wShotCount = 1; let wSpread = 0;
    
    this.effects.pierce = false; this.isSlug = false; this.effects.splinter = false;
    this.effects.plasmaArea = false; this.effects.bigExplosion = false; this.effects.explosive = false;

    if (this.weaponType === 'sniper') {
        wDamage = 200; wFireRate = 48; wShotCount = 1; wSpread = 0;
        if(purchasedUpgrades.has('sn_t1_1')) { this.effects.pierce = true; this.effects.plasmaArea = true; wDamage *= 1.3; }
        if(purchasedUpgrades.has('sn_t2_1')) { wFireRate = 30; }
        if(purchasedUpgrades.has('sn_t3_1')) { wDamage *= 2.5; }
        if(purchasedUpgrades.has('sn_t1_2')) { this.effects.explosive = true; wDamage *= 0.8; }
        if(purchasedUpgrades.has('sn_t2_2')) { this.effects.bigExplosion = true; }
        if(purchasedUpgrades.has('sn_t3_2')) { wFireRate = 26; }
    } else if (this.weaponType === 'machinegun') {
        wDamage = 10; wFireRate = 8; wShotCount = 1; wSpread = 0;
        if(purchasedUpgrades.has('mg_t1_1')) { wShotCount = 2; wSpread = 0.3; }
        if(purchasedUpgrades.has('mg_t2_1')) { wShotCount = 3; wSpread = 0.45; }
        if(purchasedUpgrades.has('mg_t3_1')) { wShotCount = 10; wSpread = 1.0; wDamage *= 0.5; }
        if(purchasedUpgrades.has('mg_t1_2')) { wDamage *= 2.5; wFireRate = 12; }
        if(purchasedUpgrades.has('mg_t2_2')) { wDamage *= 1.8; }
        if(purchasedUpgrades.has('mg_t3_2')) { wFireRate = 2; }
    } else if (this.weaponType === 'shotgun') {
        wDamage = 30; wFireRate = 26; wShotCount = 5; wSpread = 0.8;
        if(purchasedUpgrades.has('sg_t1_1')) { wShotCount = 8; }
        if(purchasedUpgrades.has('sg_t2_1')) { wSpread = 1.3; this.effects.pierce = true; }
        if(purchasedUpgrades.has('sg_t3_1')) { wFireRate = 14; }
        if(purchasedUpgrades.has('sg_t1_2')) { wShotCount = 1; wSpread = 0; wDamage *= 5.0; this.isSlug = true; }
        if(purchasedUpgrades.has('sg_t2_2')) { this.effects.pierce = true; this.effects.splinter = true; }
        if(purchasedUpgrades.has('sg_t3_2')) { wDamage *= 2.5; }
    }

    if (this.parts.gun.hp <= 0) { this.backupGun = true; wDamage *= 0.55; wFireRate *= 2.2; } else this.backupGun = false;
    
    this.damage = wDamage * elementDmgMult * this.damageMultiplier;
    this.fireRate = Math.max(1, (wFireRate / elementFRMult) / this.fireRateMultiplier);
    this.shotCount = wShotCount;
    this.spreadAngle = wSpread;

    if (this.effects.armor) this.damage *= (0.75 * this.defenseMultiplier);
    
    this.x += (mouse.x - this.x) * this.speed; this.y += (mouse.y - this.y) * this.speed;
    if(this.x < 30) this.x = 30; if(this.x > width-30) this.x = width-30;
    if(this.y < 30) this.y = 30; if(this.y > height-30) this.y = height-30;

    if (this.effects.invincible) { this.invincibleTimer--; if (this.invincibleTimer <= 0) this.effects.invincible = false; }
    if (this.effects.regen && frameCount % 60 === 0) {
        let worst = null; let minPct = 1;
        for (let k in this.parts) { let p = this.parts[k]; if (p.hp > 0 && p.hp < p.max && (p.hp/p.max) < minPct) { worst = k; minPct = p.hp/p.max; } }
        if (worst) { this.parts[worst].hp += 8 * this.defenseMultiplier; drawDamageModel(this.parts); }
    }
    if (this.effects.supernova && frameCount % 600 === 0) {
      spawnParticles(this.x, this.y, '#ff4444', 100);
      enemies.forEach(enemy => { enemy.hp -= 350 * this.damageMultiplier; if (enemy.hp <= 0) killEnemy(enemy); });
    }

    this.fireTimer++;
    if (this.fireTimer >= this.fireRate) {
      this.shoot(); this.fireTimer = 0;
      if (this.weaponType !== 'base') playRealisticGun(this.weaponType);
    }
  }

  shoot() {
    const color = ELEMENTS[this.element];
    const angleStep = this.shotCount > 1 ? this.spreadAngle / (this.shotCount - 1) : 0;
    
    let special = { 
        isSlug: this.isSlug, 
        splinter: this.effects.splinter, 
        plasmaArea: this.effects.plasmaArea, 
        bigExplosion: this.effects.bigExplosion 
    };

    for (let i = 0; i < this.shotCount; i++) {
      const angle = this.shotCount > 1 ? (-this.spreadAngle/2 + i * angleStep) : 0;
      const vx = Math.sin(angle) * 3.5; const vy = -Math.cos(angle) * 19;
      bullets.push(new Bullet(this.x, this.y - 45, vx, vy, color, false, this.element, this.effects.explosive, this.damage, special));
    }

    if (this.weaponType === 'sniper' && !this.effects.bigExplosion) {
        bullets.push(new Bullet(this.x - 20, this.y - 20, -4, -15, color, false, this.element, false, this.damage * 0.10));
        bullets.push(new Bullet(this.x + 20, this.y - 20, 4, -15, color, false, this.element, false, this.damage * 0.10));
    }
  }

  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.scale(2, 2);
    if (this.effects.invincible) {
        ctx.shadowBlur = 20; ctx.shadowColor = '#00d4ff'; ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(0, 0, 18 + Math.sin(frameCount * 0.1) * 2, 0, Math.PI*2); ctx.stroke();
    }
    if (this.parts.engine.hp > 0) {
        let flameH = 22 + Math.random() * 12; let grad = ctx.createLinearGradient(0, 18, 0, 18 + flameH);
        grad.addColorStop(0, '#00ffff'); grad.addColorStop(1, 'rgba(0, 255, 255, 0)'); ctx.fillStyle = grad;
        ctx.beginPath(); ctx.moveTo(-5, 18); ctx.lineTo(0, 18+flameH); ctx.lineTo(5, 18); ctx.fill();
        ctx.shadowBlur = 18; ctx.shadowColor = '#00d4ff';
    }
    const drawVisualPart = (hp, max, points) => {
        if (hp <= 0) { ctx.fillStyle = '#111'; ctx.strokeStyle = '#333'; } 
        else {
            const pct = hp/max; let baseColor = pct > 0.5 ? '#e0e0e0' : (pct > 0.25 ? '#aa7700' : '#880000');
            let grad = ctx.createLinearGradient(-12, -12, 12, 12); grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.3, baseColor); grad.addColorStop(1, '#444455');
            ctx.fillStyle = grad; ctx.strokeStyle = '#00d4ff';
        }
        ctx.lineWidth = 0.6; ctx.beginPath(); ctx.moveTo(points[0][0], points[0][1]);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i][0], points[i][1]); ctx.closePath(); ctx.fill(); ctx.stroke();
    };
    drawVisualPart(this.parts.body.hp, this.parts.body.max, [[-8, -22], [8, -22], [12, 14], [-12, 14]]);
    drawVisualPart(this.parts.leftWing.hp, this.parts.leftWing.max, [[-9, -4], [-26, 12], [-26, 22], [-8, 18]]);
    drawVisualPart(this.parts.rightWing.hp, this.parts.rightWing.max, [[9, -4], [26, 12], [26, 22], [8, 18]]);
    if (this.parts.gun.hp > 0) { ctx.fillStyle = '#aaaaaa'; ctx.fillRect(-4, -28, 8, 14); ctx.strokeStyle = '#00d4ff'; ctx.strokeRect(-4, -28, 8, 14); } 
    else { ctx.fillStyle = '#555555'; ctx.fillRect(-3, -26, 6, 10); }
    if(this.element !== 'NONE' && this.parts.body.hp > 0) { ctx.shadowBlur = 12; ctx.shadowColor = ELEMENTS[this.element]; ctx.strokeStyle = ELEMENTS[this.element]; ctx.lineWidth = 2; ctx.stroke(); ctx.shadowBlur = 0; }
    ctx.restore();
  }
}

class SupportShip {
  constructor(x, y, vx = 0, vy = -18, rotation = 0, delay = 0) { 
      this.x = x; this.y = y; this.vx = vx; this.vy = vy; 
      this.rotation = rotation; this.marked = false; this.fireTimer = 14; 
      this.delay = delay; 
  }
  update() {
    if (this.delay > 0) { this.delay--; return; } 

    this.x += this.vx; this.y += this.vy; this.fireTimer++;
    if (this.fireTimer >= 10) {
      this.fireTimer = 0;
      for(let i = -4; i <= 5; i++) {
          let angle = this.rotation - Math.PI/2 + (i * 0.12);
          bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*28, Math.sin(angle)*28, '#00ffcc', false, 'NONE', false, 60));
      }
      playRealisticGun('support');
    }
    if (this.y < -400 || this.y > height + 400 || this.x < -400 || this.x > width + 400) this.marked = true;
  }
  draw() {
    if (this.delay > 0) return; 

    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.scale(6, 6); ctx.shadowBlur = 15; ctx.shadowColor = '#00ffcc';
    ctx.fillStyle = '#113355'; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-15, 10); ctx.lineTo(15, 10); ctx.fill();
    ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#00ffff'; ctx.fillRect(-3, -10, 6, 12);
    ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.moveTo(-8, 10); ctx.lineTo(-8, 20); ctx.lineTo(-4, 10); ctx.fill();
    ctx.beginPath(); ctx.moveTo(8, 10); ctx.lineTo(8, 20); ctx.lineTo(4, 10); ctx.fill(); ctx.restore();
  }
}

class Enemy {
  constructor(waveDiff, isFormation = false, startX, startY, endX, endY, delay = 0) {
    let maxType = 2; if (wave >= 4) maxType = 4; if (wave >= 7) maxType = 6;
    this.type = Math.floor(Math.random() * (maxType + 1));
    this.formationType = isFormation;
    
    let rand = Math.random();
    this.subType = 'normal';
    if (rand < 0.05) this.subType = 'tank'; 
    else if (rand < 0.25) this.subType = 'speedy';
    else if (rand < 0.35) this.subType = 'kamikaze';
    
    this.hp = (32 + (waveDiff * 11) + (this.type * 22)) * 1.0; this.maxHp = this.hp; this.size = 32 + (this.type * 4);
    this.behavior = 'homing';
    let r = Math.random(); if (r < 0.25) this.behavior = 'hover'; else if (r < 0.5) this.behavior = 'sine';
    
    if (this.formationType === 'v-form' || this.formationType === 'line') {
      this.behavior = 'strafe_down'; this.x = startX; this.y = startY; this.rotation = Math.PI; 
    } else if (this.formationType === 'arc') {
      this.t = -0.1 * delay; this.p0 = {x: startX, y: startY}; this.p2 = {x: endX, y: endY};
      let cx = width/2; if (startX < width/2) cx = width * 0.22; else cx = width * 0.78;
      this.p1 = {x: cx, y: height * 0.42}; this.x = startX; this.y = startY; this.rotation = 0;
    } else {
      this.x = Math.random() * (width - 80) + 40; this.y = -60; this.targetY = 80 + Math.random() * 200;
      this.xOffset = Math.random() * 200; this.rotation = 0;
    }

    this.fireTimer = Math.random() * 90; this.fireInterval = Math.max(90, 150 - (waveDiff * 2) - (this.type * 4));
    this.speed = 1.4 + waveDiff * 0.08; 
    this.damage = Math.min(50, (11 + waveDiff * 2.2) * 1.0); 
    
    if (this.subType === 'tank') {
        this.hp *= 10; this.maxHp = this.hp; this.speed *= 0.5; this.size *= 1.4;
        this.fireInterval *= 2.5; this.bulletSize = 12; this.bulletDmgMult = 3.0;
    } else if (this.subType === 'speedy') {
        this.hp *= 0.5; this.maxHp = this.hp; this.speed *= 2.2; this.size *= 0.5; 
        this.fireInterval *= 0.3; this.bulletSize = 4; this.bulletDmgMult = 0.4;
    } else if (this.subType === 'kamikaze') {
        this.hp *= 0.6; this.maxHp = this.hp; this.speed *= 3; this.behavior = 'kamikaze';
        this.missileTimer = 150 + Math.random() * 150; 
    }

    this.slowed = false; this.stunned = false; this.stunTimer = 0; this.burnTimer = 0;
  }

  update() {
    if (this.stunned) { this.stunTimer--; if (this.stunTimer <= 0) this.stunned = false; else return; }
    if (this.burnTimer > 0) { 
        this.burnTimer--; this.hp -= 1.5 * player.damageMultiplier; 
        if(frameCount % 10 === 0) spawnParticles(this.x, this.y, '#ff4400', 3);
        if (this.hp <= 0) { killEnemy(this); return; } 
    }
    
    const speedMult = this.slowed ? 0.40 : 1; 

    if (this.behavior === 'kamikaze') {
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        this.x += Math.cos(angle) * this.speed * speedMult;
        this.y += Math.sin(angle) * this.speed * speedMult;
        this.rotation = angle - Math.PI/2;
        
        this.missileTimer--;
        if (this.missileTimer <= 0) {
            this.missileTimer = 300; 
            this.shootMissile();
        }
    } else if (this.formationType === 'v-form' || this.formationType === 'line') {
       this.y += (this.speed * 1.3) * speedMult; if (this.y > height + 50) { enemies = enemies.filter(e => e !== this); return; }
    } else if (this.formationType === 'arc') {
      this.t += 0.006 * speedMult; if (this.t < 0) return;
      const u = 1 - this.t; const tt = this.t * this.t; const uu = u * u;
      const oldX = this.x; const oldY = this.y;
      this.x = (uu * this.p0.x) + (2 * u * this.t * this.p1.x) + (tt * this.p2.x); this.y = (uu * this.p0.y) + (2 * u * this.t * this.p1.y) + (tt * this.p2.y);
      if (this.t > 0.01) this.rotation = Math.atan2(this.y - oldY, this.x - oldX) - Math.PI/2;
      if (this.t > 1.15) { enemies = enemies.filter(e => e !== this); return; }
    } else {
      if (this.behavior === 'hover') {
          if (this.y < this.targetY) this.y += this.speed * speedMult;
          else { this.x += (player.x - this.x) * 0.01 * speedMult; this.y += Math.sin(frameCount * 0.05) * 0.8; }
      } else if (this.behavior === 'sine') {
          this.y += (this.speed * 0.7) * speedMult; this.x += Math.sin(frameCount * 0.02 + this.xOffset) * 4 * speedMult;
      } else {
          if (this.y < this.targetY) this.y += this.speed * speedMult * 0.9;
          else { this.x += (player.x - this.x) * 0.009 * speedMult; this.x += Math.cos(frameCount * 0.011 + this.xOffset) * 1.1; }
      }
      this.rotation = Math.PI + Math.sin(frameCount * 0.04) * 0.2;
    }
    
    if (this.subType !== 'kamikaze' && !inIntermission) {
        this.fireTimer--;
        if (this.fireTimer <= 0 && this.y > 30 && this.y < height - 50) { this.fireTimer = this.fireInterval; this.shoot(); }
    }
  }
  
  shootMissile() {
      const angle = Math.atan2(player.y - this.y, player.x - this.x);
      let b = new Bullet(this.x, this.y + 20, Math.cos(angle)*7, Math.sin(angle)*7, '#ff8800', true, 'NONE', false, this.damage * 2.5, { isMissile: true });
      bullets.push(b);
      playEnemyGun('missile');
  }

  shoot() {
    const bulletSpeed = this.subType === 'tank' ? 4.5 : 5.5; 
    const angle = Math.atan2(player.y - this.y, player.x - this.x);
    let dmg = this.damage * (this.bulletDmgMult || 1);
    let b = new Bullet(this.x, this.y + 25, Math.cos(angle)*bulletSpeed, Math.sin(angle)*bulletSpeed, '#ff5555', true, 'NONE', false, dmg);
    b.size = this.bulletSize || 7;
    bullets.push(b);
    playEnemyGun(this.subType);
  }
  
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); 
    
    if (this.subType === 'tank') ctx.scale(2, 2);
    else if (this.subType === 'speedy') ctx.scale(0.6, 0.6);

    if (this.subType === 'kamikaze') {
        ctx.shadowBlur = 60; ctx.shadowColor = '#ff3300'; ctx.fillStyle = '#ff3300';
        ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(-12, -15); ctx.lineTo(12, -15); ctx.fill();
    } else {
        ctx.shadowBlur = 48; ctx.shadowColor = this.type === 6 ? '#ff0055' : (this.type < 3 ? '#ff3333' : '#aa00ff');
        ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.moveTo(-6, -24); ctx.lineTo(0, -38); ctx.lineTo(6, -24); ctx.fill();
        ctx.fillStyle = this.slowed ? '#0077ff' : (this.type === 6 ? '#880022' : (this.type < 3 ? '#660000' : '#440066'));
        ctx.beginPath(); ctx.moveTo(-14, 12); ctx.lineTo(14, 12); ctx.lineTo(22, -8); ctx.lineTo(0, -26); ctx.lineTo(-22, -8); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ffdd88'; ctx.fillRect(-4, -12, 8, 18);
    }
    
    if (this.hp < this.maxHp) { ctx.fillStyle = '#222'; ctx.fillRect(-this.size/1.8, this.size/1.6, this.size*1.1, 5); ctx.fillStyle = '#ff2222'; ctx.fillRect(-this.size/1.8, this.size/1.6, this.size*1.1 * (this.hp/this.maxHp), 5); }
    ctx.restore();
  }
}

function getPlayerPowerMultiplier() {
    let mult = 1.0;
    mult += purchasedUpgrades.size * 0.15;
    if (player.weaponType !== 'base') mult += 0.2;
    let cardCount = equippedCards.filter(c => c !== null).length;
    mult += cardCount * 0.25;
    return mult;
}

class Boss {
  constructor(waveNum) {
    this.waveNum = waveNum; this.isBoss = true; 
    let opMult = getPlayerPowerMultiplier();
    
    if (waveNum === 3) { this.hp = 4000 * opMult; this.speed = 1.5; }
    else if (waveNum === 6) { this.hp = 6000 * opMult; this.speed = 1.8; }
    else if (waveNum === 9) { this.hp = 9000 * opMult; this.speed = 2.8; }
    
    this.maxHp = this.hp; 
    this.size = waveNum === 6 ? 150 : 115; 
    
    const spawnSides = ['top', 'left', 'right'];
    const side = spawnSides[Math.floor(Math.random() * spawnSides.length)];
    if (side === 'top') { this.x = width / 2; this.y = -300; }
    else if (side === 'left') { this.x = -300; this.y = 100; }
    else if (side === 'right') { this.x = width + 300; this.y = 100; }
    
    this.targetX = width / 2;
    this.targetY = waveNum === 6 ? 110 : 160; 
    this.introPhase = true;

    this.fireTimer = 0; this.fireInterval = waveNum === 9 ? 18 : (waveNum === 6 ? 50 : 30);
    this.pattern = 0; this.patternTimer = 0;
    this.burnTimer = 0; this.hitCount = 0; this.direction = 1; this.slowed = false;
  }
  update() {
    if (this.burnTimer > 0) { this.burnTimer--; this.hp -= 2.4 * player.damageMultiplier; if(frameCount%5===0) spawnParticles(this.x, this.y, '#ff4400', 3); if (this.hp <= 0) { killEnemy(this); return; } }
    
    const speedMult = this.slowed ? 0.60 : 1;

    if (this.introPhase) {
        let dx = this.targetX - this.x; let dy = this.targetY - this.y; let dist = Math.hypot(dx, dy);
        if (dist > 10) { 
            this.x += (dx/dist) * this.speed * 2.5 * speedMult; 
            this.y += (dy/dist) * this.speed * 2.5 * speedMult; 
        } else { 
            this.x = this.targetX; this.y = this.targetY; this.introPhase = false; 
        }
    } else {
        if (this.waveNum === 6) {
            this.x += this.speed * 2 * this.direction * speedMult; if(this.x < width*0.2 || this.x > width*0.8) this.direction *= -1; 
        } else if (this.waveNum === 9) {
            this.x += Math.sin(frameCount * 0.03) * 7.5 * speedMult; this.y = this.targetY + Math.sin(frameCount * 0.04) * 60; 
        } else {
            this.x += this.speed * 3 * this.direction * speedMult; if(this.x < width*0.15 || this.x > width*0.85) { this.direction *= -1; this.y += 20; if(this.y > 300) this.y = this.targetY; } 
        }
    }

    if(!inIntermission){
        this.patternTimer++; if (this.patternTimer >= 140) { this.pattern = (this.pattern + 1) % 4; this.patternTimer = 0; }
        this.fireTimer++; if (this.fireTimer >= this.fireInterval) { this.fireTimer = 0; this.shoot(); }
    }
  }
  shoot() {
    playEnemyGun('tank');
    const angle = Math.atan2(player.y - this.y, player.x - this.x);
    if (this.waveNum === 6) {
       if (this.pattern % 2 === 0) {
          for(let i=-4; i<=4; i++) bullets.push(new Bullet(this.x, this.y, Math.cos(angle + i*0.20)*4.5, Math.sin(angle + i*0.20)*4.5, '#ffaa00', true, 'NONE', true, 50));
       } else {
          bullets.push(new Bullet(this.x, this.y, 0, 8, '#ff0000', true, 'NONE', true, 100));
          bullets.push(new Bullet(this.x-100, this.y, 0, 8, '#ff0000', true, 'NONE', true, 100));
          bullets.push(new Bullet(this.x+100, this.y, 0, 8, '#ff0000', true, 'NONE', true, 100));
       }
    } else if (this.waveNum === 9) {
       if (this.pattern < 2) {
          bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*12, Math.sin(angle)*12, '#00ffff', true, 'NONE', false, 30));
          bullets.push(new Bullet(this.x, this.y, Math.cos(angle+0.15)*11, Math.sin(angle+0.15)*11, '#00ffff', true, 'NONE', false, 30));
          bullets.push(new Bullet(this.x, this.y, Math.cos(angle-0.15)*11, Math.sin(angle-0.15)*11, '#00ffff', true, 'NONE', false, 30));
       } else {
          for(let i=0; i<12; i++) { let a = (i/12)*Math.PI*2 + frameCount*0.1; bullets.push(new Bullet(this.x, this.y, Math.cos(a)*6.5, Math.sin(a)*6.5, '#ffffff', true, 'NONE', false, 24)); }
       }
    } else {
       if (this.pattern === 0) { for(let i=0; i<10; i++) { let a = (i / 10) * Math.PI * 2 + (frameCount * 0.04); bullets.push(new Bullet(this.x, this.y, Math.cos(a)*5.5, Math.sin(a)*5.5, '#ff55ff', true, 'NONE', false, 26)); } } 
       else if (this.pattern === 1) { for(let i=-2; i<=2; i++) bullets.push(new Bullet(this.x, this.y, Math.cos(angle + i*0.25)*7, Math.sin(angle + i*0.25)*7, '#ff55ff', true, 'NONE', false, 26)); } 
       else if (this.pattern === 2) { bullets.push(new Bullet(this.x-30, this.y, Math.cos(angle-0.3)*6, Math.sin(angle-0.3)*6, '#ff55ff', true, 'NONE', false, 26)); bullets.push(new Bullet(this.x+30, this.y, Math.cos(angle+0.3)*6, Math.sin(angle+0.3)*6, '#ff55ff', true, 'NONE', false, 26)); } 
       else { for(let i=0; i<14; i++) { const offset = (i - 7) * 0.22; bullets.push(new Bullet(this.x, this.y, Math.cos(angle + offset)*7.8, Math.sin(angle + offset)*7.8, '#ff55ff', true, 'NONE', false, 24)); } }
    }
  }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.shadowBlur = 20; ctx.lineWidth = 4;
    if (this.waveNum === 6) {
        ctx.shadowColor = '#ffaa00'; ctx.strokeStyle = '#ffaa00'; ctx.fillStyle = '#331100';
        ctx.beginPath(); ctx.moveTo(0, 80); ctx.lineTo(60, 40); ctx.lineTo(100, 0); ctx.lineTo(100, -40); ctx.lineTo(40, -40); ctx.lineTo(0, -60);
        ctx.lineTo(-40, -40); ctx.lineTo(-100, -40); ctx.lineTo(-100, 0); ctx.lineTo(-60, 40); ctx.closePath(); ctx.fill(); ctx.stroke();
    } else if (this.waveNum === 9) {
        ctx.shadowColor = '#00ffff'; ctx.strokeStyle = '#00ffff'; ctx.fillStyle = '#001133';
        ctx.beginPath(); ctx.moveTo(0, 100); ctx.lineTo(40, 20); ctx.lineTo(80, -20); ctx.lineTo(20, -50); ctx.lineTo(0, -30);
        ctx.lineTo(-20, -50); ctx.lineTo(-80, -20); ctx.lineTo(-40, 20); ctx.closePath(); ctx.fill(); ctx.stroke();
    } else {
        ctx.shadowColor = '#ff00ff'; ctx.strokeStyle = '#ff00ff'; ctx.fillStyle = '#220022';
        ctx.beginPath(); ctx.moveTo(0, 100); ctx.lineTo(70, 50); ctx.lineTo(90, 0); ctx.lineTo(50, -50); ctx.lineTo(0, -30);
        ctx.lineTo(-50, -50); ctx.lineTo(-90, 0); ctx.lineTo(-70, 50); ctx.closePath(); ctx.fill(); ctx.stroke();
    }
    if(this.slowed) { ctx.fillStyle = 'rgba(0,100,255,0.4)'; ctx.fill(); }
    ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(0, -10, 20, 0, Math.PI*2); ctx.fill(); ctx.restore();
    ctx.fillStyle = 'rgba(255,0,0,0.25)'; ctx.fillRect(width/2 - 240, 25, 480, 14); 
    ctx.fillStyle = this.waveNum === 6 ? '#ffaa00' : (this.waveNum === 9 ? '#00ffff' : '#ff00ff'); ctx.fillRect(width/2 - 240, 25, 480 * Math.max(0, this.hp/this.maxHp), 14);
  }
}

class SecretBoss {
  constructor() {
    this.isBoss = true; this.isSecret = true; 
    let opMult = getPlayerPowerMultiplier();
    this.hp = 18000 * opMult; this.maxHp = this.hp; this.size = 180;
    
    const spawnSides = ['top', 'left', 'right', 'bottom'];
    const side = spawnSides[Math.floor(Math.random() * spawnSides.length)];
    if (side === 'top') { this.x = width / 2; this.y = -300; }
    else if (side === 'left') { this.x = -300; this.y = 200; }
    else if (side === 'right') { this.x = width + 300; this.y = 200; }
    else if (side === 'bottom') { this.x = width / 2; this.y = height + 300; }
    
    this.targetX = width / 2;
    this.targetY = 200; 
    this.introPhase = true;

    this.fireTimer = 0; this.pattern = 0; this.patternTimer = 0;
    this.speed = 3.5; this.burnTimer = 0; this.angleOffset = 0; this.hitCount = 0; this.slowed = false;
  }
  update() {
    if (this.burnTimer > 0) { this.burnTimer--; this.hp -= 2.4 * player.damageMultiplier; if(frameCount%5===0) spawnParticles(this.x, this.y, '#ff4400', 3); if (this.hp <= 0) { killEnemy(this); return; } }
    
    const speedMult = this.slowed ? 0.60 : 1;

    if (this.introPhase) {
        let dx = this.targetX - this.x; let dy = this.targetY - this.y; let dist = Math.hypot(dx, dy);
        if (dist > 10) { 
            this.x += (dx/dist) * this.speed * 2.5 * speedMult; 
            this.y += (dy/dist) * this.speed * 2.5 * speedMult; 
        } else { 
            this.x = this.targetX; this.y = this.targetY; this.introPhase = false; 
        }
    } else {
        this.x = width/2 + Math.sin(frameCount * 0.02) * (width/3) * speedMult; 
        this.y = 200 + Math.cos(frameCount * 0.015) * 50; 
    }
    
    if(!inIntermission){
        this.angleOffset += 0.05 * speedMult; this.patternTimer++;
        if (this.patternTimer >= 200) { this.pattern = (this.pattern + 1) % 4; this.patternTimer = 0; }
        this.fireTimer++; let fireInterval = this.pattern === 0 ? 8 : (this.pattern === 1 ? 40 : (this.pattern === 3 ? 5 : 15));
        if (this.fireTimer >= fireInterval) { this.fireTimer = 0; this.shoot(); }
    }
  }
  shoot() {
    playEnemyGun('tank');
    const angle = Math.atan2(player.y - this.y, player.x - this.x);
    if (this.pattern === 0) { for (let i=0; i<4; i++) { let a = this.angleOffset + (i * Math.PI / 2); bullets.push(new Bullet(this.x, this.y, Math.cos(a)*6, Math.sin(a)*6, '#ff0000', true, 'NONE', false, 30)); } } 
    else if (this.pattern === 1) { for(let i=0; i<20; i++) { let a = (i / 20) * Math.PI * 2; bullets.push(new Bullet(this.x, this.y, Math.cos(a)*5, Math.sin(a)*5, '#ffaa00', true, 'NONE', false, 40)); } } 
    else if (this.pattern === 2) { for(let i=-3; i<=3; i++) { let a = angle + i*0.15; bullets.push(new Bullet(this.x, this.y, Math.cos(a)*8, Math.sin(a)*8, '#ffffff', true, 'NONE', false, 30)); } }
    else { let a = angle + Math.sin(frameCount*0.1)*0.5; bullets.push(new Bullet(this.x, this.y, Math.cos(a)*15, Math.sin(a)*15, '#ff0000', true, 'NONE', false, 60)); }
  }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angleOffset * 0.2); ctx.shadowBlur = 50; ctx.shadowColor = '#ff0000';
    ctx.fillStyle = '#110000'; ctx.beginPath();
    for (let i = 0; i < 8; i++) { let a = (i / 8) * Math.PI * 2; let r = i % 2 === 0 ? 120 : 60; ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r); }
    ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 6; ctx.stroke();
    if(this.slowed) { ctx.fillStyle = 'rgba(0,100,255,0.4)'; ctx.fill(); }
    ctx.fillStyle = '#ff5500'; ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI*2); ctx.fill(); ctx.restore();
    ctx.fillStyle = 'rgba(255,0,0,0.3)'; ctx.fillRect(width/2 - 300, 25, 600, 20); ctx.fillStyle = '#ff0000'; ctx.fillRect(width/2 - 300, 25, 600 * (this.hp/this.maxHp), 20);
  }
}

class Bullet {
  constructor(x, y, vx, vy, color, isEnemy, element = 'NONE', explosive = false, damage = 10, special = {}) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.color = color; this.isEnemy = isEnemy; this.element = element; this.explosive = explosive;
    this.marked = false; this.size = isEnemy ? 7 : (explosive ? 6 : 4.5); this.life = 110; this.damage = damage;
    this.special = special;
    this.hitList = new Set();
  }
  update() {
    this.x += this.vx; this.y += this.vy; if (!this.isEnemy) this.life--;
    
    if (this.special && this.special.isMissile && frameCount % 2 === 0) {
        spawnParticles(this.x, this.y - 10, '#aaaaaa', 2);
        spawnParticles(this.x, this.y - 12, '#ff4400', 1);
    }

    if (this.x < -60 || this.x > width+60 || this.y < -60 || this.y > height+60 || (!this.isEnemy && this.life <= 0)) {
      if (this.explosive && !this.isEnemy) {
        spawnParticles(this.x, this.y, this.color, 48);
        enemies.forEach(enemy => { const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y); if (dist < 115) { enemy.hp -= this.damage * 1.7; if (enemy.hp <= 0) killEnemy(enemy); } });
      }
      this.marked = true;
    }
  }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.shadowBlur = 11; ctx.shadowColor = this.color;
    if (!this.isEnemy && !this.explosive) {
        ctx.rotate(Math.atan2(this.vy, this.vx) + Math.PI/2);
    } else if (this.special && this.special.isMissile) {
        ctx.rotate(Math.atan2(this.vy, this.vx) + Math.PI/2);
    }

    if (this.special && this.special.isSlug) {
        ctx.fillStyle = '#ffeedd'; ctx.fillRect(-4, -18, 8, 36); ctx.shadowBlur = 15; ctx.shadowColor = '#ffffaa';
    } else if (this.special && this.special.isMissile) {
        ctx.fillStyle = '#ff8800';
        ctx.beginPath(); ctx.moveTo(0, 8); ctx.lineTo(4, 0); ctx.lineTo(4, -12); ctx.lineTo(-4, -12); ctx.lineTo(-4, 0); ctx.fill();
        ctx.fillStyle = '#ff2200'; ctx.fillRect(-2, -16, 4, 4);
    } else if (this.isEnemy) { 
        ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fill(); 
    } else { 
        if(this.explosive) { ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0,0,this.size*1.5, 0, Math.PI*2); ctx.fill(); } 
        ctx.fillStyle = this.color; ctx.fillRect(-2.5, -13, 5, 26); 
    }
    ctx.restore();
  }
}

class Drop {
  constructor(x, y, type) { this.x = x; this.y = y; this.vy = 2.2; this.type = type; this.marked = false; }
  update() { this.y += this.vy; if(this.y > height) this.marked = true; }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.shadowBlur = 16;
    if (this.type === 'HEAL') { ctx.fillStyle = '#00ff00'; ctx.shadowColor = '#00ff00'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.fillText('+', 0, 8); ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.stroke(); } 
    else if (this.type === 'CARD') { ctx.fillStyle = '#ff44aa'; ctx.shadowColor = '#ff44aa'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 18px Arial'; ctx.fillText('‚òÖ', 0, 7); } 
    else if (this.type === 'SUPPORT') { ctx.fillStyle = '#00d4ff'; ctx.shadowColor = '#00d4ff'; ctx.beginPath(); ctx.moveTo(0, -13); ctx.lineTo(9, 7); ctx.lineTo(0, 3); ctx.lineTo(-9, 7); ctx.fill(); }
    ctx.restore();
  }
}

class Particle {
  constructor(x, y, color) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 9; this.vy = (Math.random() - 0.5) * 9; this.life = 1.0; this.color = color; this.size = 1.6 + Math.random() * 2.4; }
  update() { this.x += this.vx; this.y += this.vy; this.life -= 0.045; }
  draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
}

class GalaxyBackground {
  constructor() { this.layers = []; this.initLayers(); }
  initLayers() {
    this.layers = []; 
    this.layers.push({ speed: 0.1, stars: [], color: () => `rgba(${200 + Math.random() * 55}, ${200 + Math.random() * 55}, ${255}, ${0.3 + Math.random() * 0.4})`, size: () => 0.5 + Math.random() * 1.5, count: 300 });
    this.layers.push({ speed: 0.3, clouds: [], color: () => ['rgba(100, 50, 200, 0.15)', 'rgba(150, 50, 255, 0.15)', 'rgba(200, 100, 255, 0.15)', 'rgba(50, 100, 255, 0.15)'][Math.floor(Math.random()*4)], size: () => 30 + Math.random() * 70, count: 15 });
    this.layers.push({ speed: 0.5, stars: [], color: () => `rgba(${255}, ${200 + Math.random() * 55}, ${100 + Math.random() * 155}, ${0.5 + Math.random() * 0.3})`, size: () => 1 + Math.random() * 2, count: 200 });
    
    this.layers.push({ 
        speed: 0.7, 
        objects: [], 
        createObject: () => { 
            const rand = Math.random();
            if (rand < 0.2) return { type: 'earth', size: 60 + Math.random()*40, color: '#2266cc' };
            if (rand < 0.4) return { type: 'sun', size: 100 + Math.random()*50, color: '#ffaa00' };
            if (rand < 0.6) return { type: 'station', size: 40 + Math.random()*30, color: '#888888' };
            if (rand < 0.8) return { type: 'planet', size: 80 + Math.random()*40, color: `hsl(${Math.random() * 360}, 60%, 40%)` };
            return { type: 'galaxy', size: 50 + Math.random() * 50, color: `rgba(${100 + Math.random() * 155}, ${50 + Math.random() * 100}, ${200 + Math.random() * 55}, 0.6)` };
        }, 
        count: 8 
    });
    this.layers.push({ speed: 1.0, stars: [], color: () => `rgba(255, 255, 255, ${0.7 + Math.random() * 0.3})`, size: () => 2 + Math.random() * 3, count: 100 });
    for (let layer of this.layers) {
      if (layer.stars) for (let i = 0; i < layer.count; i++) layer.stars.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, size: layer.size(), color: layer.color() });
      if (layer.clouds) for (let i = 0; i < layer.count; i++) layer.clouds.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, size: layer.size(), color: layer.color() });
      if (layer.objects) for (let i = 0; i < layer.count; i++) { const obj = layer.createObject(); layer.objects.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, ...obj }); }
    }
  }
  update() {
    for (let layer of this.layers) {
      const speed = layer.speed;
      if (layer.stars) for (let star of layer.stars) { star.y += speed * 0.5; if (star.y > height + 50) { star.y = -50; star.x = Math.random() * width; } }
      if (layer.clouds) for (let cloud of layer.clouds) { cloud.y += speed * 0.5; if (cloud.y > height + 100) { cloud.y = -100; cloud.x = Math.random() * width; } }
      if (layer.objects) for (let obj of layer.objects) { 
          obj.y += speed * 0.5; 
          if (obj.y > height + 150) { 
              obj.y = -150; obj.x = Math.random() * width; 
              const newObj = this.layers[3].createObject(); 
              obj.type = newObj.type; obj.size = newObj.size; obj.color = newObj.color; 
          } 
      }
    }
  }
  draw() {
    for (let layer of this.layers) {
      if (layer.stars) for (let star of layer.stars) { ctx.fillStyle = star.color; ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill(); }
      if (layer.clouds) for (let cloud of layer.clouds) { ctx.fillStyle = cloud.color; ctx.beginPath(); ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2); ctx.fill(); }
      if (layer.objects) for (let obj of layer.objects) {
        if (obj.type === 'earth') {
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, '#3399ff'); gradient.addColorStop(1, '#002200'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(obj.x-10, obj.y-10, obj.size*0.4, 0, Math.PI * 2); ctx.fill();
        } else if (obj.type === 'sun') {
            ctx.shadowBlur = 50; ctx.shadowColor = '#ff5500';
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(0.2, '#ffdd00'); gradient.addColorStop(1, '#ff3300'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        } else if (obj.type === 'station') {
            ctx.fillStyle = '#666'; ctx.fillRect(obj.x - obj.size, obj.y - obj.size/4, obj.size*2, obj.size/2);
            ctx.fillStyle = '#444'; ctx.fillRect(obj.x - obj.size/4, obj.y - obj.size, obj.size/2, obj.size*2);
            ctx.fillStyle = '#00ffff'; ctx.fillRect(obj.x - 5, obj.y - 5, 10, 10);
        } else if (obj.type === 'planet') { 
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, obj.color); gradient.addColorStop(1, 'rgba(0,0,0,0.7)'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill(); 
        } else { 
            ctx.fillStyle = obj.color; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill(); 
        }
      }
    }
  }
}

let player, bullets = [], enemies = [], drops = [], particles = [], allies = [];
let mouse = { x: 0, y: 0 }; let galaxyBackground;

function initGame() {
  initAudio(); document.getElementById('start-screen').style.display = 'none'; document.getElementById('element-selection').style.display = 'flex';
  resize(); player = new Player(); drawDamageModel(player.parts); 
  bullets = []; enemies = []; drops = []; particles = []; allies = [];
  score = 0; xp = 0; xpNeeded = 2000; wave = 1; waveTimer = 0; currentLevel = 1; bossActive = false; elementPower = 0; pendingSupportPasses = 0; supportPassTimer = 0; bossSupportsUsed = 0;
  purchasedUpgrades.clear(); currentWeapon = null; currentWeaponTier = 0; playerWeaponBranch = -1; currentElement = 'NONE'; equippedCards = [null, null, null];
  inIntermission = false; intermissionTimer = 0;
  updateCardsDisplay(); updateElementBar(); updateUI();
}

function selectElement(element) {
  currentElement = element; player.element = element;
  document.getElementById('element-selection').style.display = 'none';
  gameRunning = true; galaxyBackground = new GalaxyBackground(); startBGM('normal'); updateUI(); animate();
}

function spawnLogic() {
  if (bossActive || inIntermission || waveTimer >= FRAMES_PER_WAVE) return;

  if (wave === 10) {
      if (Math.random() < 0.05) {
          let elite = new Enemy(wave, false);
          elite.type = 6; elite.hp *= 2.5; elite.maxHp = elite.hp; elite.speed *= 1.5; elite.behavior = 'sine'; elite.damage *= 1.5;
          enemies.push(elite);
      }
  } else {
    const maxEnemies = Math.min(2 + wave/2 + currentLevel, 8); 
    if (enemies.length < maxEnemies && Math.random() < 0.035 + wave * 0.007) {
      const formType = Math.random();
      if (formType < 0.25) {
        const centerX = Math.max(100, Math.min(width - 100, Math.random() * width));
        for (let i = 0; i < 5; i++) { let offsetX = (i === 0) ? 0 : (i % 2 === 1 ? -60 * Math.ceil(i/2) : 60 * Math.ceil(i/2)); let offsetY = (i === 0) ? -50 : -50 - 50 * Math.ceil(i/2); enemies.push(new Enemy(wave, 'v-form', centerX + offsetX, offsetY)); }
      } else if (formType < 0.5) {
        for(let i=0; i<6; i++) enemies.push(new Enemy(wave, 'line', (width / 7) * (i+1), -50 - (Math.random()*20)));
      } else if (formType < 0.75) {
        const startX = Math.random() > 0.5 ? -70 : width + 70; const startY = -100; const endX = width / 2; const endY = height * 0.65;
        for(let i=0; i<5; i++) enemies.push(new Enemy(wave, 'arc', startX + (i-2)*80, startY, endX + (i-2)*80, endY, i*2));
      } else {
        for(let i=0; i<3; i++) enemies.push(new Enemy(wave, false));
      }
    }
  }
}

function checkCollisions() {
  for(let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    if (b.marked) continue;
    
    if (!b.isEnemy) {
      for(let j = enemies.length - 1; j >= 0; j--) {
        let e = enemies[j];
        if (b.hitList && b.hitList.has(e)) continue;

        let hitBox = e.isBoss ? (e.isSecret ? 100 : 68) : e.size;
        if (Math.hypot(b.x - e.x, b.y - e.y) < hitBox + 12) {
          
          if (player.element === 'FIRE' || player.effects.burn) e.burnTimer = 340;
          if (player.element === 'WATER' || player.effects.slow) { e.slowed = true; setTimeout(() => e.slowed = false, 4600); }
          if ((player.element === 'EARTH' && Math.random() < 0.15) || player.effects.stun) { e.stunned = true; e.stunTimer = 68; }
          
          if (player.effects.chain) {
             let nearest = null; let minDist = 200;
             enemies.forEach(other => { if(other !== e) { let d = Math.hypot(e.x - other.x, e.y - other.y); if(d < minDist) { minDist = d; nearest = other; } } });
             if (nearest) { nearest.hp -= b.damage * 0.8; spawnParticles((e.x + nearest.x)/2, (e.y + nearest.y)/2, '#00ffff', 5); if(nearest.hp <= 0) killEnemy(nearest); }
          }
          if (player.effects.pushback && !e.isBoss) { e.y -= 30; }

          e.hp -= b.damage; 
          spawnParticles(b.x, b.y, b.color, 4);
          if(b.hitList) b.hitList.add(e);

          if (b.explosive || (b.special && b.special.plasmaArea) || (b.special && b.special.bigExplosion)) {
              let radius = (b.special && b.special.bigExplosion) ? 220 : 115;
              let dmgMult = (b.special && b.special.bigExplosion) ? 2.5 : 1.7;
              spawnParticles(b.x, b.y, b.color, (b.special && b.special.bigExplosion) ? 80 : 48);
              enemies.forEach(other => {
                  if (Math.hypot(b.x - other.x, b.y - other.y) < radius) {
                      other.hp -= b.damage * dmgMult;
                      if (other.hp <= 0) killEnemy(other);
                  }
              });
          }

          if (b.special && b.special.splinter && !b.special.isSplinterPiece) {
              for(let k=0; k<5; k++) {
                  let ang = Math.random() * Math.PI * 2;
                  let sb = new Bullet(b.x, b.y, Math.cos(ang)*8, Math.sin(ang)*8, '#ffaa00', false, 'NONE', false, b.damage * 0.4, {isSplinterPiece: true});
                  bullets.push(sb);
              }
          }

          if (!player.effects.pierce || (b.special && b.special.isSplinterPiece)) { b.marked = true; }
          
          if (e.isBoss) { e.hitCount++; if (e.hitCount > 45) { e.hitCount = 0; if (Math.random() < 0.4) drops.push(new Drop(e.x + (Math.random()*150-75), e.y + 60, 'SUPPORT')); } }
          if (e.hp <= 0) killEnemy(e);
        }
      }
    } else {
      if (player.effects.invincible) { b.marked = true; continue; }
      
      let damage = b.damage; 
      if (player.effects.elementArmor || player.effects.armor) damage *= (0.85 / player.defenseMultiplier); 
      if (player.effects.shield) damage *= 0.80;

      if (Math.hypot(b.x - player.x, b.y - player.y) < 46) {
        player.takeDamage(damage, b.x - player.x, b.y - player.y); b.marked = true;
        spawnParticles(player.x, player.y, 'red', 15); 
        if (damage > 30 && Math.random() < 0.25) drops.push(new Drop(player.x, -50, 'SUPPORT'));
        if (player.isDead()) showGameOver();
      }
    }
  }
  
  enemies.forEach(e => {
    if (player.effects.invincible) return; 
    if (!e.isBoss && Math.hypot(e.x - player.x, e.y - player.y) < e.size + 42) {
        let dmg = e.subType === 'kamikaze' ? 80 : (e.subType === 'tank' ? 70 : 25);
        player.takeDamage(dmg, e.x - player.x, e.y - player.y); 
        e.hp = 0; spawnParticles(player.x, player.y, 'red', 20); killEnemy(e);
        if (player.isDead()) showGameOver();
    }
  });

  drops.forEach(d => { if (!d.marked && Math.hypot(d.x - player.x, d.y - player.y) < 64) { d.marked = true; collectDrop(d.type); } });
}

function startIntermission(isForBoss) {
  inIntermission = true;
  intermissionTimer = 0;
  intermissionIsBoss = isForBoss;
}

function killEnemy(e) {
  let xpGain = 160; 
  if (e.isBoss) xpGain = 3000;
  else if (e.subType === 'tank') xpGain = 800; 
  else if (e.subType === 'speedy') xpGain = 80; 
  else if (e.subType === 'kamikaze') xpGain = 0; 
  
  score += e.isBoss ? 1200 : 110; 
  xp += xpGain;

  if (e.isBoss) {
    spawnParticles(e.x, e.y, '#ff00ff', 120); enemies = enemies.filter(en => en !== e); bossActive = false;
    if (e.isSecret) {
        wave = 11;
        setTimeout(() => { victoryScreen(); }, 1500);
    } else {
        wave++; // <-- FIXED THE LOOP BUG
        startBGM('normal'); 
        startIntermission(false);
    }
  } else {
    spawnParticles(e.x, e.y, '#ffaa00', 12); enemies = enemies.filter(en => en !== e);
  }

  while (xp >= xpNeeded) { xp -= xpNeeded; xpNeeded = Math.floor(xpNeeded * 1.5); showUpgradeMenu(); }
  updateUI();
}

function spawnSupportWave() { 
  if (bossActive) {
      let limit = wave === 3 ? 1 : (wave === 10 ? 3 : 2);
      if (bossSupportsUsed >= limit) return;
      bossSupportsUsed++;
  }
  showNotification("SQUADRON INBOUND"); 
  pendingSupportPasses += 3; 
}

function updateSupportWaves() {
  if (pendingSupportPasses > 0 && allies.length === 0) {
    supportPassTimer++;
    if (supportPassTimer >= 60) { 
      playEngineFlyby(); 
      const cx = width / 2;
      const pattern = Math.floor(Math.random() * 5); 
      
      if (pattern === 0) { 
          const baseY = height + 100;
          allies.push(new SupportShip(cx, baseY, 0, -18, 0, 0));
          allies.push(new SupportShip(cx - width*0.25, baseY, 0, -18, 0, 15));
          allies.push(new SupportShip(cx + width*0.25, baseY, 0, -18, 0, 15));
          allies.push(new SupportShip(cx - width*0.45, baseY, 0, -18, 0, 30));
          allies.push(new SupportShip(cx + width*0.45, baseY, 0, -18, 0, 30));
      } else if (pattern === 1) { 
          const baseY = height + 100;
          for(let i = -2; i <= 2; i++) {
              allies.push(new SupportShip(cx + (i * width*0.2), baseY, 0, -18, 0, Math.abs(i) * 10));
          }
      } else if (pattern === 2) { 
          const baseY = height + 100;
          for(let i = 0; i < 5; i++) {
              allies.push(new SupportShip(cx, baseY, 0, -18, 0, i * 25)); 
          }
      } else if (pattern === 3) { 
          const baseX = -100; const baseY = -100;
          const rot = Math.PI * 0.75; 
          const vx = 12.7; const vy = 12.7;
          for(let i = 0; i < 5; i++) {
              allies.push(new SupportShip(baseX, baseY, vx, vy, rot, i * 15));
          }
      } else if (pattern === 4) { 
          const baseY = -100;
          const rot = Math.PI; 
          allies.push(new SupportShip(cx - width*0.3, baseY, 0, 18, rot, 0));
          allies.push(new SupportShip(cx + width*0.3, baseY, 0, 18, rot, 15));
          allies.push(new SupportShip(cx - width*0.45, baseY, 0, 18, rot, 30));
          allies.push(new SupportShip(cx + width*0.45, baseY, 0, 18, rot, 45));
          allies.push(new SupportShip(cx, baseY, 0, 18, rot, 60));
      }
      
      pendingSupportPasses--; supportPassTimer = 0;
    }
  }
}

function collectDrop(type) {
  if (type === 'HEAL') {
    Object.keys(player.parts).forEach(k => { player.parts[k].hp = Math.min(player.parts[k].max, player.parts[k].hp + player.parts[k].max * 0.52); });
    drawDamageModel(player.parts); showNotification("SYSTEMS REPAIRED");
  } else if (type === 'SUPPORT') { spawnSupportWave(); } 
  else if (type === 'CARD') {
    if (currentElement === 'NONE') { currentElement = ['FIRE', 'WATER', 'EARTH', 'AIR'][Math.floor(Math.random()*4)]; player.element = currentElement; }
    const elementCards = ELEMENT_CARDS[currentElement];
    const card = {...elementCards[Math.floor(Math.random() * elementCards.length)], rarity: RARITIES[Math.min(4, Math.floor(Math.random() * 5 + wave * 0.22))]};
    showCardPickup(card);
  }
  updateUI();
}

function showCardPickup(card) {
  isPaused = true; pendingCard = card; playUpgradeSound();
  document.getElementById('card-name').textContent = card.name; document.getElementById('card-desc').textContent = card.desc;
  document.getElementById('card-rarity').textContent = card.rarity.toUpperCase(); document.getElementById('card-rarity').style.backgroundColor = RARITY_COLORS[card.rarity];
  document.querySelector('.card-preview-icon').textContent = currentElement === 'FIRE' ? 'üî•' : currentElement === 'WATER' ? 'üíß' : currentElement === 'EARTH' ? 'üåç' : 'üå™Ô∏è';
  document.getElementById('card-pickup').style.display = 'flex';
}

function acceptCard() {
  if (pendingCard.effect === 'burn') player.effects.burn = true; if (pendingCard.effect === 'explosive') player.effects.explosive = true;
  if (pendingCard.effect === 'revive') { for(let k in player.parts) { if(player.parts[k].hp <= 0) { player.parts[k].hp = player.parts[k].max; drawDamageModel(player.parts); break; } } }
  if (pendingCard.effect === 'shield') player.effects.shield = true; if (pendingCard.effect === 'slow') player.effects.slow = true;
  if (pendingCard.effect === 'stun') player.effects.stun = true; if (pendingCard.effect === 'armor') player.effects.armor = true;
  if (pendingCard.effect === 'regen') player.effects.regen = true; if (pendingCard.effect === 'speed') player.effects.speed = 0.12;
  if (pendingCard.effect === 'dodge') player.effects.dodge = true; if (pendingCard.effect === 'supernova') player.effects.supernova = true;
  if (pendingCard.effect === 'chain') player.effects.chain = true; if (pendingCard.effect === 'pushback') player.effects.pushback = true;
  
  let rMult = pendingCard.rarity === 'mythic' ? 1.5 : (pendingCard.rarity === 'legendary' ? 1.4 : (pendingCard.rarity === 'epic' ? 1.3 : (pendingCard.rarity === 'rare' ? 1.2 : 1.1)));
  if (currentElement === 'FIRE') player.damageMultiplier *= rMult;
  if (currentElement === 'WATER') player.fireRateMultiplier *= rMult;
  if (currentElement === 'AIR') player.speedMultiplier *= rMult;
  if (currentElement === 'EARTH') player.defenseMultiplier *= rMult;

  let added = false;
  for (let i = 0; i < 3; i++) { if (!equippedCards[i]) { equippedCards[i] = pendingCard; added = true; break; } }
  if (!added) {
    let worst = 0; for (let i = 1; i < 3; i++) { if (RARITIES.indexOf(equippedCards[i].rarity) < RARITIES.indexOf(equippedCards[worst].rarity)) worst = i; }
    if (RARITIES.indexOf(pendingCard.rarity) >= RARITIES.indexOf(equippedCards[worst].rarity)) equippedCards[worst] = pendingCard;
  }
  updateCardsDisplay(); document.getElementById('card-pickup').style.display = 'none'; isPaused = false; pendingCard = null;
}

function updateCardsDisplay() {
  const slots = document.querySelectorAll('.card-slot');
  slots.forEach((slot, i) => {
    slot.className = 'card-slot';
    if (equippedCards[i]) { const c = equippedCards[i]; slot.innerHTML = `<div style="font-size:26px;margin-bottom:4px;">${{common:'‚ô¶', rare:'‚ô£', epic:'‚ô†', legendary:'‚ô•', mythic:'‚òÖ'}[c.rarity] || '?'}</div><div>${c.name}</div><div style="font-size:10px;color:${RARITY_COLORS[c.rarity]}">${c.rarity}</div>`; slot.classList.add(`card-rarity-${c.rarity}`); } 
    else { slot.innerHTML = 'EMPTY'; slot.classList.add('empty'); }
  });
}

function updateElementBar() {
  document.getElementById('element-bar-fill').style.width = (elementPower / maxElementPower * 100) + '%';
  document.getElementById('element-text').textContent = currentElement !== 'NONE' ? `${ELEMENT_NAMES[currentElement]} POWER: ${Math.floor(elementPower)}` : "ELEMENT POWER";
}

function showUpgradeMenu() { isPaused = true; playUpgradeSound(); document.getElementById('wave-menu').style.display = 'flex'; buildUpgradeTree(); }

function applyRecurringUpgrade(id) {
    if (id === 'nuke') {
        const enemiesToKill = [...enemies];
        enemiesToKill.forEach(e => { if (!e.isBoss) { e.hp = 0; killEnemy(e); } else { e.hp -= 1500; if(e.hp <= 0) killEnemy(e); } });
        spawnParticles(width/2, height/2, '#ffffff', 200); showNotification("TACTICAL NUKE DEPLOYED");
    } else if (id === 'shield') {
        player.effects.invincible = true; player.invincibleTimer = 600; showNotification("ENERGY SHIELD ACTIVATED");
    } else if (id === 'support_call') {
        spawnSupportWave(); showNotification("SQUADRON DEPLOYED");
    }
    document.getElementById('wave-menu').style.display = 'none'; isPaused = false;
}

function buildUpgradeTree() {
  const container = document.getElementById('upgrade-tree'); container.innerHTML = '';
  if (!currentWeapon) {
    const baseRow = document.createElement('div'); baseRow.className = 'tree-row';
    UPGRADE_TREE.base.forEach(node => { baseRow.appendChild(createTreeNode(node, 'base')); }); container.appendChild(baseRow);
  } else if (currentWeaponTier < 3) {
    const weaponData = UPGRADE_TREE[currentWeapon]; const nextTier = currentWeaponTier + 1;
    const row = document.createElement('div'); row.className = 'tree-row';
    weaponData[`tier${nextTier}`].forEach((node, index) => { 
        let el = createTreeNode(node, currentWeapon, index);
        if (currentWeaponTier > 0 && playerWeaponBranch !== index) {
            el.classList.add('locked');
            el.onclick = null;
        }
        row.appendChild(el); 
    }); 
    container.appendChild(row);
  } else if (currentWeaponTier === 3) {
    const row = document.createElement('div'); row.className = 'tree-row';
    UPGRADE_TREE.ship.forEach(node => { row.appendChild(createTreeNode(node, 'ship')); }); container.appendChild(row);
  } else {
    const row = document.createElement('div'); row.className = 'tree-row';
    const ops = [
      { id: 'nuke', name: 'TACTICAL NUKE', icon: '‚ò¢Ô∏è', desc: 'Wipes out visible enemies.' },
      { id: 'shield', name: 'ENERGY SHIELD', icon: 'üõ°Ô∏è', desc: 'Invincibility for 10 seconds.' },
      { id: 'support_call', name: 'SQUADRON', icon: '‚úàÔ∏è', desc: 'Call in heavy backup ships.' }
    ];
    ops.forEach(node => { const el = document.createElement('div'); el.className = 'tree-node'; el.innerHTML = `<div class="tree-node-icon">${node.icon}</div><h3>${node.name}</h3><p>${node.desc}</p>`; el.onclick = () => applyRecurringUpgrade(node.id); row.appendChild(el); });
    container.appendChild(row);
  }
}

function createTreeNode(node, type, branchIndex = 0) {
  const el = document.createElement('div'); el.className = 'tree-node';
  el.innerHTML = `<div class="tree-node-icon">${node.icon}</div><h3>${node.name}</h3><p>${node.desc}</p>`;
  
  if (purchasedUpgrades.has(node.id)) {
      el.classList.add('purchased');
      el.onclick = null;
  } else {
      if (node.unlocked || (type === 'base' && currentWeapon === node.id)) el.classList.add('unlocked');
      
      if (type === 'base') { 
          el.onclick = () => { if (!currentWeapon) { currentWeapon = node.id; player.weaponType = node.id; purchasedUpgrades.add(node.id); document.getElementById('wave-menu').style.display = 'none'; isPaused = false; } }; 
      } else if (type === 'ship') { 
          el.onclick = () => { applyShipUpgrade(node.id); } 
      } else { 
          el.onclick = () => applyWeaponUpgrade(node.id, type, branchIndex); 
      }
  }
  return el;
}

function applyShipUpgrade(id) {
    purchasedUpgrades.add(id);
    if (id === 'ship_speed') player.effects.speed = 0.15;
    if (id === 'ship_armor') player.effects.armor = true;
    if (id === 'ship_regen') player.effects.regen = true;
    currentWeaponTier = 4;
    document.getElementById('wave-menu').style.display = 'none'; isPaused = false;
}

function applyWeaponUpgrade(upgradeId, weaponType, branchIndex) {
  const tier = currentWeaponTier + 1; let upgrade = UPGRADE_TREE[weaponType][`tier${tier}`].find(u => u.id === upgradeId);
  if (upgrade && !upgrade.unlocked) {
    upgrade.unlocked = true; 
    purchasedUpgrades.add(upgradeId); 
    playerWeaponBranch = branchIndex; 
    currentWeaponTier = tier;
    document.getElementById('wave-menu').style.display = 'none'; isPaused = false;
  }
}

function spawnParticles(x, y, color, count) { for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color)); }

function showNotification(text) {
  const el = document.getElementById('notification'); el.innerText = text; el.style.opacity = 1;
  document.getElementById('notification').style.color = '#ffd700'; document.getElementById('notification').style.textShadow = '0 0 20px #ffaa00';
  setTimeout(() => el.style.opacity = 0, 2000);
}

function updateUI() {
  document.getElementById('score').innerText = score; document.getElementById('wave').innerText = wave > 10 ? 10 : wave; document.getElementById('level').innerText = currentLevel;
  document.getElementById('xp-bar-fill').style.width = Math.min(100, (xp / xpNeeded) * 100) + '%';
  document.getElementById('wave-timer-fill').style.width = Math.max(0, 100 - (waveTimer / FRAMES_PER_WAVE * 100)) + '%';
}

function showGameOver() {
  gameRunning = false; if(bgmInterval) clearInterval(bgmInterval);
  document.getElementById('game-over').style.display = 'flex'; document.getElementById('end-title').innerText = "CRITICAL FAILURE"; document.getElementById('end-title').style.color = "#ff4444";
  document.getElementById('end-desc').innerText = "ALL SYSTEMS DESTROYED"; document.getElementById('end-btn').innerText = "RETRY MISSION"; document.getElementById('final-score').innerText = `FINAL SCORE: ${score}`;
  document.getElementById('end-btn').onclick = restartGame;
}

function victoryScreen() {
  gameRunning = false; if(bgmInterval) clearInterval(bgmInterval);
  document.getElementById('game-over').style.display = 'flex'; 
  document.getElementById('end-title').innerText = `VICTORY ACHIEVED`; document.getElementById('end-title').style.color = "#00ffaa";
  document.getElementById('end-desc').innerText = "THE GALAXY IS SAFE."; document.getElementById('end-btn').innerText = `RESTART GAME`; document.getElementById('final-score').innerText = `FINAL SCORE: ${score}`;
  document.getElementById('end-btn').onclick = restartGame;
}

function restartGame() { document.getElementById('game-over').style.display = 'none'; document.getElementById('start-screen').style.display = 'flex'; }

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; width = canvas.width; height = canvas.height; if (galaxyBackground) galaxyBackground.initLayers(); }
window.addEventListener('resize', resize); document.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

function animate() {
  if (!gameRunning) return; requestAnimationFrame(animate); if (isPaused) return;
  frameCount++; ctx.fillStyle = '#020205'; ctx.fillRect(0, 0, width, height);

  if (galaxyBackground) { galaxyBackground.update(); galaxyBackground.draw(); }

  if (inIntermission) {
      intermissionTimer++;
      if (intermissionTimer === 180) { 
          if (intermissionIsBoss) {
              showNotification(wave === 10 ? "WARNING: UNKNOWN ENTITY DETECTED!" : "BOSS APPROACHING!");
              if(wave===10) { document.getElementById('notification').style.color = '#ff0000'; document.getElementById('notification').style.textShadow = '0 0 20px #ff0000'; }
          } else {
              showNotification("WAVE " + wave);
          }
      }
      if (intermissionTimer >= 360) { 
          inIntermission = false;
          waveTimer = 0;
          cardDroppedThisWave = false;
          if (intermissionIsBoss) {
              bossActive = true;
              bossSupportsUsed = 0;
              if (wave === 3) startBGM('boss1'); else if (wave === 6) startBGM('boss2'); else if (wave === 9) startBGM('boss3'); else if (wave === 10) startBGM('secret');
              if (wave === 10) enemies.push(new SecretBoss()); else enemies.push(new Boss(wave)); 
          }
      }
      updateUI();
  } else if (!bossActive && wave <= 10) {
    if (waveTimer < FRAMES_PER_WAVE) {
        waveTimer++;
        let isDamaged = false; for(let k in player.parts){ if(player.parts[k].hp < player.parts[k].max) isDamaged = true; }
        if (isDamaged && (waveTimer === 600 || waveTimer === 1300)) drops.push(new Drop(Math.random() * (width - 160) + 80, -30, 'HEAL'));
        
        if (waveTimer === 900 && Math.random() < 0.70) drops.push(new Drop(Math.random() * (width - 160) + 80, -30, 'SUPPORT'));
        
        if (waveTimer === 1000 && !cardDroppedThisWave && Math.random() < 0.10) {
            drops.push(new Drop(Math.random() * (width - 160) + 80, -30, 'CARD'));
            cardDroppedThisWave = true;
        }
    }

    if (waveTimer >= FRAMES_PER_WAVE && enemies.length === 1) {
        if (wave === 3 || wave === 6 || wave === 9 || wave === 10) {
            startIntermission(true);
        } else {
            wave++; 
            startIntermission(false);
        }
    }
    updateUI();
  }

  spawnLogic(); updateSupportWaves(); player.update();

  bullets.forEach(b => b.update()); enemies.forEach(e => e.update()); allies.forEach(a => a.update()); drops.forEach(d => d.update()); particles.forEach(p => p.update());
  checkCollisions();

  player.draw();
  for (let i = bullets.length - 1; i >= 0; i--) { if (bullets[i].marked) { bullets.splice(i, 1); continue; } bullets[i].draw(); }
  for (let i = enemies.length - 1; i >= 0; i--) { enemies[i].draw(); }
  for (let i = allies.length - 1; i >= 0; i--) { if (allies[i].marked) { allies.splice(i, 1); continue; } allies[i].draw(); }
  for (let i = drops.length - 1; i >= 0; i--) { if (drops[i].marked) { drops.splice(i, 1); continue; } drops[i].draw(); }
  for (let i = particles.length - 1; i >= 0; i--) { if (particles[i].life <= 0) { particles.splice(i, 1); continue; } particles[i].draw(); }
}
</script>
</body>
</html>