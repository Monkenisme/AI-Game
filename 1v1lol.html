<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>ACES: Galaxy Edition - Luftwaffe Update</title>
<style>
body { margin: 0; overflow: hidden; background: #020205; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; cursor: none; }
canvas { display: block; }
@keyframes pulse { from { opacity:1; } to { opacity:0.4; } }

/* UI Overlay */ 
#ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
#hud-top { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; color: white; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
.hud-box { background: rgba(0, 0, 0, 0.5); padding: 10px 20px; border-radius: 20px; border: 1px solid #444; }

#damage-display { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 140px; background: rgba(0, 20, 40, 0.8); border: 2px solid #00d4ff; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
#damage-label { color: #00d4ff; font-size: 10px; margin-bottom: 5px; text-transform: uppercase; }

/* XP / Medal Bar */
#xp-bar-container { position: absolute; top: 60px; left: 50%; transform: translateX(-50%); width: 400px; height: 12px; background: #222; border: 2px solid #555; border-radius: 6px; box-shadow: 0 0 10px rgba(0,0,0,0.8); }
#xp-bar-fill { height: 100%; background: linear-gradient(90deg, #ffaa00, #ffd700); width: 0%; transition: width 0.2s; box-shadow: 0 0 10px #ffd700; border-radius: 4px; }
#xp-text { text-align: center; color: #ffd700; font-size: 13px; margin-top: 4px; text-transform: uppercase; font-weight: 900; letter-spacing: 1px; text-shadow: 1px 1px 2px #000; }

#element-bar-container { position: absolute; top: 95px; left: 50%; transform: translateX(-50%); width: 400px; height: 10px; background: #222; border: 1px solid #555; border-radius: 5px; }
#element-bar-fill { height: 100%; background: linear-gradient(90deg, #ff4444, #4488ff, #44aa44, #88ccff); width: 0%; transition: width 0.2s; }
#element-text { text-align: center; color: #aaa; font-size: 11px; margin-top: 2px; text-transform: uppercase; font-weight: bold; }

#weapon-tier-display { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); color: #ffd700; font-size: 16px; font-weight: bold; text-shadow: 0 0 10px #ffaa00; text-transform: uppercase; }

#wave-timer-container { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; color: white; }
#wave-timer-bar { width: 200px; height: 6px; background: #222; border: 1px solid #555; border-radius: 3px; margin-top: 5px; }
#wave-timer-fill { height: 100%; background: #00d4ff; width: 100%; }

#cards-display { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; width: 300px; }
.card-slot { width: 80px; height: 100px; background: rgba(0, 0, 0, 0.5); border: 1px solid #444; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-size: 12px; text-align: center; }
.card-slot.empty { border: 1px dashed #666; }
.card-rarity-common { border-top: 3px solid #aaa; }
.card-rarity-rare { border-top: 3px solid #44aaff; }
.card-rarity-epic { border-top: 3px solid #aa44ff; }
.card-rarity-legendary { border-top: 3px solid #ffaa44; }
.card-rarity-mythic { border-top: 3px solid #ff44aa; }

/* Menus */
#card-pickup, #game-over, #element-selection, #weapon-selection, #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; cursor: default; }
#card-pickup { background: rgba(10, 10, 25, 0.95); z-index: 150; }
#game-over { background: rgba(0, 0, 0, 0.9); z-index: 200; color: white;}
#element-selection, #weapon-selection { background: rgba(10, 10, 25, 0.95); z-index: 150; }
#start-screen { background: #050510; display: flex; z-index: 200; }

.btn { padding: 15px 50px; font-size: 24px; background: #00d4ff; border: none; color: #000; font-weight: 800; cursor: pointer; border-radius: 5px; box-shadow: 0 0 25px rgba(0, 212, 255, 0.5); text-transform: uppercase; margin-top: 20px; }
.btn:hover { background: white; box-shadow: 0 0 40px white; }
.selection-container { display: flex; gap: 30px; }
.option-box { width: 200px; height: 250px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #00d4ff; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.3s; box-shadow: 0 0 15px rgba(0, 212, 255, 0.2); padding: 15px; color: white; text-align: center; }
.option-box:hover { transform: translateY(-10px); box-shadow: 0 0 30px rgba(0, 212, 255, 0.8); background: #202040; }
.option-icon { font-size: 60px; margin-bottom: 15px; }
.option-name { font-size: 24px; font-weight: bold; color: #00d4ff; margin-bottom: 10px; }
.option-desc { font-size: 14px; color: #aaa; }

.element-fire { border-color: #ff4444; } .element-fire .option-name { color: #ff4444; }
.element-water { border-color: #4488ff; } .element-water .option-name { color: #4488ff; }
.element-earth { border-color: #44aa44; } .element-earth .option-name { color: #44aa44; }
.element-air { border-color: #88ccff; } .element-air .option-name { color: #88ccff; }

.card-preview { width: 300px; height: 400px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #ff44aa; border-radius: 15px; display: flex; flex-direction: column; align-items: center; padding: 20px; color: white; box-shadow: 0 0 30px rgba(255, 68, 170, 0.5); }
.card-preview-icon { font-size: 80px; margin: 20px 0; }
.card-preview h2 { color: #ff44aa; margin: 10px 0; font-size: 24px; text-transform: uppercase; }
.card-rarity-tag { padding: 5px 15px; border-radius: 20px; font-weight: bold; margin: 10px 0; background: #333; }
.btn-small { padding: 10px 30px; font-size: 18px; background: #ff44aa; border: none; color: white; font-weight: 800; cursor: pointer; border-radius: 5px; margin-top: 20px; box-shadow: 0 0 15px rgba(255, 68, 170, 0.5); }
#notification { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); color: #ffd700; font-size: 40px; font-weight: 900; opacity: 0; text-shadow: 0 0 20px #ffaa00; pointer-events: none; transition: opacity 0.5s; text-align: center; z-index: 50; }
</style>
</head>
<body>

<div id="ui-layer">
  <div id="hud-top">
    <div class="hud-box">SCORE: <span id="score">0</span></div>
    <div id="wave-timer-container">
      <div style="font-size: 20px; font-weight: bold;">WAVE: <span id="wave">1</span></div>
      <div id="wave-timer-bar"><div id="wave-timer-fill"></div></div>
    </div>
    <div class="hud-box" style="color:#00d4ff">LEVEL: <span id="level">1</span></div>
  </div>
  
  <div id="xp-bar-container"><div id="xp-bar-fill"></div><div id="xp-text">COLLECT MEDALS TO LEVEL UP</div></div>
  <div id="element-bar-container"><div id="element-bar-fill"></div><div id="element-text">ELEMENT POWER</div></div>
  <div id="weapon-tier-display">WEAPON TIER: 0</div>
  
  <div id="super-power-container" style="position:absolute; bottom:20px; right:20px; width:180px; background:rgba(0,0,0,0.6); border:2px solid #ff8800; border-radius:10px; padding:8px 12px; color:white;">
    <div style="font-size:11px; color:#ff8800; text-transform:uppercase; margin-bottom:4px;">‚ö° SQUADRON POWER</div>
    <div style="background:#222; border-radius:4px; height:10px; overflow:hidden; border:1px solid #555;">
      <div id="super-power-fill" style="height:100%; background:linear-gradient(90deg,#ff6600,#ffcc00); width:0%; transition:width 0.15s; box-shadow:0 0 8px #ff8800;"></div>
    </div>
    <div id="super-power-text" style="font-size:11px; text-align:center; margin-top:3px; color:#aaa;">0 / 50 KILLS</div>
    <div id="super-activate-btn" style="display:none; margin-top:6px; text-align:center; font-size:14px; font-weight:900; color:#ffcc00; text-shadow:0 0 10px #ff8800; animation:pulse 0.8s infinite alternate;">‚ñ∂ ACTIVATE [SPACE]</div>
  </div>
  
  <div id="damage-display"><div id="damage-label">SHIP STATUS</div><canvas id="damageCanvas" width="80" height="100"></canvas></div>
  <div id="cards-display"><div class="card-slot empty">EMPTY</div><div class="card-slot empty">EMPTY</div><div class="card-slot empty">EMPTY</div></div>
  <div id="notification">SYSTEMS REPAIRED</div>
</div>

<div id="start-screen">
  <div style="text-align: center;">
    <h1 style="color:#00d4ff; font-size: 80px; margin-bottom: 10px; text-shadow: 0 0 30px #00d4ff;">ACES GALAXY</h1>
    <p style="color:white; font-size: 18px; margin-bottom: 40px;">Move with MOUSE. Collect Weapon Crates to Upgrade. Survive 10 waves!</p>
    <button class="btn" onclick="document.getElementById('start-screen').style.display='none'; document.getElementById('element-selection').style.display='flex'; initAudio();">LAUNCH MISSION</button>
  </div>
</div>

<div id="element-selection">
  <h1 style="color:#ffffff; font-size: 40px; margin-bottom: 30px;">CHOOSE YOUR ELEMENT</h1>
  <div class="selection-container">
    <div class="option-box element-fire" onclick="selectElement('FIRE')"><div class="option-icon">üî•</div><div class="option-name">FIRE</div><div class="option-desc">+ Damage<br>Burn Effects</div></div>
    <div class="option-box element-water" onclick="selectElement('WATER')"><div class="option-icon">üíß</div><div class="option-name">WATER</div><div class="option-desc">+ Fire Rate<br>Slow Effects</div></div>
    <div class="option-box element-earth" onclick="selectElement('EARTH')"><div class="option-icon">üåç</div><div class="option-name">EARTH</div><div class="option-desc">+ Defense<br>Stun Effects</div></div>
    <div class="option-box element-air" onclick="selectElement('AIR')"><div class="option-icon">üå™Ô∏è</div><div class="option-name">AIR</div><div class="option-desc">+ Speed<br>Chain Lightning</div></div>
  </div>
</div>

<div id="weapon-selection">
  <h1 style="color:#ffd700; font-size: 40px; margin-bottom: 30px;">CHOOSE YOUR WEAPON</h1>
  <div class="selection-container">
    <div class="option-box" onclick="selectWeapon('machinegun')"><div class="option-icon">üî´</div><div class="option-name">MACHINE GUN</div><div class="option-desc">Rapid continuous fire.<br>Upgrades into massive bullet walls.</div></div>
    <div class="option-box" onclick="selectWeapon('shotgun')"><div class="option-icon">üí•</div><div class="option-name">FLAK SHOTGUN</div><div class="option-desc">Wide spread, high close damage.<br>Upgrades into explosive shrapnel.</div></div>
    <div class="option-box" onclick="selectWeapon('sniper')"><div class="option-icon">üéØ</div><div class="option-name">SNIPER</div><div class="option-desc">High damage, slow fire rate.<br>Upgrades to pierce and explode.</div></div>
  </div>
</div>

<div id="card-pickup">
  <div class="card-preview" id="card-preview">
    <div class="card-preview-icon">?</div><h2 id="card-name">CARD NAME</h2><div class="card-rarity-tag" id="card-rarity">Rarity</div>
    <p id="card-desc">Card description</p><button class="btn-small" onclick="acceptCard()">EQUIP CARD</button>
  </div>
</div>

<div id="game-over">
  <h1 id="end-title" style="color:#ff4444; font-size: 60px;">CRITICAL FAILURE</h1>
  <div id="final-score" style="font-size: 30px; margin: 20px;">FINAL SCORE: 0</div>
  <p id="end-desc" style="color: #aaa; margin-bottom: 30px;">ALL SYSTEMS DESTROYED</p>
  <button id="end-btn" class="btn" onclick="restartGame()">RETRY MISSION</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const dmgCanvas = document.getElementById('damageCanvas');
const dmgCtx = dmgCanvas.getContext('2d');

let width, height, gameRunning = false, isPaused = false, frameCount = 0;
let currentLevel = 1, wave = 1, waveTimer = 0, bossActive = false;
let cardDroppedThisWave = false;
let cameraShake = 0;
let lastTimestamp = 0; 
const FRAMES_PER_WAVE = 900; 

let inIntermission = false;
let intermissionTimer = 0;
let intermissionIsBoss = false;

let score = 0, xp = 0, xpNeeded = 800, elementPower = 0, maxElementPower = 100;
let currentWeapon = null, currentWeaponTier = 0, currentElement = 'NONE';
let equippedCards = [null, null, null], pendingCard = null;

let pendingSupportPasses = 0;
let supportPassTimer = 0;
let bossSupportsUsed = 0;
let supportSpawnDelay = 0; 
let globalFormationIdCounter = 0; 

let superPowerMeter = 0;
let superPowerReady = false;
let aceSpawnedThisWave = false;

function getSuperPowerNeeded() {
  if (wave <= 3) return 50;
  if (wave <= 6) return 75;
  return 100; 
}

const ELEMENTS = { NONE: '#ffffff', FIRE: '#ff4444', WATER: '#4488ff', EARTH: '#44aa44', AIR: '#88ccff' };
const ELEMENT_NAMES = { FIRE: 'Fire', WATER: 'Water', EARTH: 'Earth', AIR: 'Air' };
const RARITIES = ['common', 'rare', 'epic', 'legendary', 'mythic'];
const RARITY_COLORS = { common: '#aaa', rare: '#44aaff', epic: '#aa44ff', legendary: '#ffaa44', mythic: '#ff44aa' };

const ELEMENT_CARDS = {
  FIRE: [
    { name: "Inferno", desc: "+ Damage & Burn enemies", rarity: 'common', effect: 'burn' },
    { name: "Magma Burst", desc: "++ Damage & Explosive shots", rarity: 'rare', effect: 'explosive' },
    { name: "Phoenix", desc: "+++ Damage & Auto-Repair 1 Part", rarity: 'epic', effect: 'revive' },
    { name: "Solar Flare", desc: "++++ Damage & Chain lightning", rarity: 'legendary', effect: 'chain' },
    { name: "Supernova", desc: "MASSIVE Damage & Explosions", rarity: 'mythic', effect: 'supernova' }
  ],
  WATER: [
    { name: "Tidal Wave", desc: "+ Fire Rate & Push enemies", rarity: 'common', effect: 'pushback' },
    { name: "Ice Shard", desc: "++ Fire Rate & Slow enemies", rarity: 'rare', effect: 'slow' },
    { name: "Aqua Shield", desc: "+++ Fire Rate & Absorb Damage", rarity: 'epic', effect: 'shield' },
    { name: "Hydro Vortex", desc: "++++ Fire Rate & Pull enemies", rarity: 'legendary', effect: 'pull' },
    { name: "Ocean's Wrath", desc: "INSANE Fire Rate Boost", rarity: 'mythic', effect: 'minions' }
  ],
  EARTH: [
    { name: "Stone Skin", desc: "+ Defense & Armor", rarity: 'common', effect: 'armor' },
    { name: "Quake", desc: "++ Defense & Stun enemies", rarity: 'rare', effect: 'stun' },
    { name: "Gaia's Blessing", desc: "+++ Defense & Regen HP", rarity: 'epic', effect: 'regen' },
    { name: "Terra Firma", desc: "++++ Defense & Barriers", rarity: 'legendary', effect: 'barrier' },
    { name: "World Tree", desc: "GODLIKE Defense & Structures", rarity: 'mythic', effect: 'turrets' }
  ],
  AIR: [
    { name: "Gale Force", desc: "+ Speed & Maneuver", rarity: 'common', effect: 'speed' },
    { name: "Lightning Strike", desc: "++ Speed & Chain enemies", rarity: 'rare', effect: 'chain' },
    { name: "Storm Eye", desc: "+++ Speed & Dodge chance", rarity: 'epic', effect: 'dodge' },
    { name: "Tempest", desc: "++++ Speed & Wind Blades", rarity: 'legendary', effect: 'blades' },
    { name: "Celestial Wind", desc: "LIGHTSPEED & Teleportation", rarity: 'mythic', effect: 'teleport' }
  ]
};

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let noiseBuffer = null, bgmInterval = null, bgmAudio = null, currentTheme = 'normal';
let audioFiles = {}; 

function initAudio() {
  if (!audioCtx || noiseBuffer) return;
  const bufferSize = audioCtx.sampleRate * 1.0; 
  noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0); 
  for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
  
  audioFiles = {
    background: 'background music.mp3',
    boss: 'boss music.mp3',
    support: 'Support sound effect.MP3',
    explosion: 'explosion sound.mp3',
    bossExplosion: 'Explosion Sound Effect.mp3'
  };
}

function playAudioFile(filename, shouldLoop = false) {
  try {
    const poolSize = 8; 
    if (!audioFiles[filename + '_pool']) {
      audioFiles[filename + '_pool'] = [];
      for (let i = 0; i < poolSize; i++) {
        let a = new Audio(filename);
        a.volume = 0.6;
        audioFiles[filename + '_pool'].push(a);
      }
      audioFiles[filename + '_index'] = 0;
    }
    let pool = audioFiles[filename + '_pool'];
    let idx = audioFiles[filename + '_index'];
    let a = pool[idx];
    a.volume = 0.9;
    if (shouldLoop) a.loop = true;
    a.currentTime = 0;
    a.play().catch(e => { });
    audioFiles[filename + '_index'] = (idx + 1) % poolSize;
  } catch (e) {}
}

function startBGM(theme = 'normal') {
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  if (bgmAudio) { bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null; }
  if (bgmInterval) { clearInterval(bgmInterval); bgmInterval = null; }
  
  let filename = null;
  let isBossMusic = false;
  if (theme === 'normal') filename = audioFiles.background;
  else if (theme === 'boss1' || theme === 'boss2' || theme === 'boss3' || theme === 'boss4' || theme === 'secret') {
    filename = audioFiles.boss;
    isBossMusic = true;
  }
  
  if (filename) {
    bgmAudio = new Audio(filename);
    bgmAudio.loop = true;
    bgmAudio.volume = isBossMusic ? 1.0 : 0.6;
    bgmAudio.play().catch(e => {});
  }
  currentTheme = theme;
}

function playRealisticGun(type) {
  if (!audioCtx || !noiseBuffer || audioCtx.state === 'suspended') return;
  const now = audioCtx.currentTime; const noiseSource = audioCtx.createBufferSource(); noiseSource.buffer = noiseBuffer;
  const filter = audioCtx.createBiquadFilter(); const gain = audioCtx.createGain();
  if (type === 'machinegun') { filter.type = 'bandpass'; filter.frequency.value = 1800; filter.Q.value = 0.8; gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08); } 
  else if (type === 'shotgun') { filter.type = 'lowpass'; filter.frequency.value = 1200; gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25); } 
  else if (type === 'sniper') { filter.type = 'highpass'; filter.frequency.value = 800; gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); } 
  else if (type === 'support') { filter.type = 'bandpass'; filter.frequency.value = 2200; gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); }
  noiseSource.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); noiseSource.start(now);
}

function playEnemyGun(type) {
  if (!audioCtx || !noiseBuffer || audioCtx.state === 'suspended') return;
  const now = audioCtx.currentTime; const ns = audioCtx.createBufferSource(); ns.buffer = noiseBuffer;
  const f = audioCtx.createBiquadFilter(); const g = audioCtx.createGain();
  if (type === 'tank') { f.type = 'lowpass'; f.frequency.value = 400; g.gain.setValueAtTime(0.4, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.3); }
  else if (type === 'speedy') { f.type = 'highpass'; f.frequency.value = 2500; g.gain.setValueAtTime(0.1, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.1); }
  else if (type === 'missile') { f.type = 'lowpass'; f.frequency.value = 800; g.gain.setValueAtTime(0.7, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.5); }
  else { f.type = 'bandpass'; f.frequency.value = 1000; g.gain.setValueAtTime(0.2, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.15); }
  ns.connect(f); f.connect(g); g.connect(audioCtx.destination); ns.start(now);
}

function playUpgradeSound() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.type = 'sine'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now + 0.2);
  gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
  osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.5);
}

function playEngineFlyby() {
  if (!audioCtx || !noiseBuffer || audioCtx.state === 'suspended') return;
  const now = audioCtx.currentTime; const ns = audioCtx.createBufferSource(); ns.buffer = noiseBuffer;
  const f = audioCtx.createBiquadFilter(); const g = audioCtx.createGain();
  f.type = 'lowpass'; f.frequency.setValueAtTime(100, now); f.frequency.linearRampToValueAtTime(800, now + 1.0); f.frequency.linearRampToValueAtTime(100, now + 2.5);
  g.gain.setValueAtTime(0.01, now); g.gain.linearRampToValueAtTime(0.6, now + 1.0); g.gain.linearRampToValueAtTime(0.01, now + 2.5);
  ns.connect(f); f.connect(g); g.connect(audioCtx.destination); ns.start(now);
}

function playImpactSound() {
  if (!audioCtx || audioCtx.state === 'suspended') return;
  const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.type = 'square'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
  gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
  osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.1);
}

function drawDamageModel(parts) {
  dmgCtx.clearRect(0, 0, 80, 100);
  const getColor = (hp, max) => {
    if (hp <= 0) return '#000000'; const pct = hp / max;
    if (pct > 0.75) return '#00ff00'; if (pct > 0.5) return '#ffff00'; if (pct > 0.25) return '#ff8800'; return '#ff0000';
  };
  dmgCtx.fillStyle = getColor(parts.body.hp, parts.body.max); dmgCtx.fillRect(25, 20, 30, 40); dmgCtx.strokeStyle = '#005555'; dmgCtx.strokeRect(25, 20, 30, 40);
  dmgCtx.fillStyle = getColor(parts.leftWing.hp, parts.leftWing.max); dmgCtx.beginPath(); dmgCtx.moveTo(25, 35); dmgCtx.lineTo(5, 55); dmgCtx.lineTo(25, 65); dmgCtx.fill(); dmgCtx.stroke();
  dmgCtx.fillStyle = getColor(parts.rightWing.hp, parts.rightWing.max); dmgCtx.beginPath(); dmgCtx.moveTo(55, 35); dmgCtx.lineTo(75, 55); dmgCtx.lineTo(55, 65); dmgCtx.fill(); dmgCtx.stroke();
  dmgCtx.fillStyle = getColor(parts.engine.hp, parts.engine.max); dmgCtx.fillRect(30, 65, 20, 25); dmgCtx.strokeRect(30, 65, 20, 25);
  dmgCtx.fillStyle = getColor(parts.gun.hp, parts.gun.max); dmgCtx.fillRect(35, 12, 10, 12); dmgCtx.strokeRect(35, 12, 10, 12);
}

class Player {
  constructor() {
    this.x = window.innerWidth / 2; this.y = window.innerHeight - 100; this.size = 65; 
    // Player HP met 50% verhoogd
    this.parts = { body: { hp: 360, max: 360 }, leftWing: { hp: 240, max: 240 }, rightWing: { hp: 240, max: 240 }, engine: { hp: 300, max: 300 }, gun: { hp: 270, max: 270 } };
    this.speed = 0.6; this.damage = 15; this.fireRate = 4; this.fireTimer = 0; 
    this.element = 'NONE'; this.weaponType = 'base'; this.shotCount = 1; this.spreadAngle = 0; this.isParallel = false;
    this.effects = {}; this.firstShot = true; this.backupGun = false; this.invincibleTimer = 0;
    this.damageMultiplier = 1; this.fireRateMultiplier = 1; this.speedMultiplier = 1; this.defenseMultiplier = 1;
    this.isCrashing = false; this.crashTimer = 0; this.rotation = 0;
  }
  
  isDead() { return this.parts.body.hp <= 0 || this.parts.engine.hp <= 0 || (this.parts.leftWing.hp <= 0 && this.parts.rightWing.hp <= 0); }

  takeDamage(amount, relX, relY) {
      if (this.effects.invincible) return;
      if (this.element === 'AIR' && Math.random() < 0.15) { spawnParticles(this.x, this.y, '#ffffff', 10); return; }
      if (this.effects.dodge && Math.random() < 0.15) { spawnParticles(this.x, this.y, '#ffffff', 10); return; }

      let targetPart = 'body';
      if (relY > 18) targetPart = 'engine'; else if (relX < -18) targetPart = 'leftWing'; else if (relX > 18) targetPart = 'rightWing'; else if (Math.random() < 1) targetPart = 'gun';
      if (targetPart === 'engine' && this.parts.body.hp > 0) amount *= 0.5;
      if (this.parts[targetPart].hp <= 0) { const alive = Object.keys(this.parts).filter(k => this.parts[k].hp > 0); if (alive.length > 0) targetPart = alive[0]; else return; }
      this.parts[targetPart].hp -= amount; drawDamageModel(this.parts); playImpactSound();
  }

  update() {
    if (this.isCrashing) {
        this.crashTimer--;
        this.y += 5.0; 
        this.rotation += 0.2;
        spawnParticles(this.x, this.y, '#ff4400', 5);
        spawnParticles(this.x, this.y, '#444444', 5);
        if (this.crashTimer <= 0) { showGameOver(); }
        return;
    }

    let baseSpeed = 0.6; let elementDmgMult = 1.0; let elementFRMult = 1.0;
    
    if (this.element === 'FIRE') elementDmgMult = 1.15; 
    else if (this.element === 'WATER') elementFRMult = 1.15;
    else if (this.element === 'EARTH') { this.effects.elementArmor = true; }
    else if (this.element === 'AIR') { baseSpeed *= 1.25; }

    this.speed = (baseSpeed + (this.effects.speed || 0)) * this.speedMultiplier;
    
    if (this.parts.engine.hp <= 0) { this.speed = 0.16; if (frameCount % 6 === 0) this.parts.body.hp -= 3; }
    if (this.parts.leftWing.hp <= 0 && this.parts.rightWing.hp <= 0) {
        if (!this.isCrashing) { this.isCrashing = true; this.crashTimer = 60; playAudioFile(audioFiles.bossExplosion); }
        return; 
    }
    if (this.parts.leftWing.hp <= 0 || this.parts.rightWing.hp <= 0) this.speed *= 0.65;
    
    let wDamage = 15; let wFireRate = 4; let wShotCount = 1; let wSpread = 0;
    
    this.effects.pierce = false; this.isSlug = false; this.effects.splinter = false;
    this.effects.plasmaArea = false; this.effects.bigExplosion = false; this.effects.explosive = false;
    this.effects.incendiary = false; this.effects.homing = false; this.isParallel = false; this.bulletSpeedMult = 1.0; let isBossHunter = false;

    if (this.weaponType === 'sniper') {
        wDamage = 320; wFireRate = 35; wShotCount = 1; wSpread = 0; 
        if(currentWeaponTier >= 1) { this.effects.pierce = true; }
        if(currentWeaponTier >= 2) { wFireRate = 35; }
        if(currentWeaponTier >= 3) { this.effects.plasmaArea = true; }
        if(currentWeaponTier >= 4) { wFireRate = 25; }
        if(currentWeaponTier >= 5) { this.bulletSpeedMult = 3.0; }
        if(currentWeaponTier >= 6) { this.effects.explosive = true; wDamage *= 2.0; } 
    } else if (this.weaponType === 'machinegun') {
        wDamage = 30; wFireRate = 4; wShotCount = 1; wSpread = 0;
        if(currentWeaponTier >= 1) { wShotCount = 2; this.isParallel = true; wDamage = 25; }
        if(currentWeaponTier >= 2) { wFireRate = 3.5; }
        if(currentWeaponTier >= 3) { wShotCount = 3; this.isParallel = false; wSpread = 0.25; wDamage = 20; }
        if(currentWeaponTier >= 4) { wShotCount = 4; wSpread = 0.4; wDamage = 20; }
        if(currentWeaponTier >= 5) { this.effects.incendiary = true; wFireRate = 3; }
        if(currentWeaponTier >= 6) { wShotCount = 6; wSpread = 0.8; wFireRate = 3; wDamage = 15; } 
    } else if (this.weaponType === 'shotgun') {
        wDamage = 60; wFireRate = 35; wShotCount = 4; wSpread = 0.6; 
        if(currentWeaponTier >= 1) { wShotCount = 6; }
        if(currentWeaponTier >= 2) { wSpread = 1.0; }
        if(currentWeaponTier >= 3) { wFireRate = 25; }
        if(currentWeaponTier >= 4) { this.effects.explosive = true; wDamage = 50; }
        if(currentWeaponTier >= 5) { wShotCount = 8; }
        if(currentWeaponTier >= 6) { wShotCount = 12; wSpread = 1.5; wDamage = 70; }
    }

    if (this.parts.gun.hp <= 0) { this.backupGun = true; wDamage *= 0.55; wFireRate *= 2.2; } else this.backupGun = false;
    
    this.damage = wDamage * elementDmgMult * this.damageMultiplier;
    this.fireRate = Math.max(1, (wFireRate / elementFRMult) / this.fireRateMultiplier);
    this.shotCount = wShotCount;
    this.spreadAngle = wSpread;

    if (this.effects.armor) this.damage *= (0.75 * this.defenseMultiplier);
    
    this.x += (mouse.x - this.x) * this.speed; this.y += (mouse.y - this.y) * this.speed;
    this.x = Math.max(30, Math.min(width - 30, this.x));
    this.y = Math.max(30, Math.min(height - 30, this.y));

    if (this.effects.invincible) { this.invincibleTimer--; if (this.invincibleTimer <= 0) this.effects.invincible = false; }
    
    if (this.effects.regen && frameCount % 90 === 0) {
        let worst = null; let minPct = 1;
        for (let k in this.parts) { let p = this.parts[k]; if (p.hp > 0 && p.hp < p.max && (p.hp/p.max) < minPct) { worst = k; minPct = p.hp/p.max; } }
        if (worst) { this.parts[worst].hp += 4 * this.defenseMultiplier; drawDamageModel(this.parts); } 
    }

    if (this.effects.supernova && frameCount % 300 === 0) {
      spawnParticles(this.x, this.y, '#ff4444', 100);
      enemies.forEach(enemy => { enemy.hp -= 350 * this.damageMultiplier; if (enemy.hp <= 0) killEnemy(enemy); });
    }

    this.fireTimer++;
    if (this.fireTimer >= this.fireRate) {
      this.shoot(); this.fireTimer = 0;
      if (this.weaponType !== 'base') playRealisticGun(this.weaponType);
    }
  }

  shoot() {
    const color = ELEMENTS[this.element];
    const angleStep = this.shotCount > 1 ? this.spreadAngle / (this.shotCount - 1) : 0;
    let special = { 
        isSlug: this.isSlug, splinter: this.effects.splinter, plasmaArea: this.effects.plasmaArea, 
        bigExplosion: this.effects.bigExplosion, homing: this.effects.homing, incendiary: this.effects.incendiary, bossHunter: false
    };

    if (this.isParallel) {
        for (let i = 0; i < this.shotCount; i++) {
            let offset = (i - (this.shotCount - 1) / 2) * 20; 
            const vy = -38 * this.bulletSpeedMult;
            bullets.push(new Bullet(this.x + offset, this.y - 45, 0, vy, color, false, this.element, this.effects.explosive, this.damage, special));
        }
    } else {
        for (let i = 0; i < this.shotCount; i++) {
            const angle = this.shotCount > 1 ? (-this.spreadAngle/2 + i * angleStep) : 0;
            const vx = Math.sin(angle) * 7.0 * this.bulletSpeedMult; 
            const vy = -Math.cos(angle) * 38 * this.bulletSpeedMult;
            bullets.push(new Bullet(this.x, this.y - 45, vx, vy, color, false, this.element, this.effects.explosive, this.damage, special));
        }
    }

    if (this.weaponType === 'sniper' && !this.effects.bigExplosion) {
        bullets.push(new Bullet(this.x - 20, this.y - 20, -8, -30, color, false, this.element, false, this.damage * 0.10));
        bullets.push(new Bullet(this.x + 20, this.y - 20, 8, -30, color, false, this.element, false, this.damage * 0.10));
    }
  }

  draw() {
    ctx.save(); ctx.translate(this.x, this.y); 
    if (this.rotation) ctx.rotate(this.rotation);
    ctx.scale(2, 2);
    if (this.isCrashing) {
        let crashScale = Math.max(0.01, 1 - (60 - this.crashTimer) / 60);
        ctx.scale(crashScale, crashScale);
    }

    if (this.effects.invincible) {
        ctx.shadowBlur = 20; ctx.shadowColor = '#00d4ff'; ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(0, 0, 18 + Math.sin(frameCount * 0.2) * 2, 0, Math.PI*2); ctx.stroke();
    }
    if (this.parts.engine.hp > 0 && !this.isCrashing) {
        let flameH = 22 + Math.random() * 12; let grad = ctx.createLinearGradient(0, 18, 0, 18 + flameH);
        grad.addColorStop(0, '#00ffff'); grad.addColorStop(1, 'rgba(0, 255, 255, 0)'); ctx.fillStyle = grad;
        ctx.beginPath(); ctx.moveTo(-5, 18); ctx.lineTo(0, 18+flameH); ctx.lineTo(5, 18); ctx.fill();
        ctx.shadowBlur = 18; ctx.shadowColor = '#00d4ff';
    }
    const drawVisualPart = (hp, max, points) => {
        if (hp <= 0) { ctx.fillStyle = '#111'; ctx.strokeStyle = '#333'; } 
        else {
            const pct = hp/max; let baseColor = pct > 0.5 ? '#e0e0e0' : (pct > 0.25 ? '#aa7700' : '#880000');
            let grad = ctx.createLinearGradient(-12, -12, 12, 12); grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.3, baseColor); grad.addColorStop(1, '#444455');
            ctx.fillStyle = grad; ctx.strokeStyle = '#00d4ff';
        }
        ctx.lineWidth = 0.6; ctx.beginPath(); ctx.moveTo(points[0][0], points[0][1]);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i][0], points[i][1]); ctx.closePath(); ctx.fill(); ctx.stroke();
    };
    drawVisualPart(this.parts.body.hp, this.parts.body.max, [[-8, -22], [8, -22], [12, 14], [-12, 14]]);
    drawVisualPart(this.parts.leftWing.hp, this.parts.leftWing.max, [[-9, -4], [-26, 12], [-26, 22], [-8, 18]]);
    drawVisualPart(this.parts.rightWing.hp, this.parts.rightWing.max, [[9, -4], [26, 12], [26, 22], [8, 18]]);
    if (this.parts.gun.hp > 0) { ctx.fillStyle = '#aaaaaa'; ctx.fillRect(-4, -28, 8, 14); ctx.strokeStyle = '#00d4ff'; ctx.strokeRect(-4, -28, 8, 14); } 
    else { ctx.fillStyle = '#555555'; ctx.fillRect(-3, -26, 6, 10); }
    if(this.element !== 'NONE' && this.parts.body.hp > 0 && !this.isCrashing) { ctx.shadowBlur = 12; ctx.shadowColor = ELEMENTS[this.element]; ctx.strokeStyle = ELEMENTS[this.element]; ctx.lineWidth = 2; ctx.stroke(); ctx.shadowBlur = 0; }
    ctx.restore();
  }
}

class SupportShip {
  constructor(x, y, vx = 0, vy = -36, rotation = 0, delay = 0, pattern = 'linear') { 
      this.x = x; this.y = y; this.vx = vx; this.vy = vy; 
      this.rotation = rotation; this.marked = false; this.fireTimer = 14; 
      this.delay = delay; this.pattern = pattern; 
  }
  update() {
    if (this.delay > 0) { this.delay--; return; } 

    this.x += this.vx; this.y += this.vy; 
    if (this.y < -400 || this.y > height + 400 || this.x < -400 || this.x > width + 400) this.marked = true;

    this.fireTimer++;
    if (this.fireTimer >= 5) {
      this.fireTimer = 0;
      for(let i = -4; i <= 5; i++) {
          let angle = this.rotation - Math.PI/2 + (i * 0.12);
          bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*56, Math.sin(angle)*56, '#00ffcc', false, 'NONE', false, 60));
      }
      playRealisticGun('support');
    }
  }
  draw() {
    if (this.delay > 0) return; 

    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.scale(6, 6); ctx.shadowBlur = 15; ctx.shadowColor = '#00ffcc';
    ctx.fillStyle = '#113355'; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-15, 10); ctx.lineTo(15, 10); ctx.fill();
    ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#00ffff'; ctx.fillRect(-3, -10, 6, 12);
    ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.moveTo(-8, 10); ctx.lineTo(-8, 20); ctx.lineTo(-4, 10); ctx.fill();
    ctx.beginPath(); ctx.moveTo(8, 10); ctx.lineTo(8, 20); ctx.lineTo(4, 10); ctx.fill(); ctx.restore();
  }
}

class Enemy {
  constructor(waveDiff, formationType = false, startX, startY, startX2, startY2, delay = 0) {
    let maxType = 2; if (wave >= 4) maxType = 4; if (wave >= 7) maxType = 6;
    this.type = Math.floor(Math.random() * (maxType + 1));
    this.formationType = formationType;
    this.subType = 'normal';
    if (this.type >= 3) this.subType = 'tank'; 
    
    this.isCrashing = false;
    this.crashTimer = 0;
    this.returning = false;
    this.returnTargetX = null;
    
    let baseHp = (40 + (this.type * 10)) * 2; 
    this.hp = baseHp * Math.pow(1.10, waveDiff - 1); 
    this.maxHp = this.hp; 
    this.size = 55;
    this.vx = 0; 
    this.targetY = 80 + Math.random() * 200;
    this.xOffset = Math.random() * 200; 
    this.rotation = 0;
    
    if (formationType === 'bomber') {
      this.behavior = 'bomber';
      this.subType = 'bomber';
      this.x = Math.random() * (width - 150) + 75;
      this.y = -150;
      this.hp = 2400 * Math.pow(1.10, waveDiff - 1); 
      this.maxHp = this.hp;
      this.size = 85;
      this.speed = 1.0 * Math.pow(1.02, waveDiff - 1);
      this.damage = 40;
      this.fireInterval = 50;
      this.rotation = Math.PI;
    } else if (formationType === 'ace_pilot') {
      this.behavior = 'ace_pilot';
      this.subType = 'ace';
      this.x = Math.random() > 0.5 ? -100 : width + 100;
      this.y = Math.random() * 200;
      this.hp = 600 * Math.pow(1.10, waveDiff - 1);
      this.maxHp = this.hp;
      this.speed = 6.0;
      this.damage = 10;
      this.fireInterval = 15;
    } else if (formationType === 'boss_missile') {
      this.behavior = 'boss_missile';
      this.subType = 'boss_missile';
      this.x = startX; this.y = startY;
      this.hp = 120; // Player can shoot it down relatively easily
      this.maxHp = 120;
      this.speed = 2.5;
      this.damage = 150; // Heavy damage to player
      this.size = 20;
      this.fireInterval = 9999;
    } else if (formationType === 'fighter-wing') {
      this.behavior = 'fighter-wing';
      this.x = startX; this.y = startY;
      this.speed = 7.2 * Math.pow(1.02, waveDiff - 1); // 2x speed
      this.fireInterval = 60;
    } else if (this.formationType === 'diagonal-kette') {
      this.behavior = 'diagonal-kette';
      this.x = startX; this.y = startY - 50;
      this.rotation = Math.PI;
      this.fireInterval = 80;
    } else if (this.formationType === 'box') {
      this.behavior = 'box';
      this.x = startX; this.y = startY - 50;
      this.rotation = Math.PI;
      this.fireInterval = 90;
    } else if (this.formationType === 'column-sweep') {
      this.behavior = 'column-sweep';
      this.x = startX || Math.random() * (width - 200) + 100;
      this.y = startY || -150;
      this.rotation = Math.PI;
      this.vy = 0;
      this.fireInterval = 70;
    } else {
      this.x = Math.random() * (width - 80) + 40;
      this.y = -150;
      this.behavior = 'homing';
      this.fireInterval = 100;
    }

    if(this.formationType !== 'bomber' && this.formationType !== 'ace_pilot' && this.formationType !== 'boss_missile' && this.formationType !== 'fighter-wing') {
       this.speed = 3.6 * Math.pow(1.02, waveDiff - 1); 
       this.damage = Math.min(50, 20 * Math.pow(1.08, waveDiff - 1));
    }
    this.fireTimer = Math.random() * this.fireInterval;
    this.slowed = false; this.stunned = false; this.stunTimer = 0; this.burnTimer = 0;
  }

  update() {
    if (this.isCrashing) {
        this.crashTimer--;
        this.y += 6;
        this.rotation += 0.3;
        spawnParticles(this.x, this.y, '#ff4400', 4);
        spawnParticles(this.x, this.y, '#222222', 4);
        if (this.crashTimer <= 0) { finalizeKillEnemy(this); }
        return;
    }

    if (this.stunned) { this.stunTimer--; if (this.stunTimer <= 0) this.stunned = false; else return; }
    if (this.burnTimer > 0) { 
        this.burnTimer--; this.hp -= 1.5 * player.damageMultiplier; 
        if(frameCount % 5 === 0) spawnParticles(this.x, this.y, '#ff4400', 3);
        if (this.hp <= 0) { killEnemy(this); return; } 
    }
    
    const speedMult = this.slowed ? 0.40 : 1; 

    if (this.returning) {
        if (!this.returnTargetX) {
            this.returnTargetX = width * 0.2 + Math.random() * (width * 0.6);
            this.returnTargetY = height * 0.1 + Math.random() * (height * 0.3);
            this.rotation = Math.atan2(this.returnTargetY - this.y, this.returnTargetX - this.x);
        }

        let targetRotation = Math.atan2(this.returnTargetY - this.y, this.returnTargetX - this.x);
        let diff = targetRotation - this.rotation;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        this.rotation += diff * 0.05;

        this.x += Math.cos(this.rotation) * this.speed * 1.5 * speedMult;
        this.y += Math.sin(this.rotation) * this.speed * 1.5 * speedMult;

        if (Math.hypot(this.returnTargetX - this.x, this.returnTargetY - this.y) < 50) {
            this.returning = false;
            this.returnTargetX = null;
        }
    } else {
        if (this.behavior === 'bomber') {
           this.y += this.speed * speedMult;
           if (this.y > height + 100) { this.returning = true; }
        } else if (this.behavior === 'ace_pilot') {
           this.rotation = Math.atan2(player.y - this.y, player.x - this.x);
           this.x += Math.cos(this.rotation) * this.speed * speedMult;
           this.y += Math.sin(this.rotation) * this.speed * speedMult;
           if (this.y > height + 150 || this.y < -150 || this.x > width + 150 || this.x < -150) { this.returning = true; }
        } else if (this.behavior === 'boss_missile') {
           this.rotation = Math.atan2(player.y - this.y, player.x - this.x);
           this.x += Math.cos(this.rotation) * this.speed * speedMult;
           this.y += Math.sin(this.rotation) * this.speed * speedMult;
           if (frameCount % 3 === 0) spawnParticles(this.x, this.y, '#888888', 2);
        } else if (this.behavior === 'fighter-wing') {
           this.x += this.side * this.speed * speedMult;
           this.y += Math.sin(frameCount * 0.05 + this.xOffset) * 4.0 + 1.5;
           this.rotation = Math.atan2(Math.sin(frameCount * 0.05 + this.xOffset) * 4.0 + 1.5, this.side * this.speed * speedMult);
           if (this.x > width + 150 || this.x < -150 || this.y > height + 100) this.returning = true;
        } else if (this.behavior === 'diagonal-kette' || this.behavior === 'box') {
           this.y += this.speed * speedMult; 
           if (this.y > height + 80) { this.returning = true; }
        } else if (this.behavior === 'column-sweep') {
          const dir = this.vy === -1 ? -1 : 1;
          this.y += this.speed * speedMult * dir;
          if (dir === 1 && this.y > height + 80) { this.vy = -1; } 
          else if (dir === -1 && this.y < -80) { this.returning = true; }
        } else {
          if (this.y < this.targetY) this.y += this.speed * speedMult * 0.9;
          else { 
            if (this.subType === 'tank') {
               this.x += (player.x - this.x) * 0.02 * speedMult;
               this.y += (player.y - this.y - 300) * 0.01 * speedMult; 
               this.rotation = Math.atan2(player.y - this.y, player.x - this.x) - Math.PI/2;
            } else {
               this.x += (player.x - this.x) * 0.008 * speedMult; 
               this.x += Math.cos(frameCount * 0.022 + this.xOffset) * 2.0; 
               this.rotation = Math.PI + Math.sin(frameCount * 0.08) * 0.2;
            }
          }
        }
    }

    if (!this.returning) {
        enemies.forEach(other => {
            if (other !== this && !other.isBoss && !other.isCrashing) {
                let dx = this.x - other.x; let dy = this.y - other.y;
                let dist = Math.hypot(dx, dy);
                let minDist = this.size + 15;
                if (dist < minDist && dist > 0) {
                    this.x += (dx / dist) * 1.5;
                    this.y += (dy / dist) * 1.5;
                }
            }
        });
    }
    
    if (!inIntermission && this.subType !== 'boss_missile') {
        let distToPlayer = Math.hypot(this.x - player.x, this.y - player.y);
        let shootRange = height * 0.75;
        this.fireTimer--;
        if (this.fireTimer <= 0 && distToPlayer < shootRange && this.y > -50 && this.y < height + 50) { 
            this.fireTimer = this.fireInterval; 
            if (this.subType === 'bomber' || this.subType === 'ace' || Math.random() < 0.6) this.shoot();
        }
    }
  }

  shoot() {
    if (this.subType === 'bomber') {
        for (let i=0; i<8; i++) {
            let a = (i/8)*Math.PI*2;
            bullets.push(new Bullet(this.x, this.y+20, Math.cos(a)*8, Math.sin(a)*8, '#ffaa00', true, 'NONE', false, this.damage));
        }
        playEnemyGun('tank');
        return;
    }
    
    if (this.subType === 'ace') {
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*12, Math.sin(angle)*12, '#ffffff', true, 'NONE', false, this.damage));
        playEnemyGun('speedy');
        return;
    }

    const angle = Math.atan2(player.y - this.y, player.x - this.x);
    const spd = this.subType === 'tank' ? 7.0 : 9.0;
    let b = new Bullet(this.x, this.y + 20, Math.cos(angle)*spd, Math.sin(angle)*spd, '#ff5555', true, 'NONE', false, this.damage);
    b.size = this.subType === 'tank' ? 9 : 7;
    bullets.push(b);
    playEnemyGun(this.subType || 'normal');
  }
  
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); 
    
    if (this.subType === 'ace' || this.subType === 'boss_missile' || this.behavior === 'fighter-wing' || this.returning) {
         ctx.rotate(this.rotation + Math.PI/2);
    } else {
         ctx.rotate(this.rotation);
    }
    
    let renderScale = this.subType === 'bomber' ? 3.0 : 2.0;
    if (this.isCrashing) {
        let crashScale = Math.max(0.01, 1 - (22 - this.crashTimer)/22);
        ctx.scale(renderScale * crashScale, renderScale * crashScale);
    } else {
        ctx.scale(renderScale, renderScale);
    }

    if (this.subType === 'bomber') {
        ctx.shadowBlur = 40; ctx.shadowColor = '#ff6600';
        ctx.fillStyle = '#442211';
        ctx.beginPath(); ctx.moveTo(-20, 10); ctx.lineTo(20, 10); ctx.lineTo(30, -10); ctx.lineTo(0, -30); ctx.lineTo(-30, -10); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, -10, 8, 0, Math.PI*2); ctx.fill();
    } else if (this.subType === 'ace') {
        ctx.shadowBlur = 20; ctx.shadowColor = '#ffffff';
        ctx.fillStyle = '#ffffff';
        ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-10, 10); ctx.lineTo(10, 10); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
    } else if (this.subType === 'boss_missile') {
        ctx.shadowBlur = 15; ctx.shadowColor = '#ff2200';
        ctx.fillStyle = '#aa0000';
        ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-10, 10); ctx.lineTo(10, 10); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, -15, 6, 0, Math.PI*2); ctx.fill();
        let flameH = 10 + Math.random() * 15;
        ctx.fillStyle = '#ffeedd';
        ctx.beginPath(); ctx.moveTo(-5, 10); ctx.lineTo(0, 10 + flameH); ctx.lineTo(5, 10); ctx.fill();
    } else {
        ctx.shadowBlur = 48; ctx.shadowColor = this.type === 6 ? '#ff0055' : (this.type < 3 ? '#ff3333' : '#aa00ff');
        let flameH = 18 + Math.random() * 8; 
        let grad = ctx.createLinearGradient(0, 18, 0, 18 + flameH);
        grad.addColorStop(0, '#ff4400'); grad.addColorStop(1, 'rgba(255, 68, 0, 0)'); 
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.moveTo(-4, 18); ctx.lineTo(0, 18+flameH); ctx.lineTo(4, 18); ctx.fill();
        
        ctx.fillStyle = this.slowed ? '#0077ff' : (this.type === 6 ? '#880022' : (this.type < 3 ? '#660000' : '#440066'));
        ctx.beginPath(); ctx.moveTo(-14, 12); ctx.lineTo(14, 12); ctx.lineTo(22, -8); ctx.lineTo(0, -26); ctx.lineTo(-22, -8); ctx.closePath(); ctx.fill();
        
        ctx.fillStyle = this.type < 3 ? '#ff4444' : '#aa44ff'; 
        ctx.beginPath(); ctx.arc(0, -8, 5, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = '#ffdd88'; ctx.fillRect(-2, -30, 4, 12);
    }
    ctx.restore();
  }
}

class Boss {
  constructor(waveNum) {
    this.waveNum = waveNum; this.isBoss = true;
    let opMult = 1 + (currentWeaponTier * 0.2);
    this.currentPhase = 0; 
    this.parts = [];
    let totalBossHp = 0;
    this.isCrashing = false; this.crashTimer = 0;
    
    if (waveNum === 3) {
      this.name = "IRON HAWK FORTRESS";
      this.parts.push({id:'eng_l', relX:-110, relY:60, hp:2200*opMult, maxHp:2200*opMult, radius:30, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_r', relX:110, relY:60, hp:2200*opMult, maxHp:2200*opMult, radius:30, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'gun_l', relX:-70, relY:-65, hp:2000*opMult, maxHp:2000*opMult, radius:22, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
      this.parts.push({id:'gun_r', relX:70, relY:-65, hp:2000*opMult, maxHp:2000*opMult, radius:22, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
      this.parts.push({id:'hull', relX:0, relY:0, hp:3000*opMult, maxHp:3000*opMult, radius:55, color:'#ff2200', isDead:false, phase:2, label:'HULL'});
      totalBossHp = 11400 * opMult;
    } else if (waveNum === 6) {
      this.name = "STEEL CARRIER FORTRESS";
      this.parts.push({id:'eng_fl', relX:-130, relY:80, hp:2800*opMult, maxHp:2800*opMult, radius:28, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_fr', relX:130, relY:80, hp:2800*opMult, maxHp:2800*opMult, radius:28, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_rl', relX:-50, relY:90, hp:2800*opMult, maxHp:2800*opMult, radius:24, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_rr', relX:50, relY:90, hp:2800*opMult, maxHp:2800*opMult, radius:24, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'bat_l', relX:-120, relY:-20, hp:3500*opMult, maxHp:3500*opMult, radius:26, color:'#ff8800', isDead:false, phase:1, label:'BATTERY'});
      this.parts.push({id:'bat_c', relX:0, relY:-80, hp:3500*opMult, maxHp:3500*opMult, radius:26, color:'#ff8800', isDead:false, phase:1, label:'BATTERY'});
      this.parts.push({id:'bat_r', relX:120, relY:-20, hp:3500*opMult, maxHp:3500*opMult, radius:26, color:'#ff8800', isDead:false, phase:1, label:'BATTERY'});
      this.parts.push({id:'hull', relX:0, relY:10, hp:5000*opMult, maxHp:5000*opMult, radius:65, color:'#ff2200', isDead:false, phase:2, label:'HULL'});
      totalBossHp = 25600 * opMult;
    } else if (waveNum === 9) {
      this.name = "DOOM ZEPPELIN";
      this.parts.push({id:'prop_l', relX:-120, relY:50, hp:4000*opMult, maxHp:4000*opMult, radius:32, color:'#00ff66', isDead:false, phase:0, label:'PROPELLER'});
      this.parts.push({id:'prop_c', relX:0, relY:80, hp:4000*opMult, maxHp:4000*opMult, radius:32, color:'#00ff66', isDead:false, phase:0, label:'PROPELLER'});
      this.parts.push({id:'prop_r', relX:120, relY:50, hp:4000*opMult, maxHp:4000*opMult, radius:32, color:'#00ff66', isDead:false, phase:0, label:'PROPELLER'});
      this.parts.push({id:'tur_ll', relX:-140, relY:-30, hp:3500*opMult, maxHp:3500*opMult, radius:24, color:'#ff8800', isDead:false, phase:1, label:'TURRET'});
      this.parts.push({id:'tur_l', relX:-60, relY:-60, hp:3500*opMult, maxHp:3500*opMult, radius:24, color:'#ff8800', isDead:false, phase:1, label:'TURRET'});
      this.parts.push({id:'tur_r', relX:60, relY:-60, hp:3500*opMult, maxHp:3500*opMult, radius:24, color:'#ff8800', isDead:false, phase:1, label:'TURRET'});
      this.parts.push({id:'tur_rr', relX:140, relY:-30, hp:3500*opMult, maxHp:3500*opMult, radius:24, color:'#ff8800', isDead:false, phase:1, label:'TURRET'});
      this.parts.push({id:'hull', relX:0, relY:-20, hp:6000*opMult, maxHp:6000*opMult, radius:70, color:'#ff2200', isDead:false, phase:2, label:'GONDOLA'});
      totalBossHp = 28000 * opMult;
    } else if (waveNum === 10) {
      this.name = "FINAL COLOSSUS";
      this.parts.push({id:'eng_ll', relX:-200, relY:100, hp:6000*opMult, maxHp:6000*opMult, radius:38, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_l', relX:-110, relY:120, hp:6000*opMult, maxHp:6000*opMult, radius:35, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_c', relX:0, relY:130, hp:7000*opMult, maxHp:7000*opMult, radius:40, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_r', relX:110, relY:120, hp:6000*opMult, maxHp:6000*opMult, radius:35, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_rr', relX:200, relY:100, hp:6000*opMult, maxHp:6000*opMult, radius:38, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'can_ll', relX:-190, relY:-50, hp:5500*opMult, maxHp:5500*opMult, radius:30, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'can_l', relX:-100, relY:-80, hp:5500*opMult, maxHp:5500*opMult, radius:30, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'can_c', relX:0, relY:-110, hp:6000*opMult, maxHp:6000*opMult, radius:34, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'can_r', relX:100, relY:-80, hp:5500*opMult, maxHp:5500*opMult, radius:30, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'can_rr', relX:190, relY:-50, hp:5500*opMult, maxHp:5500*opMult, radius:30, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'core', relX:0, relY:0, hp:14000*opMult, maxHp:14000*opMult, radius:90, color:'#ff0000', isDead:false, phase:2, label:'CORE'});
      totalBossHp = 80000 * opMult;
    }
    
    this.hp = totalBossHp; this.maxHp = totalBossHp;
    this.speed = waveNum === 10 ? 4.4 : (waveNum === 9 ? 3.2 : 2.4);
    this.x = width / 2; this.y = -400;
    this.targetY = waveNum === 6 ? 120 : (waveNum === 10 ? 150 : 170);
    this.introPhase = true;
    this.fireTimer = 0; this.pattern = 0; this.patternTimer = 0;
    this.attackPhaseTimer = 0; this.attackInterval = 40; 
    this.inAttack = false; this.attackBurstTimer = 0;
    this.burnTimer = 0; this.hitCount = 0; this.direction = 1; this.slowed = false;
  }
  
  checkCurrentPhase() {
    let phaseParts = this.parts.filter(p => p.phase === this.currentPhase && !p.isDead);
    if (phaseParts.length === 0) {
      this.currentPhase++;
      if (this.currentPhase === 1) { 
        let msg = this.waveNum === 10 ? "ENGINES DOWN! DESTROY THE CANNONS!" : "ENGINES DOWN! TARGET THE GUNS!";
        showNotification(msg); cameraShake = 20; 
      }
      else if (this.currentPhase === 2) { 
        let msg = this.waveNum === 10 ? "CANNONS DESTROYED! TARGET THE CORE!" : "GUNS DESTROYED! TARGET THE HULL!";
        showNotification(msg); cameraShake = 30; 
      }
    }
  }
  
  update() {
    if (this.isCrashing) {
        this.crashTimer--;
        this.y += 3.0;
        this.x += Math.sin(this.crashTimer * 0.2) * 5;
        spawnParticles(this.x + (Math.random()-0.5)*150, this.y + (Math.random()-0.5)*150, '#ff4400', 10);
        spawnParticles(this.x + (Math.random()-0.5)*150, this.y, '#222222', 15);
        if (this.crashTimer <= 0) { finalizeKillEnemy(this); }
        return;
    }

    if (this.burnTimer > 0) { 
      this.burnTimer--; 
      if (this.currentPhase <= 2) {
        let activeParts = this.parts.filter(p => p.phase === this.currentPhase && !p.isDead);
        if (activeParts.length > 0) {
          let burnTarget = activeParts[Math.floor(Math.random() * activeParts.length)];
          burnTarget.hp -= 2.4 * player.damageMultiplier;
          if(frameCount%5===0) spawnParticles(this.x + burnTarget.relX, this.y + burnTarget.relY, '#ff4400', 3);
          if (burnTarget.hp <= 0) { burnTarget.isDead = true; burnTarget.hp = 0; this.checkCurrentPhase(); }
        }
      } else {
        this.hp -= 2.4 * player.damageMultiplier;
        if(frameCount%5===0) spawnParticles(this.x, this.y, '#ff4400', 3);
      }
    }
    
    if (this.currentPhase !== undefined && this.currentPhase !== 99 && this.currentPhase > 2) return;
    
    let baseSpeedMult = this.slowed ? 0.60 : 1.0;
    let totalEngines = this.parts.filter(p => p.label === 'ENGINE' || p.label === 'PROPELLER').length;
    let aliveEngines = this.parts.filter(p => (p.label === 'ENGINE' || p.label === 'PROPELLER') && !p.isDead).length;
    if (totalEngines > 0) {
        baseSpeedMult *= (0.3 + 0.7 * (aliveEngines / totalEngines));
    }
    
    if (this.introPhase) {
        if (this.y < this.targetY) { this.y += 5.0 * baseSpeedMult; } 
        else { this.y = this.targetY; this.introPhase = false; }
    } else {
        if (this.waveNum === 6) {
            this.x += this.speed * 2.5 * this.direction * baseSpeedMult;
            if(this.x < width*0.2 || this.x > width*0.8) this.direction *= -1;
        } else if (this.waveNum === 9) {
            this.x += Math.sin(frameCount * 0.036) * 6.0 * baseSpeedMult;
            this.y = this.targetY + Math.sin(frameCount * 0.060) * 60;
        } else if (this.waveNum === 10) {
            this.x += this.speed * 4.5 * this.direction * baseSpeedMult;
            this.y = this.targetY + Math.sin(frameCount * 0.050) * 80;
            if(this.x < width*0.1 || this.x > width*0.9) { this.direction *= -1; }
        } else {
            this.x += this.speed * 3.5 * this.direction * baseSpeedMult;
            if(this.x < width*0.15 || this.x > width*0.85) { this.direction *= -1; }
        }
    }
    
    if (!inIntermission && !this.introPhase) {
        this.patternTimer++;
        this.attackPhaseTimer++;
        let numPatterns = this.waveNum === 10 ? 4 : (this.waveNum === 9 ? 5 : (this.waveNum === 6 ? 4 : 3));
        
        let activeGunsCount = this.parts.filter(p => !p.isDead && ['GUN', 'BATTERY', 'TURRET', 'CANNON'].includes(p.label)).length;
        let isRageMode = (this.currentPhase === 1 && activeGunsCount === 1);

        if (this.attackPhaseTimer >= this.attackInterval) {
            this.attackPhaseTimer = 0;
            this.inAttack = true;
            this.attackBurstTimer = 0;
            this.pattern = (this.pattern + 1) % numPatterns;
            this.attackInterval = this.waveNum === 10 ? 80 + Math.random() * 40 : 40 + Math.random() * 30;
            if (isRageMode) this.attackInterval = 25; 
        }
        
        if (this.inAttack) {
            this.attackBurstTimer++;
            this.fireTimer++;
            
// Fire interval verhoogd voor Boss 10 zodat hij minder spammt
            let fireInterval = this.waveNum === 10 ? (this.pattern === 2 ? 160 : (this.pattern === 1 ? 120 : 80)) : (this.waveNum === 3 ? 22 : (this.waveNum === 6 ? 18 : 14));
            
            if (this.currentPhase === 0) {
                fireInterval *= 5; 
            } else if (isRageMode) {
                fireInterval = 6; 
            } else if (this.currentPhase === 1) {
                fireInterval = Math.max(4, Math.floor(fireInterval * 0.8)); 
            }

            if (this.fireTimer >= fireInterval) { this.fireTimer = 0; this.shoot(); }
            
            // Burst duration verlaagd (was 180) zodat de aanvalspauzes eerlijker zijn
            let burstDuration = this.waveNum === 10 ? 110 : 90;          
            if (isRageMode) burstDuration = 5; 
            if (this.currentPhase === 0) burstDuration = Math.floor(burstDuration * 1.5); 

            if (this.attackBurstTimer >= burstDuration) { this.inAttack = false; }
        }
    }
  }
  
  shoot() {
    playEnemyGun('tank');
    let angle = Math.atan2(player.y - this.y, player.x - this.x);
    let activeGuns = this.parts.filter(p => !p.isDead && ['GUN', 'BATTERY', 'TURRET', 'CANNON'].includes(p.label));
    
    if (activeGuns.length === 0) return; 

    // RAGE MODE voor ELKE boss, inclusief custom effect voor Wave 10
    if (this.currentPhase === 1 && activeGuns.length === 1) {
        let g = activeGuns[0];
        let bx = this.x + g.relX; let by = this.y + g.relY;
        let ba = Math.atan2(player.y - by, player.x - bx);
        
        // 7 kogels per burst in wijd verspreide vorm
        for(let i = -3; i <= 3; i++) {
            let b = new Bullet(bx, by, Math.cos(ba + i*0.12)*14, Math.sin(ba + i*0.12)*14, '#ff0000', true, 'NONE', false, 60);
            b.size = 11; bullets.push(b);
        }
        
        // Wave 10 voegt ook nog wanhopige bommen toe in rage mode!
        if (this.waveNum === 10) {
            if (Math.random() < 0.3) {
                let bomb = new Bullet(bx, by, Math.cos(ba)*5, Math.sin(ba)*5, '#ff8800', true, 'NONE', true, 100, { bigExplosion: true });
                bomb.size = 20; bullets.push(bomb);
            }
        }
        return; 
    }

    if (this.waveNum === 3) {
      if (this.pattern === 0) {
        activeGuns.forEach(g => {
            let bx = this.x + g.relX; let by = this.y + g.relY;
            let ba = Math.atan2(player.y - by, player.x - bx);
            let b = new Bullet(bx, by, Math.cos(ba)*10, Math.sin(ba)*10, '#ffaa00', true, 'NONE', false, 50); b.size=9; bullets.push(b);
        });
      } else if (this.pattern === 1) {
         activeGuns.forEach(g => {
             let bx = this.x + g.relX; let by = this.y + g.relY;
             for (let i=-1; i<=1; i++) {
                 let b = new Bullet(bx, by, Math.cos(angle+i*0.2)*11, Math.sin(angle+i*0.2)*11, '#ff3300', true, 'NONE', false, 55); b.size=8; bullets.push(b);
             }
         });
      } else if (this.pattern === 2) {
        activeGuns.forEach(g => {
            let b = new Bullet(this.x + g.relX, this.y + g.relY, Math.cos(angle)*14, Math.sin(angle)*14, '#ff6600', true, 'NONE', false, 80, {isMissile:true}); b.size=12; bullets.push(b);
        });
      }
    } else if (this.waveNum === 6) {
      if (this.pattern === 0) {
        activeGuns.forEach(g => {
            let bx = this.x + g.relX; let by = this.y + g.relY; let ba = Math.atan2(player.y - by, player.x - bx);
            for (let i=-1; i<=1; i++) {
                let b = new Bullet(bx, by, Math.cos(ba+i*0.12)*10, Math.sin(ba+i*0.12)*10, '#ffcc00', true, 'NONE', false, 60); b.size=8; bullets.push(b);
            }
        });
      } else if (this.pattern === 1) {
        activeGuns.forEach((g, idx) => {
            let offset = (idx - activeGuns.length/2) * 0.15;
            let b = new Bullet(this.x + g.relX, this.y + g.relY, Math.cos(angle+offset)*11, Math.sin(angle+offset)*11, '#ff4400', true, 'NONE', false, 100, {isMissile:true}); b.size=11; bullets.push(b);
        });
      } else if (this.pattern === 2) {
        activeGuns.forEach(g => {
            for (let i=0; i<4; i++) {
              let a = (i/4)*Math.PI*2 + frameCount*0.1; let b = new Bullet(this.x + g.relX, this.y + g.relY, Math.cos(a)*12, Math.sin(a)*12, '#00ffff', true, 'NONE', false, 45); b.size=8; bullets.push(b);
            }
        });
      } else if (this.pattern === 3) {
        activeGuns.forEach(g => {
          let b = new Bullet(this.x + g.relX, this.y + g.relY, Math.cos(angle)*12, Math.sin(angle)*12, '#ff8800', true, 'NONE', false, 70); b.size=10; bullets.push(b);
        });
      }
    } else if (this.waveNum === 9) {
      activeGuns.forEach(g => {
          let bx = this.x + g.relX; let by = this.y + g.relY;
          let ba = Math.atan2(player.y - by, player.x - bx);
          
          if (this.pattern === 0) {
             let b = new Bullet(bx, by, Math.cos(ba)*11, Math.sin(ba)*11, '#ff0000', true, 'NONE', false, 90); b.size=11; bullets.push(b);
          } else if (this.pattern === 1) {
             let b = new Bullet(bx, by, Math.cos(ba)*12, Math.sin(ba)*12, '#ff6600', true, 'NONE', false, 120, {isMissile:true}); b.size=13; bullets.push(b);
          } else if (this.pattern === 2) {
             for (let i=-1; i<=1; i++) {
                 let b = new Bullet(bx, by, Math.cos(ba+i*0.2)*10, Math.sin(ba+i*0.2)*10, '#ff2200', true, 'NONE', false, 75); b.size=9; bullets.push(b);
             }
          } else if (this.pattern === 3) {
             let b = new Bullet(bx, by, Math.cos(ba)*14, Math.sin(ba)*14, '#ffcc00', true, 'NONE', false, 80); b.size=9; bullets.push(b);
          } else {
             let a = frameCount * 0.1; 
             let b = new Bullet(bx, by, Math.cos(a)*16, Math.sin(a)*16, '#ff8800', true, 'NONE', false, 100, {isMissile:true}); b.size=12; bullets.push(b);
          }
      });
    } else if (this.waveNum === 10) {
        activeGuns.forEach((g, idx) => {
            let bx = this.x + g.relX; let by = this.y + g.relY;
            let ba = Math.atan2(player.y - by, player.x - bx);

            if (this.pattern === 0) {
                let b = new Bullet(bx, by, Math.cos(ba)*7, Math.sin(ba)*7, '#ff0000', true, 'NONE', false, 60);
                b.size = 9; bullets.push(b);
            } else if (this.pattern === 1) {
                if (idx % 2 === 0) {
                    let b = new Bullet(bx, by, Math.cos(ba)*3.5, Math.sin(ba)*3.5, '#ff8800', true, 'NONE', true, 90, { bigExplosion: true });
                    b.size = 18; bullets.push(b);
                }
            } else if (this.pattern === 2) {
                if (idx === 0 || idx === activeGuns.length - 1) {
                    enemies.push(new Enemy(wave, 'boss_missile', bx, by));
                }
            } else {
                if (idx % 2 !== 0) {
                    let b = new Bullet(bx, by, Math.cos(ba)*6, Math.sin(ba)*6, '#ff0000', true, 'NONE', false, 60);
                    b.size = 9; bullets.push(b);
                } else if (Math.random() < 0.5) {
                    let b = new Bullet(bx, by, Math.cos(ba)*3, Math.sin(ba)*3, '#ff8800', true, 'NONE', true, 90, { bigExplosion: true });
                    b.size = 18; bullets.push(b);
                }
            }
        });
    }
  }
  
  draw() {
    ctx.save(); ctx.translate(this.x, this.y);
    
    if (this.isCrashing) {
        let crashScale = Math.max(0.01, 1 - (75 - this.crashTimer)/75);
        ctx.scale(crashScale, crashScale);
        ctx.rotate(Math.sin(this.crashTimer * 0.1) * 0.2);
    }

    if (this.waveNum === 10) {
      ctx.shadowBlur = 30; ctx.shadowColor = '#ff0000';
      ctx.fillStyle = '#1a0000';
      ctx.beginPath(); ctx.ellipse(0, 0, 250, 140, 0, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#ff2200'; ctx.lineWidth = 3; ctx.stroke();
      [-230,-150,150,230].forEach(ox => {
        ctx.fillStyle = '#110000'; ctx.fillRect(ox > 0 ? ox-10 : ox, -25, 20, 130);
        ctx.strokeStyle = '#882200'; ctx.lineWidth = 1.5; ctx.strokeRect(ox > 0 ? ox-10 : ox, -25, 20, 130);
      });
      ctx.fillStyle = '#2a0000'; ctx.fillRect(-100, -130, 200, 40);
      ctx.strokeStyle = '#ff4400'; ctx.lineWidth = 2; ctx.strokeRect(-100,-130,200,40);
      const pulse = Math.sin(frameCount * 0.3) * 0.5 + 0.5;
      ctx.shadowBlur = 40 * pulse; ctx.shadowColor = '#ff0000';
      ctx.fillStyle = `rgba(255,${Math.floor(50*pulse)},0,0.6)`;
      ctx.beginPath(); ctx.arc(0, 10, 45, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#660000'; ctx.lineWidth = 1;
      for (let i=-200; i<=200; i+=80) { ctx.beginPath(); ctx.moveTo(i,-100); ctx.lineTo(i,120); ctx.stroke(); }
    } else if (this.waveNum === 3) {
      ctx.shadowBlur = 20; ctx.shadowColor = '#00ff00';
      ctx.fillStyle = '#1a2a1a'; ctx.fillRect(-140, -50, 280, 130);
      ctx.fillStyle = '#111a11';
      ctx.beginPath(); ctx.moveTo(-140,-20); ctx.lineTo(-210,40); ctx.lineTo(-210,70); ctx.lineTo(-140,70); ctx.fill();
      ctx.beginPath(); ctx.moveTo(140,-20); ctx.lineTo(210,40); ctx.lineTo(210,70); ctx.lineTo(140,70); ctx.fill();
      ctx.fillStyle = '#223322'; ctx.fillRect(-50, -95, 100, 55);
      ctx.strokeStyle = '#336633'; ctx.lineWidth = 2;
      ctx.strokeRect(-140,-50,280,130); ctx.strokeRect(-50,-95,100,55);
      ctx.beginPath(); ctx.moveTo(-140,10); ctx.lineTo(140,10); ctx.stroke();
    } else if (this.waveNum === 6) {
      ctx.shadowBlur = 20; ctx.shadowColor = '#00ff00';
      ctx.fillStyle = '#112211'; ctx.fillRect(-200, -60, 400, 160);
      ctx.fillStyle = '#0d1a0d';
      ctx.fillRect(-250, -20, 60, 100); ctx.fillRect(190, -20, 60, 100);
      ctx.fillStyle = '#1a3a1a'; ctx.fillRect(-30, -110, 60, 60);
      ctx.fillStyle = '#224422'; ctx.fillRect(-60, -80, 120, 30);
      ctx.strokeStyle = '#336633'; ctx.lineWidth = 1.5;
      ctx.strokeRect(-200,-60,400,160);
      for (let i=-150; i<=150; i+=75) { ctx.beginPath(); ctx.moveTo(i,-60); ctx.lineTo(i,100); ctx.stroke(); }
    } else if (this.waveNum === 9) {
      ctx.shadowBlur = 20; ctx.shadowColor = '#ff4400';
      ctx.fillStyle = '#221111';
      ctx.beginPath(); ctx.ellipse(0, -10, 180, 90, 0, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#662222'; ctx.lineWidth = 2; ctx.stroke();
      ctx.fillStyle = '#331a1a'; ctx.fillRect(-80, 60, 160, 50);
      ctx.strokeStyle = '#ff4400'; ctx.lineWidth = 1.5; ctx.strokeRect(-80,60,160,50);
      ctx.fillStyle = '#2a1010';
      ctx.beginPath(); ctx.moveTo(-180,0); ctx.lineTo(-220,-40); ctx.lineTo(-220,40); ctx.fill();
      ctx.beginPath(); ctx.moveTo(180,0); ctx.lineTo(220,-40); ctx.lineTo(220,40); ctx.fill();
      ctx.strokeStyle = '#441111'; ctx.lineWidth = 1;
      for (let i=-3; i<=3; i++) { ctx.beginPath(); ctx.ellipse(0, -10, 180, 90, i*0.2, 0, Math.PI*2); ctx.stroke(); }
    }
    
    for (let part of this.parts) {
      ctx.save(); ctx.translate(part.relX, part.relY);
      if (part.isDead) {
          ctx.fillStyle = '#1a1a1a';
          if (frameCount % 8 === 0) spawnParticles(this.x + part.relX, this.y + part.relY, '#ff4400', 2);
      } else {
          const isCurrentTarget = (part.phase === this.currentPhase);
          ctx.fillStyle = part.isDead ? '#111' : (isCurrentTarget ? part.color : '#444455');
      }
      
      if (part.label === 'ENGINE' || part.label === 'PROPELLER') {
          ctx.beginPath(); ctx.arc(0, 0, part.radius, 0, Math.PI*2); ctx.fill();
      } else if (part.label === 'GUN' || part.label === 'BATTERY' || part.label === 'TURRET' || part.label === 'CANNON') {
          ctx.fillRect(-part.radius*0.7, -part.radius*0.7, part.radius*1.4, part.radius*1.4);
          if (!part.isDead && part.phase === this.currentPhase) {
            const barrelAngle = Math.atan2(player.y-(this.y+part.relY), player.x-(this.x+part.relX));
            ctx.save(); ctx.rotate(barrelAngle);
            ctx.fillStyle = '#888'; ctx.fillRect(-4, -part.radius, 8, part.radius);
            ctx.restore();
          }
      } else { 
          ctx.beginPath(); ctx.arc(0, 0, part.radius*0.6, 0, Math.PI*2); ctx.fill();
      }
      

// VISUAL TARGET INDICATOR
             if (!part.isDead && part.phase === this.currentPhase) {
          ctx.save();
          // Gebruik cyaan voor Boss 10 omdat de boss zelf al rood is!
          let crossColor = this.waveNum === 10 ? '#00ffff' : '#ff0000';
          ctx.strokeStyle = crossColor; 
          ctx.lineWidth = 4;
          ctx.shadowColor = crossColor;
          ctx.shadowBlur = 15;
          ctx.setLineDash([12, 12]);
          ctx.lineDashOffset = -frameCount * 1.5; // Draait lekker snel
          ctx.beginPath();
          let glowRadius = part.radius + 15 + Math.sin(frameCount * 0.2) * 5;
          ctx.arc(0, 0, glowRadius, 0, Math.PI*2);
          ctx.stroke();
          
          ctx.setLineDash([]);
          ctx.lineWidth = 3;
          let crossLen = 16;
          ctx.beginPath();
          ctx.moveTo(0, -glowRadius - crossLen); ctx.lineTo(0, -glowRadius - 4);
          ctx.moveTo(0, glowRadius + 4); ctx.lineTo(0, glowRadius + crossLen);
          ctx.moveTo(-glowRadius - crossLen, 0); ctx.lineTo(-glowRadius - 4, 0);
          ctx.moveTo(glowRadius + 4, 0); ctx.lineTo(glowRadius + crossLen, 0);
          ctx.stroke();
          ctx.restore();
      }
      ctx.restore();
    }
    
    if(this.slowed) { ctx.fillStyle = 'rgba(0,100,255,0.15)'; ctx.beginPath(); ctx.arc(0,0,260,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
}

class SecretBoss {
  constructor() {
    this.isBoss = true; this.isSecret = true; 
    let opMult = 1 + (currentWeaponTier * 0.2);
    this.name = "EUGENBURG DOOM-ENTITY";
    this.currentPhase = 0; 
    this.isCrashing = false; this.crashTimer = 0;
    
    this.parts = [];
    let totalBossHp = 0;
    
    // Phase 0: Engines
    let engineHp = 7000 * opMult;
    this.parts.push({id:'eng_ll', relX:-120, relY:80, hp:engineHp, maxHp:engineHp, radius:32, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    this.parts.push({id:'eng_l', relX:-60, relY:100, hp:engineHp, maxHp:engineHp, radius:30, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    this.parts.push({id:'eng_c', relX:0, relY:110, hp:engineHp, maxHp:engineHp, radius:34, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    this.parts.push({id:'eng_r', relX:60, relY:100, hp:engineHp, maxHp:engineHp, radius:30, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    this.parts.push({id:'eng_rr', relX:120, relY:80, hp:engineHp, maxHp:engineHp, radius:32, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    totalBossHp += engineHp * 5;
    
    // Phase 1: Guns (top corners)
    let gunHp = 2500 * opMult;
    this.parts.push({id:'gun_ll', relX:-150, relY:-80, hp:gunHp, maxHp:gunHp, radius:26, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
    this.parts.push({id:'gun_l', relX:-70, relY:-90, hp:gunHp, maxHp:gunHp, radius:26, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
    this.parts.push({id:'gun_r', relX:70, relY:-90, hp:gunHp, maxHp:gunHp, radius:26, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
    this.parts.push({id:'gun_rr', relX:150, relY:-80, hp:gunHp, maxHp:gunHp, radius:26, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
    totalBossHp += gunHp * 4;
    
    // Phase 2: Core (center)
    let coreHp = 5000 * opMult;
    this.parts.push({id:'core', relX:0, relY:0, hp:coreHp, maxHp:coreHp, radius:70, color:'#ff2200', isDead:false, phase:2, label:'CORE'});
    totalBossHp += coreHp;
    
    this.hp = totalBossHp; this.maxHp = totalBossHp;
    this.x = width / 2; this.y = -300;
    this.targetY = 180;
    this.introPhase = true;
    this.speed = 5.5; this.burnTimer = 0; this.angleOffset = 0; this.hitCount = 0; this.slowed = false;
    this.fireTimer = 0; this.pattern = 0; this.patternTimer = 0;
    this.attackPhaseTimer = 0; this.attackInterval = 40; 
    this.inAttack = false; this.attackBurstTimer = 0;
    this.direction = 1;
  }
  
  checkCurrentPhase() {
    let phaseParts = this.parts.filter(p => p.phase === this.currentPhase && !p.isDead);
    if (phaseParts.length === 0) {
      this.currentPhase++;
      if (this.currentPhase === 1) { 
        showNotification("ENGINES DOWN! TARGET THE GUNS!"); cameraShake = 20; 
      }
      else if (this.currentPhase === 2) { 
        showNotification("GUNS DESTROYED! TARGET THE CORE!"); cameraShake = 30; 
      }
    }
  }
  
  update() {
    if (this.isCrashing) {
        this.crashTimer--;
        this.y += 3.0;
        this.x += Math.sin(this.crashTimer * 0.2) * 5;
        spawnParticles(this.x + (Math.random()-0.5)*150, this.y + (Math.random()-0.5)*150, '#ff4400', 10);
        spawnParticles(this.x + (Math.random()-0.5)*150, this.y, '#222222', 15);
        if (this.crashTimer <= 0) { finalizeKillEnemy(this); }
        return;
    }

    if (this.burnTimer > 0) { 
      this.burnTimer--; 
      if (this.currentPhase <= 2) {
        let activeParts = this.parts.filter(p => p.phase === this.currentPhase && !p.isDead);
        if (activeParts.length > 0) {
          let burnTarget = activeParts[Math.floor(Math.random() * activeParts.length)];
          burnTarget.hp -= 2.4 * player.damageMultiplier;
          if(frameCount%5===0) spawnParticles(this.x + burnTarget.relX, this.y + burnTarget.relY, '#ff4400', 3);
          if (burnTarget.hp <= 0) { burnTarget.isDead = true; burnTarget.hp = 0; this.checkCurrentPhase(); }
        }
      }
    }
    
    if (this.currentPhase > 2) return;
    
    let baseSpeedMult = this.slowed ? 0.60 : 1.0;
    let totalEngines = this.parts.filter(p => p.label === 'ENGINE').length;
    let aliveEngines = this.parts.filter(p => p.label === 'ENGINE' && !p.isDead).length;
    if (totalEngines > 0) {
        baseSpeedMult *= (0.3 + 0.7 * (aliveEngines / totalEngines));
    }
    
    if (this.introPhase) {
        if (this.y < this.targetY) { this.y += 5.0 * baseSpeedMult; } 
        else { this.y = this.targetY; this.introPhase = false; }
    } else {
        this.x += this.speed * 3.0 * this.direction * baseSpeedMult;
        if(this.x < width*0.15 || this.x > width*0.85) { this.direction *= -1; }
    }
    
    if (!inIntermission && !this.introPhase) {
        this.patternTimer++;
        this.attackPhaseTimer++;
        
        let activeGunsCount = this.parts.filter(p => !p.isDead && p.label === 'GUN').length;
        let isRageMode = (this.currentPhase === 1 && activeGunsCount === 1);

        if (this.attackPhaseTimer >= this.attackInterval) {
            this.attackPhaseTimer = 0;
            this.inAttack = true;
            this.attackBurstTimer = 0;
            this.pattern = (this.pattern + 1) % 4;
            this.attackInterval = 50 + Math.random() * 30;
            if (isRageMode) this.attackInterval = 25; 
        }
        
        if (this.inAttack) {
            this.attackBurstTimer++;
            this.fireTimer++;
            
            let fireInterval = 20;
            
            if (this.currentPhase === 0) {
                fireInterval *= 5; 
            } else if (isRageMode) {
                fireInterval = 8; 
            } else if (this.currentPhase === 1) {
                fireInterval = Math.max(4, Math.floor(fireInterval * 0.6));
            }

            if (this.fireTimer >= fireInterval) { this.fireTimer = 0; this.shoot(); }
            
            let burstDuration = 100;          
            if (isRageMode) burstDuration = 5; 
            if (this.currentPhase === 0) burstDuration = Math.floor(burstDuration * 1.5);

            if (this.attackBurstTimer >= burstDuration) { this.inAttack = false; }
        }
    }
  }
  
  shoot() {
    playEnemyGun('tank');
    let angle = Math.atan2(player.y - this.y, player.x - this.x);
    let activeGuns = this.parts.filter(p => !p.isDead && p.label === 'GUN');
    
    if (activeGuns.length === 0) return; 

    // RAGE MODE when only 1 gun left
    if (this.currentPhase === 1 && activeGuns.length === 1) {
        let g = activeGuns[0];
        let bx = this.x + g.relX; let by = this.y + g.relY;
        let ba = Math.atan2(player.y - by, player.x - bx);
        
        // 5 bullets in wide spread
        for(let i = -2; i <= 2; i++) {
            let b = new Bullet(bx, by, Math.cos(ba + i*0.15)*14, Math.sin(ba + i*0.15)*14, '#ff0000', true, 'NONE', false, 70);
            b.size = 11; bullets.push(b);
        }
        
        // Add bombs
        if (Math.random() < 0.4) {
            let bomb = new Bullet(bx, by, Math.cos(ba)*5, Math.sin(ba)*5, '#ff8800', true, 'NONE', true, 120, { bigExplosion: true });
            bomb.size = 20; bullets.push(bomb);
        }
        return; 
    }

    if (this.currentPhase === 0) {
        // Engine phase - light fire
        activeGuns.forEach(g => {
            let bx = this.x + g.relX; let by = this.y + g.relY;
            let ba = Math.atan2(player.y - by, player.x - bx);
            let b = new Bullet(bx, by, Math.cos(ba)*9, Math.sin(ba)*9, '#ffff00', true, 'NONE', false, 40); b.size=7; bullets.push(b);
        });
    } else if (this.currentPhase === 1) {
        // Gun phase - heavy fire
        if (this.pattern === 0) {
            activeGuns.forEach(g => {
                let bx = this.x + g.relX; let by = this.y + g.relY;
                let ba = Math.atan2(player.y - by, player.x - bx);
                for (let i=-1; i<=1; i++) {
                    let b = new Bullet(bx, by, Math.cos(ba+i*0.15)*11, Math.sin(ba+i*0.15)*11, '#ff3300', true, 'NONE', false, 60); b.size=8; bullets.push(b);
                }
            });
        } else if (this.pattern === 1) {
            activeGuns.forEach((g, idx) => {
                let bx = this.x + g.relX; let by = this.y + g.relY;
                let ba = Math.atan2(player.y - by, player.x - bx);
                let b = new Bullet(bx, by, Math.cos(ba)*10, Math.sin(ba)*10, '#ff4400', true, 'NONE', true, 100, {isMissile:true}); b.size=11; bullets.push(b);
            });
        } else if (this.pattern === 2) {
            activeGuns.forEach(g => {
                for (let i=0; i<3; i++) {
                  let a = (i/3)*Math.PI*2 + frameCount*0.1; let b = new Bullet(this.x + g.relX, this.y + g.relY, Math.cos(a)*12, Math.sin(a)*12, '#00ffff', true, 'NONE', false, 50); b.size=8; bullets.push(b);
                }
            });
        } else if (this.pattern === 3) {
            activeGuns.forEach(g => {
              let ba = Math.atan2(player.y-(this.y+g.relY), player.x-(this.x+g.relX));
              let b = new Bullet(this.x + g.relX, this.y + g.relY, Math.cos(ba)*12, Math.sin(ba)*12, '#ff8800', true, 'NONE', false, 70); b.size=9; bullets.push(b);
            });
        }
    } else if (this.currentPhase === 2) {
        // Core phase - varied attack
        let corePart = this.parts.find(p => p.label === 'CORE');
        if (!corePart) return;
        
        let bx = this.x + corePart.relX; let by = this.y + corePart.relY;
        let ba = Math.atan2(player.y - by, player.x - bx);
        
        if (this.pattern === 0) {
            for(let i = -4; i <= 4; i++) { 
                let a = (i/9) * Math.PI * 2 + this.angleOffset;
                bullets.push(new Bullet(bx, by, Math.cos(a)*14, Math.sin(a)*14, '#ff00ff', true, 'NONE', false, 80));
            }
        } else if (this.pattern === 1) {
            for (let i = -3; i <= 3; i++) {
                let b = new Bullet(bx, by, Math.cos(ba)*12, Math.sin(ba)*12, '#ff0000', true, 'NONE', true, 130, {bigExplosion:true}); b.size=18; bullets.push(b);
            }
        } else if (this.pattern === 2) {
            for (let i = -2; i <= 2; i++) {
                let a = ba + (i / 2) * 0.4;
                bullets.push(new Bullet(bx, by, Math.cos(a)*13, Math.sin(a)*13, '#ffcc00', true, 'NONE', false, 90));
            }
        } else {
            for (let i = 0; i < 8; i++) {
                let a = (i/8) * Math.PI * 2;
                bullets.push(new Bullet(bx, by, Math.cos(a)*15, Math.sin(a)*15, '#ff2200', true, 'NONE', false, 75));
            }
        }
    }
  }
  
  draw() {
    ctx.save(); ctx.translate(this.x, this.y);
    
    if (this.isCrashing) {
        let crashScale = Math.max(0.01, 1 - (75 - this.crashTimer)/75);
        ctx.scale(crashScale, crashScale);
        ctx.rotate(Math.sin(this.crashTimer * 0.1) * 0.2);
    }

    ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000';
    ctx.fillStyle = '#220022'; ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      let a = (i / 5) * Math.PI * 2 + frameCount * 0.04;
      let x = Math.cos(a) * 110; let y = Math.sin(a) * 150;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 3; ctx.stroke();
    
    // Draw all parts with proper targeting indicators
    for (let part of this.parts) {
      ctx.save(); ctx.translate(part.relX, part.relY);
      
      if (part.isDead) {
          ctx.fillStyle = '#1a1a1a';
          if (frameCount % 8 === 0) spawnParticles(this.x + part.relX, this.y + part.relY, '#ff4400', 2);
      } else {
          const isCurrentTarget = (part.phase === this.currentPhase);
          ctx.fillStyle = part.isDead ? '#111' : (isCurrentTarget ? part.color : '#444455');
      }
      
      if (part.label === 'ENGINE') {
          ctx.beginPath(); ctx.arc(0, 0, part.radius, 0, Math.PI*2); ctx.fill();
      } else if (part.label === 'GUN') {
          ctx.fillRect(-part.radius*0.7, -part.radius*0.7, part.radius*1.4, part.radius*1.4);
          if (!part.isDead && part.phase === this.currentPhase) {
            const barrelAngle = Math.atan2(player.y-(this.y+part.relY), player.x-(this.x+part.relX));
            ctx.save(); ctx.rotate(barrelAngle);
            ctx.fillStyle = '#888'; ctx.fillRect(-4, -part.radius, 8, part.radius);
            ctx.restore();
          }
      } else if (part.label === 'CORE') {
          ctx.beginPath(); ctx.arc(0, 0, part.radius, 0, Math.PI*2); ctx.fill();
      }
      
      // VISUAL TARGET INDICATOR
      if (!part.isDead && part.phase === this.currentPhase) {
          ctx.save();
          let crossColor = '#ff00ff';
          ctx.strokeStyle = crossColor; 
          ctx.lineWidth = 4;
          ctx.shadowColor = crossColor;
          ctx.shadowBlur = 15;
          ctx.setLineDash([12, 12]);
          ctx.lineDashOffset = -frameCount * 1.5;
          ctx.beginPath();
          let glowRadius = part.radius + 15 + Math.sin(frameCount * 0.2) * 5;
          ctx.arc(0, 0, glowRadius, 0, Math.PI*2);
          ctx.stroke();
          
          ctx.setLineDash([]);
          ctx.lineWidth = 3;
          let crossLen = 16;
          ctx.beginPath();
          ctx.moveTo(0, -glowRadius - crossLen); ctx.lineTo(0, -glowRadius - 4);
          ctx.moveTo(0, glowRadius + 4); ctx.lineTo(0, glowRadius + crossLen);
          ctx.moveTo(-glowRadius - crossLen, 0); ctx.lineTo(-glowRadius - 4, 0);
          ctx.moveTo(glowRadius + 4, 0); ctx.lineTo(glowRadius + crossLen, 0);
          ctx.stroke();
          ctx.restore();
      }
      ctx.restore();
    }
    
    if(this.slowed) { ctx.fillStyle = 'rgba(0,100,255,0.15)'; ctx.beginPath(); ctx.arc(0,0,260,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
}

class Bullet {
  constructor(x, y, vx, vy, color, isEnemy, element = 'NONE', explosive = false, damage = 10, special = {}) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.color = color; this.isEnemy = isEnemy; this.element = element; this.explosive = explosive;
    this.marked = false; this.size = isEnemy ? (explosive && special && special.bigExplosion ? 18 : 7) : (explosive ? 6 : 4.5); this.life = 55; this.damage = damage;
    this.special = special; this.hitList = new Set();
  }
  update() {
    if (this.special && this.special.homing && !this.isEnemy) {
        let nearest = null; let minDist = 400;
        enemies.forEach(e => { let d = Math.hypot(this.x - e.x, this.y - e.y); if (d < minDist && !e.isCrashing) { minDist = d; nearest = e; } });
        if (nearest) {
            let tA = Math.atan2(nearest.y - this.y, nearest.x - this.x);
            let cA = Math.atan2(this.vy, this.vx);
            let diff = tA - cA;
            while (diff > Math.PI) diff -= Math.PI * 2; while (diff < -Math.PI) diff += Math.PI * 2;
            cA += diff * 0.30; 
            let spd = Math.hypot(this.vx, this.vy);
            this.vx = Math.cos(cA) * spd; this.vy = Math.sin(cA) * spd;
        }
    }

    this.x += this.vx; this.y += this.vy; if (!this.isEnemy) this.life--;
    
    if (this.special && this.special.isMissile && frameCount % 4 === 0) {
        spawnParticles(this.x, this.y - 10, '#aaaaaa', 2); spawnParticles(this.x, this.y - 12, '#ff4400', 1);
    }

    if (this.x < -60 || this.x > width+60 || this.y < -60 || this.y > height+60 || (!this.isEnemy && this.life <= 0)) {
      if (this.explosive && !this.isEnemy) {
        spawnParticles(this.x, this.y, this.color, 48);
        enemies.forEach(other => { 
            if (other.isCrashing) return;
            if (other.isBoss) {
                for (let part of other.parts) {
                    if (!part.isDead && Math.hypot(this.x - (other.x + part.relX), this.y - (other.y + part.relY)) < 115) {
                        part.hp -= this.damage * 1.7;
                        if (part.hp <= 0) { part.isDead = true; part.hp = 0; spawnParticles(other.x + part.relX, other.y + part.relY, '#ffaa00', 80); }
                    }
                }
            } else {
                if (Math.hypot(this.x - other.x, this.y - other.y) < 115) { 
                    other.hp -= this.damage * 1.7; if (other.hp <= 0) killEnemy(other); 
                } 
            }
        });
      }
      this.marked = true;
    }
  }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.shadowBlur = 11; ctx.shadowColor = this.color;
    if (!this.isEnemy && !this.explosive) {
        ctx.rotate(Math.atan2(this.vy, this.vx) + Math.PI/2);
    } else if (this.special && this.special.isMissile) {
        ctx.rotate(Math.atan2(this.vy, this.vx) + Math.PI/2);
    }

    if (this.special && this.special.isSlug) {
        ctx.fillStyle = '#ffeedd'; ctx.fillRect(-4, -18, 8, 36); ctx.shadowBlur = 15; ctx.shadowColor = '#ffffaa';
    } else if (this.special && this.special.isMissile) {
        ctx.fillStyle = '#ff8800'; ctx.beginPath(); ctx.moveTo(0, 8); ctx.lineTo(4, 0); ctx.lineTo(4, -12); ctx.lineTo(-4, -12); ctx.lineTo(-4, 0); ctx.fill();
        ctx.fillStyle = '#ff2200'; ctx.fillRect(-2, -16, 4, 4);
    } else if (this.isEnemy) { 
        if (this.explosive && this.special && this.special.bigExplosion) {
            ctx.shadowBlur = 20; ctx.shadowColor = '#ff6600';
            ctx.fillStyle = '#ff3300'; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, 0, this.size*0.6, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fill(); 
        }
    } else { 
        if(this.explosive) { ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0,0,this.size*1.5, 0, Math.PI*2); ctx.fill(); } 
        ctx.fillStyle = this.color; ctx.fillRect(-2.5, -13, 5, 26); 
    }
    ctx.restore();
  }
}

class EnemyDescent {
  constructor(x, y, isBoss = false, isPlayer = false) {
    this.x = x; this.y = y; this.isBoss = isBoss; this.isPlayer = isPlayer;
    this.vy = 3.0 + Math.random() * 1.6; this.vx = (Math.random() - 0.5) * 0.6; 
    this.life = 1.0; this.marked = false; this.flameTimer = 0;
  }
  update() {
    this.x += this.vx; this.y += this.vy; this.life -= 0.024; this.flameTimer++;
    if (this.flameTimer >= 1) {
      const flameColors = ['#ff6600', '#ffaa00', '#ff4400', '#ffdd00'];
      const color = flameColors[Math.floor(Math.random() * flameColors.length)];
      spawnParticles(this.x, this.y, color, 3 + Math.floor(Math.random() * 2));
      this.flameTimer = 0;
    }
    if (this.life <= 0 || this.y > height + 100) this.marked = true;
  }
  draw() {
    if (this.life <= 0) return;
    ctx.save(); ctx.globalAlpha = this.life * 0.8;
    const flameColors = ['#ff4400', '#ff8800', '#ffaa00', '#ffdd00'];
    for (let i = 0; i < flameColors.length; i++) {
      const radius = 12 - i * 3;
      if (radius <= 0) continue;
      ctx.fillStyle = flameColors[i]; ctx.beginPath(); ctx.arc(this.x, this.y, radius, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1.0; ctx.restore();
  }
}

class Wreck {
  constructor(x, y, type = 'normal', rotation = 0) {
    this.x = x; this.y = y; this.type = type; this.rotation = rotation;
    this.vy = 1.0 + Math.random() * 3.0; this.vx = (Math.random() - 0.5) * 6;
    this.angularVel = (Math.random() - 0.5) * 0.2; this.life = 1.0; this.marked = false; this.smokeTimer = 0;
  }
  update() {
    this.x += this.vx; this.y += this.vy; this.rotation += this.angularVel; this.life -= 0.016; this.smokeTimer++;
    if (this.smokeTimer >= 2) {
      spawnParticles(this.x, this.y, this.type === 'boss' ? '#ff4400' : '#888888', 1); spawnParticles(this.x, this.y, '#444444', 1);
      this.smokeTimer = 0;
    }
    if (this.life <= 0) this.marked = true;
  }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.globalAlpha = this.life;
    if (this.type === 'tank') {
      ctx.fillStyle = '#333'; ctx.beginPath(); ctx.moveTo(-14, 12); ctx.lineTo(14, 12); ctx.lineTo(22, -8); ctx.lineTo(0, -26); ctx.lineTo(-22, -8); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#ff4400'; ctx.fillRect(-8, 5, 16, 8);
    } else if (this.type === 'boss') {
      ctx.fillStyle = '#1a1a1a'; ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ff4400'; ctx.beginPath(); ctx.arc(Math.random() * 20 - 10, Math.random() * 20 - 10, 15, 0, Math.PI * 2); ctx.fill();
    } else {
      ctx.fillStyle = '#444'; ctx.fillRect(-8, -12, 16, 24); ctx.fillStyle = '#ff6600'; ctx.fillRect(-6, -8, 12, 4);
    }
    ctx.globalAlpha = 1.0; ctx.restore();
  }
}

class PlayerEscort {
  constructor(side) {
    this.side = side;
    this.x = player.x + side * 80;
    this.y = player.y;
    this.fireTimer = 0;
    this.life = 600; 
    this.marked = false;
  }
  update() {
    this.x = player.x + this.side * 80;
    this.y = player.y - 10;
    this.life--;
    if (this.life <= 0) { this.marked = true; return; }
    this.fireTimer++;
    if (this.fireTimer >= 10) { 
      this.fireTimer = 0;
      let target = null; let minDist = 1200;
      enemies.forEach(e => { if(e.isCrashing)return; let d = Math.hypot(this.x-e.x, this.y-e.y); if(d<minDist){minDist=d;target=e;} });
      if (target) {
        let angle = Math.atan2(target.y - this.y, target.x - this.x);
        bullets.push(new Bullet(this.x, this.y-20, Math.cos(angle)*32, Math.sin(angle)*32, '#00ffcc', false, 'NONE', false, 40));
        playRealisticGun('support');
      } else {
        bullets.push(new Bullet(this.x, this.y-20, 0, -32, '#00ffcc', false, 'NONE', false, 40));
      }
    }
  }
  draw() {
    let alpha = this.life < 60 ? this.life / 60 : 1;
    ctx.save(); ctx.globalAlpha = alpha; ctx.translate(this.x, this.y); ctx.scale(1.4, 1.4);
    ctx.shadowBlur = 12; ctx.shadowColor = '#00ffcc';
    ctx.fillStyle = '#113355';
    ctx.beginPath(); ctx.moveTo(0, -18); ctx.lineTo(-12, 8); ctx.lineTo(12, 8); ctx.fill();
    ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 1.5; ctx.stroke();
    ctx.fillStyle = '#00ffff'; ctx.fillRect(-2, -10, 4, 10);
    ctx.globalAlpha = 1; ctx.restore();
  }
}

let escortShips = [];

function spawnEscortShips() {
  escortShips = [];
  escortShips.push(new PlayerEscort(-1)); 
  escortShips.push(new PlayerEscort(1));  
  showNotification("ESCORT SHIPS DEPLOYED!");
}

class Drop {
  constructor(x, y, type) { this.x = x; this.y = y; this.vy = 4.4; this.type = type; this.marked = false; }
  update() { this.y += this.vy; if(this.y > height) this.marked = true; }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.shadowBlur = 16;
    if (this.type === 'HEAL') { 
        ctx.fillStyle = '#00ff00'; ctx.shadowColor = '#00ff00'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.fillText('+', 0, 8); ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.stroke(); 
    } 
    else if (this.type === 'CARD') { 
        ctx.fillStyle = '#ff44aa'; ctx.shadowColor = '#ff44aa'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 18px Arial'; ctx.textAlign = 'center'; ctx.fillText('‚òÖ', 0, 7); 
    } 
    else if (this.type === 'SUPPORT') { 
        ctx.fillStyle = '#00d4ff'; ctx.shadowColor = '#00d4ff'; ctx.beginPath(); ctx.moveTo(0, -13); ctx.lineTo(9, 7); ctx.lineTo(0, 3); ctx.lineTo(-9, 7); ctx.fill(); 
    }
    else if (this.type === 'MEDAL') { 
        ctx.fillStyle = '#ffaa00'; ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.fillText('‚òÖ', 0, 4);
    }
    else if (this.type === 'SCORE_COIN') { 
        ctx.fillStyle = '#0088ff'; ctx.shadowColor = '#00d4ff'; ctx.shadowBlur = 15;
        ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#c0c0c0'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText('$', 0, 5);
    }
    else if (this.type === 'ESCORT') { 
        ctx.fillStyle = '#00ffcc'; ctx.shadowColor = '#00ffcc'; ctx.shadowBlur = 14;
        ctx.beginPath(); ctx.moveTo(-8,-12); ctx.lineTo(8,-12); ctx.lineTo(12,8); ctx.lineTo(-12,8); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.fillText('ESC', 0, 3);
    }
    else if (this.type === 'UPGRADE') {
        ctx.fillStyle = '#ffd700'; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 16;
        ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText('‚ñ≤', 0, 5);
    }
    ctx.restore();
  }
}

class Particle {
  constructor(x, y, color) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 18; this.vy = (Math.random() - 0.5) * 18; this.life = 1.0; this.color = color; this.size = 1.6 + Math.random() * 2.4; }
  update() { this.x += this.vx; this.y += this.vy; this.life -= 0.09; }
  draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
}

class GalaxyBackground {
  constructor() { this.layers = []; this.initLayers(); }
  initLayers() {
    this.layers = []; 
    this.layers.push({ speed: 0.2, stars: [], color: () => `rgba(${200 + Math.random() * 55}, ${200 + Math.random() * 55}, ${255}, ${0.3 + Math.random() * 0.4})`, size: () => 0.5 + Math.random() * 1.5, count: 300 });
    this.layers.push({ speed: 0.6, clouds: [], color: () => ['rgba(100, 50, 200, 0.15)', 'rgba(150, 50, 255, 0.15)', 'rgba(200, 100, 255, 0.15)', 'rgba(50, 100, 255, 0.15)'][Math.floor(Math.random()*4)], size: () => 30 + Math.random() * 70, count: 15 });
    this.layers.push({ speed: 1.0, stars: [], color: () => `rgba(${255}, ${200 + Math.random() * 55}, ${100 + Math.random() * 155}, ${0.5 + Math.random() * 0.3})`, size: () => 1 + Math.random() * 2, count: 200 });
    
    this.layers.push({ 
        speed: 1.4, objects: [], 
        createObject: () => { 
            const rand = Math.random();
            if (rand < 0.2) return { type: 'earth', size: 60 + Math.random()*40, color: '#2266cc' };
            if (rand < 0.4) return { type: 'sun', size: 100 + Math.random()*50, color: '#ffaa00' };
            if (rand < 0.6) return { type: 'station', size: 40 + Math.random()*30, color: '#888888' };
            if (rand < 0.8) return { type: 'planet', size: 80 + Math.random()*40, color: `hsl(${Math.random() * 360}, 60%, 40%)` };
            return { type: 'galaxy', size: 50 + Math.random() * 50, color: `rgba(${100 + Math.random() * 155}, ${50 + Math.random() * 100}, ${200 + Math.random() * 55}, 0.6)` };
        }, 
        count: 8 
    });
    this.layers.push({ speed: 2.0, stars: [], color: () => `rgba(255, 255, 255, ${0.7 + Math.random() * 0.3})`, size: () => 2 + Math.random() * 3, count: 100 });
    for (let layer of this.layers) {
      if (layer.stars) for (let i = 0; i < layer.count; i++) layer.stars.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, size: layer.size(), color: layer.color() });
      if (layer.clouds) for (let i = 0; i < layer.count; i++) layer.clouds.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, size: layer.size(), color: layer.color() });
      if (layer.objects) for (let i = 0; i < layer.count; i++) { const obj = layer.createObject(); layer.objects.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, ...obj }); }
    }
  }
  update() {
    for (let layer of this.layers) {
      const speed = layer.speed;
      if (layer.stars) for (let star of layer.stars) { star.y += speed * 0.5; if (star.y > height + 50) { star.y = -50; star.x = Math.random() * width; } }
      if (layer.clouds) for (let cloud of layer.clouds) { cloud.y += speed * 0.5; if (cloud.y > height + 100) { cloud.y = -100; cloud.x = Math.random() * width; } }
      if (layer.objects) for (let obj of layer.objects) { 
          obj.y += speed * 0.5; 
          if (obj.y > height + 150) { 
              obj.y = -150; obj.x = Math.random() * width; 
              const newObj = this.layers[3].createObject(); 
              obj.type = newObj.type; obj.size = newObj.size; obj.color = newObj.color; 
          } 
      }
    }
  }
  draw() {
    for (let layer of this.layers) {
      if (layer.stars) for (let star of layer.stars) { ctx.fillStyle = star.color; ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill(); }
      if (layer.clouds) for (let cloud of layer.clouds) { ctx.fillStyle = cloud.color; ctx.beginPath(); ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2); ctx.fill(); }
      if (layer.objects) for (let obj of layer.objects) {
        if (obj.type === 'earth') {
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, '#3399ff'); gradient.addColorStop(1, '#002200'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(obj.x-10, obj.y-10, obj.size*0.4, 0, Math.PI * 2); ctx.fill();
        } else if (obj.type === 'sun') {
            ctx.shadowBlur = 50; ctx.shadowColor = '#ff5500';
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(0.2, '#ffdd00'); gradient.addColorStop(1, '#ff3300'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        } else if (obj.type === 'station') {
            ctx.fillStyle = '#666'; ctx.fillRect(obj.x - obj.size, obj.y - obj.size/4, obj.size*2, obj.size/2);
            ctx.fillStyle = '#444'; ctx.fillRect(obj.x - obj.size/4, obj.y - obj.size, obj.size/2, obj.size*2);
            ctx.fillStyle = '#00ffff'; ctx.fillRect(obj.x - 5, obj.y - 5, 10, 10);
        } else if (obj.type === 'planet') { 
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, obj.color); gradient.addColorStop(1, 'rgba(0,0,0,0.7)'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill(); 
        } else { 
            ctx.fillStyle = obj.color; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill(); 
        }
      }
    }
  }
}

let player, bullets = [], enemies = [], drops = [], particles = [], allies = [], wrecks = [];
let mouse = { x: 0, y: 0 }; let galaxyBackground;

function selectElement(element) {
  currentElement = element;
  document.getElementById('element-selection').style.display = 'none';
  document.getElementById('weapon-selection').style.display = 'flex';
}

function selectWeapon(weaponId) {
  currentWeapon = weaponId;
  currentWeaponTier = 0;
  document.getElementById('weapon-selection').style.display = 'none';
  initGame();
}

function initGame() {
  const allAudio = document.querySelectorAll('audio');
  allAudio.forEach(audio => { audio.pause(); audio.currentTime = 0; });
  
  resize(); 
  player = new Player(); 
  player.element = currentElement;
  player.weaponType = currentWeapon;
  drawDamageModel(player.parts); 
  
  bullets = []; enemies = []; drops = []; particles = []; allies = []; wrecks = []; escortShips = [];
  score = 0; xp = 0; xpNeeded = 1000; wave = 1; waveTimer = 0; currentLevel = 1; bossActive = false; elementPower = 0; 
  pendingSupportPasses = 0; supportPassTimer = 0; bossSupportsUsed = 0; supportSpawnDelay = 0; globalFormationIdCounter = 0;
  superPowerMeter = 0; superPowerReady = false; aceSpawnedThisWave = false;
  equippedCards = [null, null, null];
  inIntermission = false; intermissionTimer = 0;
  
  gameRunning = true; 
  galaxyBackground = new GalaxyBackground(); 
  startBGM('normal'); 
  updateCardsDisplay(); updateElementBar(); updateUI(); updateSuperPowerUI();
  requestAnimationFrame(animate);
}

function spawnDiagonalKette() {
    globalFormationIdCounter++;
    const dir = Math.random() > 0.5 ? 1 : -1; 
    const cx = Math.random() * (width - 300) + 150;
    const spacing = 90; 
    for (let i = 0; i < 3; i++) {
        let e = new Enemy(wave, 'diagonal-kette', cx + dir * i * spacing * 0.6, -150 - i * spacing * 0.8);
        e.speed = 3.6 + Math.random() * 0.8;
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    }
}

function spawnBox() {
    globalFormationIdCounter++;
    const cx = Math.random() * (width - 250) + 125;
    const offsets = [[-70,-60],[70,-60],[-70,60],[70,60]];
    offsets.forEach(([ox, oy]) => {
        let e = new Enemy(wave, 'box', cx + ox, oy - 150);
        e.speed = 3.4 + Math.random() * 0.6;
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    });
}

function spawnColumnSweep() {
    globalFormationIdCounter++;
    const cx = Math.random() * (width - 200) + 100;
    for (let i = 0; i < 4; i++) {
        let e = new Enemy(wave, 'column-sweep', cx, -150 - i * 100);
        e.vy = 0; 
        e.rotation = Math.PI;
        e.speed = 3.8 + Math.random() * 0.6;
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    }
}

function spawnFighterWing() {
    globalFormationIdCounter++;
    const side = Math.random() > 0.5 ? 1 : -1;
    const startX = side === 1 ? -150 : width + 150;
    const startY = Math.random() * (height * 0.4);
    for (let i = 0; i < 4; i++) {
        let e = new Enemy(wave, 'fighter-wing', startX - side * i * 60, startY - i * 40);
        e.side = side;
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    }
}

function spawnLogic() {
  if (bossActive || inIntermission || waveTimer >= FRAMES_PER_WAVE) return;

  let isReturningActive = enemies.some(e => e.returning);
  if (isReturningActive) return;

  let activeFormations = new Set();
  enemies.forEach(e => { if (e.formationId && !e.isCrashing) activeFormations.add(e.formationId); });
  
  const maxFormations = wave >= 7 ? 2 : 1;
  
  if (activeFormations.size < maxFormations || (activeFormations.size < maxFormations && Math.random() < 0.02)) {
    const formType = Math.random();
    if (formType < 0.25) spawnDiagonalKette();
    else if (formType < 0.50) spawnBox();
    else if (formType < 0.75) spawnColumnSweep();
    else spawnFighterWing();
  }

  // Mini-boss Bomber spawn
  if (wave >= 2 && Math.random() < 0.003) {
      let bomberCount = enemies.filter(e => e.subType === 'bomber').length;
      if (bomberCount === 0) enemies.push(new Enemy(wave, 'bomber'));
  }

  // Ace Pilot spawnt exact 1 keer op waveTimer === 450 per 3e wave
  if (wave % 3 === 0 && !aceSpawnedThisWave && waveTimer === 450) {
      enemies.push(new Enemy(wave, 'ace_pilot'));
      aceSpawnedThisWave = true;
  }
}

function checkCollisions() {
  for(let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    if (b.marked) continue;
    
    if (!b.isEnemy) {
      for(let j = enemies.length - 1; j >= 0; j--) {
        let e = enemies[j];
        if (e.isCrashing) continue; 
        if (!e.isBoss && b.hitList && b.hitList.has(e)) continue;

        let hitBox = e.isBoss ? (e.isSecret ? 100 : 68) : e.size;
        
        let finalDamage = b.damage;
        if (e.isBoss && b.special && b.special.bossHunter) finalDamage *= 2.0;
        
        if (e.isBoss) {
            let hitEngine = false;
            for (let part of e.parts) {
                if (b.hitList && b.hitList.has(part)) continue;
                if (part.isDead || part.phase !== e.currentPhase) continue;
                if (Math.hypot(b.x - (e.x + part.relX), b.y - (e.y + part.relY)) < part.radius + 12) {
                    hitEngine = true;
                    part.hp -= finalDamage;
                    if (e.currentPhase === 99) e.hp -= finalDamage; 
                    playAudioFile(audioFiles.explosion);
                    if (part.hp <= 0) {
                        part.isDead = true; part.hp = 0;
                        playAudioFile(audioFiles.bossExplosion);
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#ff4400', 120);
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#000000', 60);
                        cameraShake = 18;
                        if (e.checkCurrentPhase) e.checkCurrentPhase();
                    } else {
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#ffffff', 8);
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#00ffff', 12);
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#ffaa00', 15);
                    }
                    if (b.hitList) b.hitList.add(part);
                    break; 
                }
            }
            if (!hitEngine) continue; 
        } else {
            if (Math.hypot(b.x - e.x, b.y - e.y) >= hitBox + 12) continue;
            e.hp -= finalDamage; 
            spawnParticles(b.x, b.y, '#ffaa00', 6);
            if (b.hitList) b.hitList.add(e);
        }
          
        if (player.element === 'FIRE' || player.effects.burn || b.special.incendiary) e.burnTimer = 50;
        if ((player.element === 'WATER' || player.effects.slow) && !e.isBoss) { e.slowed = true; setTimeout(() => e.slowed = false, 2300); }
        if ((player.element === 'EARTH' && Math.random() < 0.15) || player.effects.stun) { e.stunned = true; e.stunTimer = 34; }
        
        if (player.effects.chain) {
           let nearest = null; let minDist = 200;
           enemies.forEach(other => { if(other !== e && !other.isBoss && !other.isCrashing) { let d = Math.hypot(e.x - other.x, e.y - other.y); if(d < minDist) { minDist = d; nearest = other; } } });
           if (nearest) { nearest.hp -= b.damage * 0.8; spawnParticles((e.x + nearest.x)/2, (e.y + nearest.y)/2, '#00ffff', 5); if(nearest.hp <= 0) killEnemy(nearest); }
        }
        if (player.effects.pushback && !e.isBoss) { e.y -= 30; }

        if (b.explosive || (b.special && b.special.plasmaArea) || (b.special && b.special.bigExplosion)) {
            let radius = (b.special && b.special.bigExplosion) ? 220 : 115;
            let dmgMult = (b.special && b.special.bigExplosion) ? 2.5 : 1.7;
            spawnParticles(b.x, b.y, b.color, (b.special && b.special.bigExplosion) ? 80 : 48);
            
            enemies.forEach(other => {
                if(other.isCrashing) return;
                if (other.isBoss) {
                    for (let part of other.parts) {
                        if (!part.isDead && part.phase === other.currentPhase) {
                            if (Math.hypot(b.x - (other.x + part.relX), b.y - (other.y + part.relY)) < radius) {
                                part.hp -= finalDamage * dmgMult;
                                if (other.currentPhase === 99) other.hp -= finalDamage * dmgMult;
                                playAudioFile(audioFiles.explosion);
                                if (part.hp <= 0) { 
                                    part.isDead = true; part.hp = 0; 
                                    playAudioFile(audioFiles.bossExplosion);
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#ffaa00', 150);
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#000000', 80);
                                    if (other.checkCurrentPhase) other.checkCurrentPhase();
                                } else {
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#ffffff', 10);
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#00ffff', 15);
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#ffaa00', 20);
                                }
                            }
                        }
                    }
                } else {
                    if (Math.hypot(b.x - other.x, b.y - other.y) < radius) {
                        other.hp -= finalDamage * dmgMult;
                        if (other.hp <= 0) killEnemy(other);
                    }
                }
            });
        }

        if (b.special && b.special.splinter && !b.special.isSplinterPiece) {
            for(let k=0; k<5; k++) {
                let ang = Math.random() * Math.PI * 2;
                let sb = new Bullet(b.x, b.y, Math.cos(ang)*16, Math.sin(ang)*16, '#ffaa00', false, 'NONE', false, b.damage * 0.4, {isSplinterPiece: true});
                bullets.push(sb);
            }
        }

        if (!player.effects.pierce || (b.special && b.special.isSplinterPiece)) { b.marked = true; }
        
        if (e.hp <= 0 && !e.isBoss) killEnemy(e);
      }
    } else {
      if (player.effects.invincible || player.isCrashing) { b.marked = true; continue; }
      
      let damage = b.damage; 
      if (player.effects.elementArmor || player.effects.armor) damage *= (0.85 / player.defenseMultiplier); 
      if (player.effects.shield) damage *= 0.80;
      
      let hitRadius = 46;
      if (b.explosive && b.special && b.special.bigExplosion) hitRadius = 85;

      if (Math.hypot(b.x - player.x, b.y - player.y) < hitRadius) {
        player.takeDamage(damage, b.x - player.x, b.y - player.y); b.marked = true;
        if (b.explosive) {
            spawnParticles(b.x, b.y, '#ff4400', 60);
            spawnParticles(b.x, b.y, '#ffff00', 40);
            cameraShake = 15;
        } else {
            spawnParticles(player.x, player.y, '#ff6600', 20); 
        }
      }
    }
  }
  
  enemies.forEach(e => {
    if (e.isCrashing) return;
    if (e.isBoss) {
        if (e.currentPhase !== undefined && e.currentPhase !== 99 && e.currentPhase > 2) { killEnemy(e); }
        else if (e.currentPhase === 99 && e.hp <= 0) { killEnemy(e); } 
    } else {
        if (player.effects.invincible || player.isCrashing) return; 
        
        let crashHitRadius = e.subType === 'boss_missile' ? e.size + 42 : e.size + 42;
        if (!e.isBoss && Math.hypot(e.x - player.x, e.y - player.y) < crashHitRadius) {
            let dmg = e.subType === 'bomber' ? 100 : (e.subType === 'boss_missile' ? 150 : (e.subType === 'tank' ? 70 : 25));
            player.takeDamage(dmg, e.x - player.x, e.y - player.y); 
            e.hp = 0; spawnParticles(player.x, player.y, '#ff0000', 25); killEnemy(e);
        }
    }
  });

  drops.forEach(d => { if (!d.marked && Math.hypot(d.x - player.x, d.y - player.y) < 64) { d.marked = true; collectDrop(d.type); } });
}

function startIntermission(isBoss) {
    inIntermission = true;
    intermissionTimer = 0;
    intermissionIsBoss = isBoss;
    if (isBoss && bgmAudio) {
        bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null;
    }
}

function killEnemy(e) {
  if (e.isCrashing) return;
  e.isCrashing = true;
  e.crashTimer = e.isBoss ? 75 : 22;
  playAudioFile(audioFiles.explosion); 
}

function finalizeKillEnemy(e) {
  score += e.isBoss ? 5000 : (e.subType === 'bomber' ? 500 : 150); 

  if (e.isBoss) {
    playAudioFile(audioFiles.bossExplosion);
    spawnParticles(e.x, e.y, '#ff4400', 100);
    spawnParticles(e.x, e.y, '#000000', 50);
    for (let i = 0; i < 4; i++) wrecks.push(new EnemyDescent(e.x + (Math.random() - 0.5) * 80, e.y, true, false));
    
    for (let i = 0; i < 25; i++) drops.push(new Drop(e.x + (Math.random()-0.5)*150, e.y + (Math.random()-0.5)*150, 'SCORE_COIN'));
    
    enemies = enemies.filter(en => en !== e);
    bossActive = false;
    if (e.isSecret) {
        wave = 11; setTimeout(() => { victoryScreen(); }, 1500);
    } else {
        wave++; startBGM('normal'); startIntermission(false);
    }
  } else {
    playAudioFile(audioFiles.explosion);
    spawnParticles(e.x, e.y, '#ff8844', 15);
    spawnParticles(e.x, e.y, '#ff4400', 8);
    wrecks.push(new EnemyDescent(e.x, e.y, false, false));
    enemies = enemies.filter(en => en !== e);
    
    if (Math.random() < (e.subType === 'bomber' ? 0.8 : 0.10)) { drops.push(new Drop(e.x, e.y, 'MEDAL')); }
    if (e.subType === 'bomber' || Math.random() < 0.006) { drops.push(new Drop(e.x, e.y, 'ESCORT')); }
    if (Math.random() < 0.006) { drops.push(new Drop(e.x, e.y, 'HEAL')); }
    if (Math.random() < 0.02) { drops.push(new Drop(e.x, e.y, 'UPGRADE')); }
    
    if (!superPowerReady) {
      superPowerMeter += e.subType === 'bomber' ? 5 : 1;
      if (superPowerMeter >= getSuperPowerNeeded()) {
        superPowerMeter = getSuperPowerNeeded();
        superPowerReady = true;
      }
      updateSuperPowerUI();
    }
  }
  updateUI();
}

function updateSuperPowerUI() {
  const fill = document.getElementById('super-power-fill');
  const text = document.getElementById('super-power-text');
  const btn = document.getElementById('super-activate-btn');
  if (!fill) return;
  fill.style.width = (superPowerMeter / getSuperPowerNeeded() * 100) + '%';
  if (superPowerReady) {
    text.textContent = 'READY!';
    text.style.color = '#ffcc00';
    btn.style.display = 'block';
  } else {
    text.textContent = superPowerMeter + ' / ' + getSuperPowerNeeded() + ' KILLS';
    text.style.color = '#aaa';
    btn.style.display = 'none';
  }
}

function activateSquadron() {
  if (!superPowerReady) return;
  superPowerReady = false;
  superPowerMeter = 0;
  updateSuperPowerUI();
  showNotification("SQUADRON INBOUND!");
  setTimeout(() => { if (gameRunning) playAudioFile(audioFiles.support); }, 1);
  supportSpawnDelay = 120; 
}

function updateSupportWaves() {
  if (supportSpawnDelay > 0) {
      supportSpawnDelay--;
      if (supportSpawnDelay === 0) {
          pendingSupportPasses = 1;
      }
      return;
  }

  if (pendingSupportPasses > 0 && allies.length === 0) {
    playEngineFlyby(); 
    const formations = [
        { x: width * 0.1, yBase: height + 280 },
        { x: width * 0.28, yBase: height + 180 },
        { x: width * 0.5,  yBase: height + 100 }, 
        { x: width * 0.72, yBase: height + 180 },
        { x: width * 0.9, yBase: height + 280 }, 
    ];
    formations.forEach((pos, i) => {
        allies.push(new SupportShip(pos.x, pos.yBase, 0, -40, 0, i * 4));
    });
    pendingSupportPasses--;
  }
}

function collectDrop(type) {
  if (type === 'HEAL') {
    Object.keys(player.parts).forEach(k => { player.parts[k].hp = Math.min(player.parts[k].max, player.parts[k].hp + player.parts[k].max * 0.52); });
    drawDamageModel(player.parts); showNotification("SYSTEMS REPAIRED");
  } else if (type === 'ESCORT') { 
    spawnEscortShips();
  } else if (type === 'UPGRADE') {
    if (currentWeaponTier < 6) {
        currentWeaponTier++; playUpgradeSound(); showNotification("WEAPON TIER " + currentWeaponTier + " UNLOCKED!");
    } else {
        score += 2500; showNotification("MAX TIER! +2500 SCORE");
    }
  } else if (type === 'SCORE_COIN') {
    score += 500; playUpgradeSound();
  } else if (type === 'MEDAL') {
    xp += 150; score += 50; playUpgradeSound();
    if (xp >= xpNeeded) {
        xp -= xpNeeded; xpNeeded = Math.floor(xpNeeded * 1.5);
        currentLevel++; playUpgradeSound();
        showNotification("LEVEL UP!");
        setTimeout(() => {
            if (currentElement === 'NONE') { currentElement = ['FIRE', 'WATER', 'EARTH', 'AIR'][Math.floor(Math.random()*4)]; player.element = currentElement; }
            const elementCards = ELEMENT_CARDS[currentElement];
            const card = {...elementCards[Math.floor(Math.random() * elementCards.length)], rarity: RARITIES[Math.min(4, Math.floor(Math.random() * 5 + wave * 0.22))]};
            showCardPickup(card);
        }, 500);
    }
  } else if (type === 'CARD') {
    if (currentElement === 'NONE') { currentElement = ['FIRE', 'WATER', 'EARTH', 'AIR'][Math.floor(Math.random()*4)]; player.element = currentElement; }
    const elementCards = ELEMENT_CARDS[currentElement];
    const card = {...elementCards[Math.floor(Math.random() * elementCards.length)], rarity: RARITIES[Math.min(4, Math.floor(Math.random() * 5 + wave * 0.22))]};
    showCardPickup(card);
  }
  updateUI();
}

function showCardPickup(card) {
  isPaused = true; pendingCard = card; playUpgradeSound();
  document.getElementById('card-name').textContent = card.name; document.getElementById('card-desc').textContent = card.desc;
  document.getElementById('card-rarity').textContent = card.rarity.toUpperCase(); document.getElementById('card-rarity').style.backgroundColor = RARITY_COLORS[card.rarity];
  document.querySelector('.card-preview-icon').textContent = currentElement === 'FIRE' ? 'üî•' : currentElement === 'WATER' ? 'üíß' : currentElement === 'EARTH' ? 'üåç' : 'üå™Ô∏è';
  document.getElementById('card-pickup').style.display = 'flex';
}

function acceptCard() {
  if (pendingCard.effect === 'burn') player.effects.burn = true; if (pendingCard.effect === 'explosive') player.effects.explosive = true;
  if (pendingCard.effect === 'revive') { for(let k in player.parts) { if(player.parts[k].hp <= 0) { player.parts[k].hp = player.parts[k].max; drawDamageModel(player.parts); break; } } }
  if (pendingCard.effect === 'shield') player.effects.shield = true; if (pendingCard.effect === 'slow') player.effects.slow = true;
  if (pendingCard.effect === 'stun') player.effects.stun = true; if (pendingCard.effect === 'armor') player.effects.armor = true;
  if (pendingCard.effect === 'regen') player.effects.regen = true; if (pendingCard.effect === 'speed') player.effects.speed = 0.12;
  if (pendingCard.effect === 'dodge') player.effects.dodge = true; if (pendingCard.effect === 'supernova') player.effects.supernova = true;
  if (pendingCard.effect === 'chain') player.effects.chain = true; if (pendingCard.effect === 'pushback') player.effects.pushback = true;
  
  let rMult = pendingCard.rarity === 'mythic' ? 1.5 : (pendingCard.rarity === 'legendary' ? 1.4 : (pendingCard.rarity === 'epic' ? 1.3 : (pendingCard.rarity === 'rare' ? 1.2 : 1.1)));
  if (currentElement === 'FIRE') player.damageMultiplier *= rMult;
  if (currentElement === 'WATER') player.fireRateMultiplier *= rMult;
  if (currentElement === 'AIR') player.speedMultiplier *= rMult;
  if (currentElement === 'EARTH') player.defenseMultiplier *= rMult;

  let added = false;
  for (let i = 0; i < 3; i++) { if (!equippedCards[i]) { equippedCards[i] = pendingCard; added = true; break; } }
  if (!added) {
    let worst = 0; for (let i = 1; i < 3; i++) { if (RARITIES.indexOf(equippedCards[i].rarity) < RARITIES.indexOf(equippedCards[worst].rarity)) worst = i; }
    if (RARITIES.indexOf(pendingCard.rarity) >= RARITIES.indexOf(equippedCards[worst].rarity)) equippedCards[worst] = pendingCard;
  }
  updateCardsDisplay(); document.getElementById('card-pickup').style.display = 'none'; isPaused = false; pendingCard = null;
}

function updateCardsDisplay() {
  const slots = document.querySelectorAll('.card-slot');
  slots.forEach((slot, i) => {
    slot.className = 'card-slot';
    if (equippedCards[i]) { const c = equippedCards[i]; slot.innerHTML = `<div style="font-size:26px;margin-bottom:4px;">${{common:'‚ô¶', rare:'‚ô£', epic:'‚ô†', legendary:'‚ô•', mythic:'‚òÖ'}[c.rarity] || '?'}</div><div>${c.name}</div><div style="font-size:10px;color:${RARITY_COLORS[c.rarity]}">${c.rarity}</div>`; slot.classList.add(`card-rarity-${c.rarity}`); } 
    else { slot.innerHTML = 'EMPTY'; slot.classList.add('empty'); }
  });
}

function updateElementBar() {
  document.getElementById('element-bar-fill').style.width = (elementPower / maxElementPower * 100) + '%';
  document.getElementById('element-text').textContent = currentElement !== 'NONE' ? `${ELEMENT_NAMES[currentElement]} POWER: ${Math.floor(elementPower)}` : "ELEMENT POWER";
}

function spawnParticles(x, y, color, count) { for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color)); }

function showNotification(text) {
  const el = document.getElementById('notification'); el.innerText = text; el.style.opacity = 1;
  document.getElementById('notification').style.color = '#ffd700'; document.getElementById('notification').style.textShadow = '0 0 20px #ffaa00';
  setTimeout(() => el.style.opacity = 0, 2000);
}

function updateUI() {
  document.getElementById('score').innerText = score; 
  document.getElementById('wave').innerText = wave > 10 ? 10 : wave; 
  document.getElementById('level').innerText = currentLevel;
  document.getElementById('weapon-tier-display').innerText = "WEAPON TIER: " + currentWeaponTier + (currentWeaponTier === 6 ? " (MAX)" : "");
  document.getElementById('wave-timer-fill').style.width = Math.max(0, 100 - (waveTimer / FRAMES_PER_WAVE * 100)) + '%';
  document.getElementById('xp-bar-fill').style.width = Math.min(100, (xp / xpNeeded) * 100) + '%';
}

function showGameOver() {
  gameRunning = false; 
  if (bgmAudio) { bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null; }
  if(bgmInterval) clearInterval(bgmInterval);
  
  spawnParticles(player.x, player.y, '#ff8800', 80);
  spawnParticles(player.x, player.y, '#ff4400', 40);
  wrecks.push(new EnemyDescent(player.x, player.y, false, true));
  
  setTimeout(() => {
    document.getElementById('game-over').style.display = 'flex'; 
    document.getElementById('end-title').innerText = "CRITICAL FAILURE"; 
    document.getElementById('end-title').style.color = "#ff4444";
    document.getElementById('end-desc').innerText = "ALL SYSTEMS DESTROYED"; 
    document.getElementById('end-btn').innerText = "RETRY MISSION"; 
    document.getElementById('final-score').innerText = `FINAL SCORE: ${score}`;
    document.getElementById('end-btn').onclick = restartGame;
  }, 600);
}

function victoryScreen() {
  gameRunning = false; 
  if (bgmAudio) { bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null; }
  if(bgmInterval) clearInterval(bgmInterval);
  document.getElementById('game-over').style.display = 'flex'; 
  document.getElementById('end-title').innerText = `VICTORY ACHIEVED`; document.getElementById('end-title').style.color = "#00ffaa";
  document.getElementById('end-desc').innerText = "THE GALAXY IS SAFE."; document.getElementById('end-btn').innerText = `RESTART GAME`; document.getElementById('final-score').innerText = `FINAL SCORE: ${score}`;
  document.getElementById('end-btn').onclick = restartGame;
}

function restartGame() { 
  if (bgmAudio) { bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null; }
  const allAudio = document.querySelectorAll('audio');
  allAudio.forEach(audio => { audio.pause(); audio.currentTime = 0; });
  
  document.getElementById('game-over').style.display = 'none'; 
  document.getElementById('start-screen').style.display = 'flex'; 
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; width = canvas.width; height = canvas.height; if (galaxyBackground) galaxyBackground.initLayers(); }
window.addEventListener('resize', resize); 
document.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
document.addEventListener('keydown', e => {
  if (e.code === 'Space' && gameRunning) {
    e.preventDefault();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    if (superPowerReady && !isPaused && !player.isCrashing) activateSquadron();
  }
});

function animate(timestamp) {
  if (!gameRunning) return; 
  requestAnimationFrame(animate); 
  if (isPaused) return;

  if (!timestamp) timestamp = performance.now();
  if (timestamp - lastTimestamp < 16) return; 
  lastTimestamp = timestamp;

  frameCount++; 
  
  let shakeX = 0, shakeY = 0;
  if (cameraShake > 0) { shakeX = (Math.random() - 0.5) * cameraShake; shakeY = (Math.random() - 0.5) * cameraShake; cameraShake *= 0.92; }
  
  ctx.save(); ctx.translate(shakeX, shakeY);
  ctx.fillStyle = '#020205'; ctx.fillRect(0, 0, width, height);

  if (galaxyBackground) { galaxyBackground.update(); galaxyBackground.draw(); }

  if (player.isCrashing) {
      ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
      ctx.fillRect(0, 0, width, height);
  }

  if (inIntermission) {
      intermissionTimer++;
      if (intermissionTimer === 30) { 
          if (intermissionIsBoss) {
              showNotification(wave === 11 ? "WARNING: UNKNOWN ENTITY DETECTED!" : (wave === 10 ? "‚ö† FINAL FORTRESS INCOMING!" : "BOSS APPROACHING!"));
              if(wave===11 || wave===10) { document.getElementById('notification').style.color = '#ff0000'; document.getElementById('notification').style.textShadow = '0 0 20px #ff0000'; }
          } else {
              showNotification("WAVE " + wave);
          }
      }
      if (intermissionTimer >= 90) { 
          inIntermission = false; waveTimer = 0; cardDroppedThisWave = false; aceSpawnedThisWave = false;
          if (intermissionIsBoss) {
              wave++; bossActive = true; bossSupportsUsed = 0;
              if (wave === 3) startBGM('boss1'); 
              else if (wave === 6) startBGM('boss2'); 
              else if (wave === 9) startBGM('boss3'); 
              else if (wave === 10) startBGM('boss4');
              else if (wave === 11) startBGM('secret');
              if (wave === 11) enemies.push(new SecretBoss()); else enemies.push(new Boss(wave)); 
          }
      }
      updateUI();
  } else if (!bossActive && wave <= 11) {
    if (waveTimer < FRAMES_PER_WAVE) {
        waveTimer++;
        let isDamaged = false; for(let k in player.parts){ if(player.parts[k].hp < player.parts[k].max) isDamaged = true; }
        if (isDamaged && (waveTimer === 300 || waveTimer === 650)) drops.push(new Drop(Math.random() * (width - 160) + 80, -30, 'HEAL'));
        
        if (waveTimer === 500 && !cardDroppedThisWave && Math.random() < 0.10) { drops.push(new Drop(Math.random() * (width - 160) + 80, -30, 'CARD')); cardDroppedThisWave = true; }
    }

    if (waveTimer >= FRAMES_PER_WAVE && !inIntermission) {
        waveTimer = 0; let nextWave = wave + 1;
        if (nextWave === 3 || nextWave === 6 || nextWave === 9 || nextWave === 10 || nextWave === 11) { 
            startIntermission(true); 
        } else { 
            wave++; startIntermission(false); 
        }
    }
    updateUI();
  }

  spawnLogic(); updateSupportWaves(); player.update();
  bullets.forEach(b => b.update()); enemies.forEach(e => e.update()); allies.forEach(a => a.update()); drops.forEach(d => d.update()); particles.forEach(p => p.update()); wrecks.forEach(w => w.update());
  escortShips.forEach(s => s.update());
  checkCollisions();

  player.draw();
  for (let i = bullets.length - 1; i >= 0; i--) { if (bullets[i].marked) { bullets.splice(i, 1); continue; } bullets[i].draw(); }
  for (let i = enemies.length - 1; i >= 0; i--) { enemies[i].draw(); }
  for (let i = allies.length - 1; i >= 0; i--) { if (allies[i].marked) { allies.splice(i, 1); continue; } allies[i].draw(); }
  for (let i = drops.length - 1; i >= 0; i--) { if (drops[i].marked) { drops.splice(i, 1); continue; } drops[i].draw(); }
  for (let i = wrecks.length - 1; i >= 0; i--) { if (wrecks[i].marked) { wrecks.splice(i, 1); continue; } wrecks[i].draw(); }
  for (let i = particles.length - 1; i >= 0; i--) { if (particles[i].life <= 0) { particles.splice(i, 1); continue; } particles[i].draw(); }
  for (let i = escortShips.length - 1; i >= 0; i--) { if (escortShips[i].marked) { escortShips.splice(i, 1); continue; } escortShips[i].draw(); }
  
  ctx.restore();
}
</script>
</body>
</html>