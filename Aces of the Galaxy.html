<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>ACES of the Galaxy</title>
<style>
body { margin: 0; overflow: hidden; background: #020205; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; cursor: none; }
canvas { display: block; }
@keyframes pulse { from { opacity:1; } to { opacity:0.4; } }

/* UI Overlay */ 
#ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
#hud-top { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; color: white; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
.hud-box { background: rgba(0, 0, 0, 0.5); padding: 10px 20px; border-radius: 20px; border: 1px solid #444; }

#damage-display { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 140px; background: rgba(0, 20, 40, 0.8); border: 2px solid #00d4ff; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
#damage-label { color: #00d4ff; font-size: 10px; margin-bottom: 5px; text-transform: uppercase; }

/* XP / Medal Bar */
#xp-bar-container { position: absolute; top: 60px; left: 50%; transform: translateX(-50%); width: 400px; height: 12px; background: #222; border: 2px solid #555; border-radius: 6px; box-shadow: 0 0 10px rgba(0,0,0,0.8); }
#xp-bar-fill { height: 100%; background: linear-gradient(90deg, #ffaa00, #ffd700); width: 0%; transition: width 0.2s; box-shadow: 0 0 10px #ffd700; border-radius: 4px; }
#xp-text { text-align: center; color: #ffd700; font-size: 13px; margin-top: 4px; text-transform: uppercase; font-weight: 900; letter-spacing: 1px; text-shadow: 1px 1px 2px #000; }

#element-bar-container { position: absolute; top: 95px; left: 50%; transform: translateX(-50%); width: 400px; height: 10px; background: #222; border: 1px solid #555; border-radius: 5px; }
#element-bar-fill { height: 100%; background: linear-gradient(90deg, #ff4444, #4488ff, #44aa44, #88ccff); width: 0%; transition: width 0.2s; }
#element-text { text-align: center; color: #aaa; font-size: 11px; margin-top: 2px; text-transform: uppercase; font-weight: bold; }

#weapon-tier-display { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); color: #ffd700; font-size: 16px; font-weight: bold; text-shadow: 0 0 10px #ffaa00; text-transform: uppercase; }

#wave-timer-container { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; color: white; }
#wave-timer-bar { width: 200px; height: 6px; background: #222; border: 1px solid #555; border-radius: 3px; margin-top: 5px; }
#wave-timer-fill { height: 100%; background: #00d4ff; width: 100%; }

#cards-display { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; width: 300px; }
.card-slot { width: 80px; height: 100px; background: rgba(0, 0, 0, 0.5); border: 1px solid #444; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-size: 12px; text-align: center; }
.card-slot.empty { border: 1px dashed #666; }
.card-rarity-common { border-top: 3px solid #aaa; }
.card-rarity-rare { border-top: 3px solid #44aaff; }
.card-rarity-epic { border-top: 3px solid #aa44ff; }
.card-rarity-legendary { border-top: 3px solid #ffaa44; }
.card-rarity-mythic { border-top: 3px solid #ff44aa; }

/* Menus */
#card-pickup, #game-over, #element-selection, #weapon-selection, #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; cursor: default; }
#card-pickup { background: rgba(10, 10, 25, 0.95); z-index: 150; }
#game-over { background: rgba(0, 0, 0, 0.9); z-index: 200; color: white;}
#element-selection, #weapon-selection { background: rgba(10, 10, 25, 0.95); z-index: 150; }
#start-screen { background: #050510; display: flex; z-index: 200; }

.btn { padding: 15px 50px; font-size: 24px; background: #00d4ff; border: none; color: #000; font-weight: 800; cursor: pointer; border-radius: 5px; box-shadow: 0 0 25px rgba(0, 212, 255, 0.5); text-transform: uppercase; margin-top: 20px; }
.btn:hover { background: white; box-shadow: 0 0 40px white; }
.selection-container { display: flex; gap: 30px; }
.option-box { width: 200px; height: 250px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #00d4ff; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.3s; box-shadow: 0 0 15px rgba(0, 212, 255, 0.2); padding: 15px; color: white; text-align: center; }
.option-box:hover { transform: translateY(-10px); box-shadow: 0 0 30px rgba(0, 212, 255, 0.8); background: #202040; }
.option-icon { font-size: 60px; margin-bottom: 15px; }
.option-name { font-size: 24px; font-weight: bold; color: #00d4ff; margin-bottom: 10px; }
.option-desc { font-size: 14px; color: #aaa; }

.element-fire { border-color: #ff4444; } .element-fire .option-name { color: #ff4444; }
.element-water { border-color: #4488ff; } .element-water .option-name { color: #4488ff; }
.element-earth { border-color: #44aa44; } .element-earth .option-name { color: #44aa44; }
.element-air { border-color: #88ccff; } .element-air .option-name { color: #88ccff; }

.card-preview { width: 300px; height: 400px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #ff44aa; border-radius: 15px; display: flex; flex-direction: column; align-items: center; padding: 20px; color: white; box-shadow: 0 0 30px rgba(255, 68, 170, 0.5); }
.card-preview-icon { font-size: 80px; margin: 20px 0; }
.card-preview h2 { color: #ff44aa; margin: 10px 0; font-size: 24px; text-transform: uppercase; }
.card-rarity-tag { padding: 5px 15px; border-radius: 20px; font-weight: bold; margin: 10px 0; background: #333; }
.btn-small { padding: 10px 30px; font-size: 18px; background: #ff44aa; border: none; color: white; font-weight: 800; cursor: pointer; border-radius: 5px; margin-top: 20px; box-shadow: 0 0 15px rgba(255, 68, 170, 0.5); }
#notification { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); color: #ffd700; font-size: 40px; font-weight: 900; opacity: 0; text-shadow: 0 0 20px #ffaa00; pointer-events: none; transition: opacity 0.5s; text-align: center; z-index: 50; }
</style>
</head>
<body>

<div id="ui-layer">
  <div id="hud-top">
    <div class="hud-box">SCORE: <span id="score">0</span></div>
    <div id="wave-timer-container">
      <div style="font-size: 20px; font-weight: bold;">WAVE: <span id="wave">1</span></div>
      <div id="wave-timer-bar"><div id="wave-timer-fill"></div></div>
    </div>
    <div class="hud-box" style="color:#00d4ff">LEVEL: <span id="level">1</span></div>
  </div>
  
  <div id="xp-bar-container"><div id="xp-bar-fill"></div><div id="xp-text">COLLECT MEDALS TO LEVEL UP</div></div>
  <div id="element-bar-container"><div id="element-bar-fill"></div><div id="element-text">ELEMENT POWER</div></div>
  <div id="weapon-tier-display">WEAPON TIER: 0</div>
  
  <div id="super-power-container" style="position:absolute; bottom:20px; right:20px; width:180px; background:rgba(0,0,0,0.6); border:2px solid #ff8800; border-radius:10px; padding:8px 12px; color:white;">
    <div style="font-size:11px; color:#ff8800; text-transform:uppercase; margin-bottom:4px;">‚ö° SQUADRON POWER</div>
    <div style="background:#222; border-radius:4px; height:10px; overflow:hidden; border:1px solid #555;">
      <div id="super-power-fill" style="height:100%; background:linear-gradient(90deg,#ff6600,#ffcc00); width:0%; transition:width 0.15s; box-shadow:0 0 8px #ff8800;"></div>
    </div>
    <div id="super-power-text" style="font-size:11px; text-align:center; margin-top:3px; color:#aaa;">0 / 50 KILLS</div>
    <div id="super-activate-btn" style="display:none; margin-top:6px; text-align:center; font-size:14px; font-weight:900; color:#ffcc00; text-shadow:0 0 10px #ff8800; animation:pulse 0.8s infinite alternate;">‚ñ∂ ACTIVATE [SPACE]</div>
  </div>
  
  <div id="damage-display"><div id="damage-label">SHIP STATUS</div><canvas id="damageCanvas" width="80" height="100"></canvas></div>
  
  <!-- Wingman HUD -->
  <div id="wingman-hud" style="position:absolute; bottom:180px; left:20px; width:120px; display:none;">
    <div style="color:#44ff44; font-size:10px; text-transform:uppercase; margin-bottom:4px; text-shadow:0 0 6px #44ff44;">‚ö° WINGMEN</div>
    <div id="wingman-left-bar" style="height:8px; background:#111; border:1px solid #44ff44; border-radius:3px; margin-bottom:4px; overflow:hidden;"><div id="wingman-left-fill" style="height:100%; background:#44ff44; width:100%; transition:width 0.2s;"></div></div>
    <div id="wingman-right-bar" style="height:8px; background:#111; border:1px solid #44ff44; border-radius:3px; overflow:hidden;"><div id="wingman-right-fill" style="height:100%; background:#44ff44; width:100%; transition:width 0.2s;"></div></div>
    <div id="wingman-tier-text" style="color:#88ff88; font-size:9px; margin-top:3px; text-align:center;">TIER 0</div>
  </div>

  <!-- Boss intro overlay -->
  <div id="boss-intro-overlay" style="position:absolute; top:0; left:0; width:100%; height:100%; display:none; flex-direction:column; align-items:center; justify-content:center; pointer-events:none; z-index:40;">
    <div id="boss-intro-name" style="color:#ff0000; font-size:52px; font-weight:900; text-shadow:0 0 30px #ff0000, 0 0 60px #ff0000; text-transform:uppercase; letter-spacing:4px; text-align:center;"></div>
    <div id="boss-intro-sub" style="color:#ffaa00; font-size:22px; font-weight:bold; text-shadow:0 0 15px #ff8800; margin-top:12px; text-align:center;"></div>
  </div>

  <div id="cards-display"><div class="card-slot empty">EMPTY</div><div class="card-slot empty">EMPTY</div><div class="card-slot empty">EMPTY</div></div>
  <div id="notification">SYSTEMS REPAIRED</div>
</div>

<div id="start-screen">
  <div style="text-align: center;">
    <h1 style="color:#00d4ff; font-size: 80px; margin-bottom: 10px; text-shadow: 0 0 30px #00d4ff;">ACES GALAXY</h1>
    <p style="color:white; font-size: 18px; margin-bottom: 40px;">Move with MOUSE. Collect Weapon Crates to Upgrade. Survive 10 waves!</p>
    <button class="btn" onclick="document.getElementById('start-screen').style.display='none'; document.getElementById('element-selection').style.display='flex'; initAudio();">LAUNCH MISSION</button>
  </div>
</div>

<div id="element-selection">
  <h1 style="color:#ffffff; font-size: 40px; margin-bottom: 30px;">CHOOSE YOUR ELEMENT</h1>
  <div class="selection-container">
    <div class="option-box element-fire" onclick="selectElement('FIRE')"><div class="option-icon">üî•</div><div class="option-name">FIRE</div><div class="option-desc">+ Damage<br>Burn Effects</div></div>
    <div class="option-box element-water" onclick="selectElement('WATER')"><div class="option-icon">üíß</div><div class="option-name">WATER</div><div class="option-desc">+ Fire Rate<br>Slow Effects</div></div>
    <div class="option-box element-earth" onclick="selectElement('EARTH')"><div class="option-icon">üåç</div><div class="option-name">EARTH</div><div class="option-desc">+ Defense<br>Stun Effects</div></div>
    <div class="option-box element-air" onclick="selectElement('AIR')"><div class="option-icon">üå™Ô∏è</div><div class="option-name">AIR</div><div class="option-desc">+ Speed<br>Chain Lightning</div></div>
  </div>
</div>

<div id="weapon-selection">
  <h1 style="color:#ffd700; font-size: 40px; margin-bottom: 30px;">CHOOSE YOUR WEAPON</h1>
  <div class="selection-container">
    <div class="option-box" onclick="selectWeapon('machinegun')"><div class="option-icon">üî´</div><div class="option-name">MACHINE GUN</div><div class="option-desc">Rapid continuous fire.<br>Upgrades into massive bullet walls.</div></div>
    <div class="option-box" onclick="selectWeapon('shotgun')"><div class="option-icon">üí•</div><div class="option-name">FLAK SHOTGUN</div><div class="option-desc">Wide spread, high close damage.<br>Upgrades into explosive shrapnel.</div></div>
    <div class="option-box" onclick="selectWeapon('sniper')"><div class="option-icon">üéØ</div><div class="option-name">SNIPER</div><div class="option-desc">High damage, slow fire rate.<br>Upgrades to pierce and explode.</div></div>
  </div>
</div>

<div id="card-pickup">
  <div class="card-preview" id="card-preview">
    <div class="card-preview-icon">?</div><h2 id="card-name">CARD NAME</h2><div class="card-rarity-tag" id="card-rarity">Rarity</div>
    <p id="card-desc">Card description</p><button class="btn-small" onclick="acceptCard()">EQUIP CARD</button>
  </div>
</div>

<div id="game-over">
  <h1 id="end-title" style="color:#ff4444; font-size: 60px;">CRITICAL FAILURE</h1>
  <div id="final-score" style="font-size: 30px; margin: 20px;">FINAL SCORE: 0</div>
  <p id="end-desc" style="color: #aaa; margin-bottom: 30px;">ALL SYSTEMS DESTROYED</p>
  <button id="end-btn" class="btn" onclick="restartGame()">RETRY MISSION</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const dmgCanvas = document.getElementById('damageCanvas');
const dmgCtx = dmgCanvas.getContext('2d');

let width, height, gameRunning = false, isPaused = false, frameCount = 0;
let currentLevel = 1, wave = 1, waveTimer = 0, bossActive = false;
let cardDroppedThisWave = false;
let cameraShake = 0;
let lastTimestamp = 0; 
const FRAMES_PER_WAVE = 900; 

let inIntermission = false;
let intermissionTimer = 0;
let intermissionIsBoss = false;

let score = 0, xp = 0, xpNeeded = 800, elementPower = 0, maxElementPower = 100;
let currentWeapon = null, currentWeaponTier = 0, currentElement = 'NONE';
let equippedCards = [null, null, null], pendingCard = null;

let pendingSupportPasses = 0;
let supportPassTimer = 0;
let bossSupportsUsed = 0;
let supportSpawnDelay = 0; 
let globalFormationIdCounter = 0; 

let superPowerMeter = 0;
let superPowerReady = false;
let aceSpawnedThisWave = false;
let wingmen = [];       // persistent wingman array
let wingmanTier = 0;    // 0-3 upgrade tier

function getSuperPowerNeeded() {
  if (wave <= 3) return 50;
  if (wave <= 6) return 75;
  return 100; 
}

const ELEMENTS = { NONE: '#ffffff', FIRE: '#ff4444', WATER: '#4488ff', EARTH: '#44aa44', AIR: '#88ccff' };
const ELEMENT_NAMES = { FIRE: 'Fire', WATER: 'Water', EARTH: 'Earth', AIR: 'Air' };
const RARITIES = ['common', 'rare', 'epic', 'legendary', 'mythic'];
const RARITY_COLORS = { common: '#aaa', rare: '#44aaff', epic: '#aa44ff', legendary: '#ffaa44', mythic: '#ff44aa' };

const ELEMENT_CARDS = {
  FIRE: [
    { name: "Inferno", desc: "+ Damage & Burn enemies", rarity: 'common', effect: 'burn' },
    { name: "Magma Burst", desc: "++ Damage & Explosive shots", rarity: 'rare', effect: 'explosive' },
    { name: "Phoenix", desc: "+++ Damage & Auto-Repair 1 Part", rarity: 'epic', effect: 'revive' },
    { name: "Solar Flare", desc: "++++ Damage & Chain lightning", rarity: 'legendary', effect: 'chain' },
    { name: "Supernova", desc: "MASSIVE Damage & Explosions", rarity: 'mythic', effect: 'supernova' }
  ],
  WATER: [
    { name: "Tidal Wave", desc: "+ Fire Rate & Push enemies", rarity: 'common', effect: 'pushback' },
    { name: "Ice Shard", desc: "++ Fire Rate & Slow enemies", rarity: 'rare', effect: 'slow' },
    { name: "Aqua Shield", desc: "+++ Fire Rate & Absorb Damage", rarity: 'epic', effect: 'shield' },
    { name: "Hydro Vortex", desc: "++++ Fire Rate & Pull enemies", rarity: 'legendary', effect: 'pull' },
    { name: "Ocean's Wrath", desc: "INSANE Fire Rate Boost", rarity: 'mythic', effect: 'minions' }
  ],
  EARTH: [
    { name: "Stone Skin", desc: "+ Defense & Armor", rarity: 'common', effect: 'armor' },
    { name: "Quake", desc: "++ Defense & Stun enemies", rarity: 'rare', effect: 'stun' },
    { name: "Gaia's Blessing", desc: "+++ Defense & Regen HP", rarity: 'epic', effect: 'regen' },
    { name: "Terra Firma", desc: "++++ Defense & Barriers", rarity: 'legendary', effect: 'barrier' },
    { name: "World Tree", desc: "GODLIKE Defense & Structures", rarity: 'mythic', effect: 'turrets' }
  ],
  AIR: [
    { name: "Gale Force", desc: "+ Speed & Maneuver", rarity: 'common', effect: 'speed' },
    { name: "Lightning Strike", desc: "++ Speed & Chain enemies", rarity: 'rare', effect: 'chain' },
    { name: "Storm Eye", desc: "+++ Speed & Dodge chance", rarity: 'epic', effect: 'dodge' },
    { name: "Tempest", desc: "++++ Speed & Wind Blades", rarity: 'legendary', effect: 'blades' },
    { name: "Celestial Wind", desc: "LIGHTSPEED & Teleportation", rarity: 'mythic', effect: 'teleport' }
  ]
};

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let noiseBuffer = null, bgmInterval = null, bgmAudio = null, currentTheme = 'normal';
let audioFiles = {}; 

function initAudio() {
  if (!audioCtx || noiseBuffer) return;
  const bufferSize = audioCtx.sampleRate * 1.0; 
  noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0); 
  for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
  
  audioFiles = {
    background: 'background music.mp3',
    boss: 'boss music.mp3',
    support: 'Support sound effect.MP3',
    explosion: 'explosion sound.mp3',
    bossExplosion: 'Explosion Sound Effect.mp3',
    // Enemy events
    enemyHit: 'Enemy hit sound effect.mp3',
    // Wingman events
    wingmanReady: 'Wingman ready.mp3',
    wingmanRepaired: 'Wingman repaired.mp3',
    wingmanUpgraded: 'Wingman upgraded.mp3',
    // Player events
    weaponTierIncrease: 'Weapon tier increase.mp3',
    heal: 'Heal.mp3',
    // Boss events
    bossIntro: 'Boss intro.mp3',
    bossDefeated: 'Boss defeated.mp3',
    allTurretsGone: 'All turrets gone.mp3',
    oneTurretGone: 'One turret gone.mp3',
    enginesAllGone: 'Engines all gone.mp3',
    oneEngineGone: 'One engine gone.mp3',
    // Game completion
    missionAccomplished: 'Mission accomplished.mp3',
  };
}

function playAudioFile(filename, shouldLoop = false) {
  try {
    const poolSize = 8; 
    if (!audioFiles[filename + '_pool']) {
      audioFiles[filename + '_pool'] = [];
      for (let i = 0; i < poolSize; i++) {
        let a = new Audio(filename);
        a.volume = 0.6;
        audioFiles[filename + '_pool'].push(a);
      }
      audioFiles[filename + '_index'] = 0;
    }
    let pool = audioFiles[filename + '_pool'];
    let idx = audioFiles[filename + '_index'];
    let a = pool[idx];
    a.volume = 0.9;
    if (shouldLoop) a.loop = true;
    a.currentTime = 0;
    a.play().catch(e => { });
    audioFiles[filename + '_index'] = (idx + 1) % poolSize;
  } catch (e) {}
}

function startBGM(theme = 'normal') {
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  if (bgmAudio) { bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null; }
  if (bgmInterval) { clearInterval(bgmInterval); bgmInterval = null; }
  
  let filename = null;
  let isBossMusic = false;
  if (theme === 'normal') filename = audioFiles.background;
  else if (theme === 'boss1' || theme === 'boss2' || theme === 'boss3' || theme === 'boss4' || theme === 'secret') {
    filename = audioFiles.boss;
    isBossMusic = true;
  }
  
  if (filename) {
    bgmAudio = new Audio(filename);
    bgmAudio.loop = true;
    bgmAudio.volume = isBossMusic ? 1.0 : 0.6;
    bgmAudio.play().catch(e => {});
  }
  currentTheme = theme;
}

function playRealisticGun(type) {
  if (!audioCtx || !noiseBuffer || audioCtx.state === 'suspended') return;
  const now = audioCtx.currentTime; const noiseSource = audioCtx.createBufferSource(); noiseSource.buffer = noiseBuffer;
  const filter = audioCtx.createBiquadFilter(); const gain = audioCtx.createGain();
  if (type === 'machinegun') { filter.type = 'bandpass'; filter.frequency.value = 1800; filter.Q.value = 0.8; gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08); } 
  else if (type === 'shotgun') { filter.type = 'lowpass'; filter.frequency.value = 1200; gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25); } 
  else if (type === 'sniper') { filter.type = 'highpass'; filter.frequency.value = 800; gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); } 
  else if (type === 'support') { filter.type = 'bandpass'; filter.frequency.value = 2200; gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); }
  noiseSource.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); noiseSource.start(now);
}

function playEnemyGun(type) {
  if (!audioCtx || !noiseBuffer || audioCtx.state === 'suspended') return;
  const now = audioCtx.currentTime; const ns = audioCtx.createBufferSource(); ns.buffer = noiseBuffer;
  const f = audioCtx.createBiquadFilter(); const g = audioCtx.createGain();
  if (type === 'tank') { f.type = 'lowpass'; f.frequency.value = 400; g.gain.setValueAtTime(0.4, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.3); }
  else if (type === 'speedy') { f.type = 'highpass'; f.frequency.value = 2500; g.gain.setValueAtTime(0.1, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.1); }
  else if (type === 'missile') { f.type = 'lowpass'; f.frequency.value = 800; g.gain.setValueAtTime(0.7, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.5); }
  else { f.type = 'bandpass'; f.frequency.value = 1000; g.gain.setValueAtTime(0.2, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.15); }
  ns.connect(f); f.connect(g); g.connect(audioCtx.destination); ns.start(now);
}

function playUpgradeSound() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.type = 'sine'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now + 0.2);
  gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
  osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.5);
}

function playEngineFlyby() {
  if (!audioCtx || !noiseBuffer || audioCtx.state === 'suspended') return;
  const now = audioCtx.currentTime; const ns = audioCtx.createBufferSource(); ns.buffer = noiseBuffer;
  const f = audioCtx.createBiquadFilter(); const g = audioCtx.createGain();
  f.type = 'lowpass'; f.frequency.setValueAtTime(100, now); f.frequency.linearRampToValueAtTime(800, now + 1.0); f.frequency.linearRampToValueAtTime(100, now + 2.5);
  g.gain.setValueAtTime(0.01, now); g.gain.linearRampToValueAtTime(0.6, now + 1.0); g.gain.linearRampToValueAtTime(0.01, now + 2.5);
  ns.connect(f); f.connect(g); g.connect(audioCtx.destination); ns.start(now);
}

function playImpactSound() {
  if (!audioCtx || audioCtx.state === 'suspended') return;
  const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.type = 'square'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
  gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
  osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.1);
}

function drawDamageModel(parts) {
  dmgCtx.clearRect(0, 0, 80, 100);
  const getColor = (hp, max) => {
    if (hp <= 0) return '#000000'; const pct = hp / max;
    if (pct > 0.75) return '#00ff00'; if (pct > 0.5) return '#ffff00'; if (pct > 0.25) return '#ff8800'; return '#ff0000';
  };
  dmgCtx.fillStyle = getColor(parts.body.hp, parts.body.max); dmgCtx.fillRect(25, 20, 30, 40); dmgCtx.strokeStyle = '#005555'; dmgCtx.strokeRect(25, 20, 30, 40);
  dmgCtx.fillStyle = getColor(parts.leftWing.hp, parts.leftWing.max); dmgCtx.beginPath(); dmgCtx.moveTo(25, 35); dmgCtx.lineTo(5, 55); dmgCtx.lineTo(25, 65); dmgCtx.fill(); dmgCtx.stroke();
  dmgCtx.fillStyle = getColor(parts.rightWing.hp, parts.rightWing.max); dmgCtx.beginPath(); dmgCtx.moveTo(55, 35); dmgCtx.lineTo(75, 55); dmgCtx.lineTo(55, 65); dmgCtx.fill(); dmgCtx.stroke();
  dmgCtx.fillStyle = getColor(parts.engine.hp, parts.engine.max); dmgCtx.fillRect(30, 65, 20, 25); dmgCtx.strokeRect(30, 65, 20, 25);
  dmgCtx.fillStyle = getColor(parts.gun.hp, parts.gun.max); dmgCtx.fillRect(35, 12, 10, 12); dmgCtx.strokeRect(35, 12, 10, 12);
}

class Player {
  constructor() {
    this.x = window.innerWidth / 2; this.y = window.innerHeight - 100; this.size = 65; 
    // Player HP met 50% verhoogd
    this.parts = { body: { hp: 400, max: 400 }, leftWing: { hp: 270, max: 270 }, rightWing: { hp: 270, max: 270 }, engine: { hp: 330, max: 330 }, gun: { hp: 300, max: 300 } };
    this.speed = 0.6; this.damage = 15; this.fireRate = 4; this.fireTimer = 0; 
    this.element = 'NONE'; this.weaponType = 'base'; this.shotCount = 1; this.spreadAngle = 0; this.isParallel = false;
    this.effects = {}; this.firstShot = true; this.backupGun = false; this.invincibleTimer = 0;
    this.damageMultiplier = 1; this.fireRateMultiplier = 1; this.speedMultiplier = 1; this.defenseMultiplier = 1;
    this.isCrashing = false; this.crashTimer = 0; this.rotation = 0;
  }
  
  isDead() { return this.parts.body.hp <= 0 || this.parts.engine.hp <= 0 || (this.parts.leftWing.hp <= 0 && this.parts.rightWing.hp <= 0); }

  takeDamage(amount, relX, relY) {
      if (this.effects.invincible) return;
      if (this.element === 'AIR' && Math.random() < 0.15) { spawnParticles(this.x, this.y, '#ffffff', 10); return; }
      if (this.effects.dodge && Math.random() < 0.15) { spawnParticles(this.x, this.y, '#ffffff', 10); return; }

      let targetPart = 'body';
      if (relY > 18) targetPart = 'engine'; else if (relX < -18) targetPart = 'leftWing'; else if (relX > 18) targetPart = 'rightWing'; else if (Math.random() < 1) targetPart = 'gun';
      if (targetPart === 'engine' && this.parts.body.hp > 0) amount *= 0.5;
      if (this.parts[targetPart].hp <= 0) { const alive = Object.keys(this.parts).filter(k => this.parts[k].hp > 0); if (alive.length > 0) targetPart = alive[0]; else return; }
      this.parts[targetPart].hp -= amount; drawDamageModel(this.parts); playImpactSound();
  }

  update() {
    if (this.isCrashing) {
        this.crashTimer--;
        this.y += 5.0; 
        this.rotation += 0.2;
        spawnParticles(this.x, this.y, '#ff4400', 5);
        spawnParticles(this.x, this.y, '#444444', 5);
        if (this.crashTimer <= 0) { showGameOver(); }
        return;
    }

    let baseSpeed = 0.6; let elementDmgMult = 1.0; let elementFRMult = 1.0;
    
    if (this.element === 'FIRE') elementDmgMult = 1.15; 
    else if (this.element === 'WATER') elementFRMult = 1.15;
    else if (this.element === 'EARTH') { this.effects.elementArmor = true; }
    else if (this.element === 'AIR') { baseSpeed *= 1.25; }

this.speed = (baseSpeed + (this.effects.speed || 0)) * this.speedMultiplier;
    
    // DE FIX: Maximale cap op speed zodat de muis-berekening nooit over de kop slaat
    this.speed = Math.min(this.speed, 0.95);
    
    if (this.parts.engine.hp <= 0) { this.speed = 0.16; if (frameCount % 6 === 0) this.parts.body.hp -= 3; }    
    if (this.parts.leftWing.hp <= 0 && this.parts.rightWing.hp <= 0) {
        if (!this.isCrashing) { this.isCrashing = true; this.crashTimer = 60; playAudioFile(audioFiles.bossExplosion); }
        return; 
    }
    if (this.parts.leftWing.hp <= 0 || this.parts.rightWing.hp <= 0) this.speed *= 0.65;
    
    let wDamage = 15; let wFireRate = 4; let wShotCount = 1; let wSpread = 0;
    
    this.effects.pierce = false; this.isSlug = false; this.effects.splinter = false;
    this.effects.plasmaArea = false; this.effects.bigExplosion = false; this.effects.explosive = false;
    this.effects.incendiary = false; this.effects.homing = false; this.isParallel = false; this.bulletSpeedMult = 1.0; let isBossHunter = false;

    if (this.weaponType === 'sniper') {
        wDamage = 200; wFireRate = 70; wShotCount = 1; wSpread = 0; 
        if(currentWeaponTier >= 1) { this.effects.pierce = true; wDamage = 150; wFireRate = 100; }
        if(currentWeaponTier >= 2) { wFireRate = 90; }
        if(currentWeaponTier >= 3) { this.effects.plasmaArea = true; }
        if(currentWeaponTier >= 4) { wFireRate = 80; }
        if(currentWeaponTier >= 5) { this.bulletSpeedMult = 1.2; }
        if(currentWeaponTier >= 6) { this.effects.explosive = true; wDamage *= 0.5; } // was 2.0x, nerfed
    } else if (this.weaponType === 'machinegun') {
        wDamage = 30; wFireRate = 15; wShotCount = 2; this.isParallel = true; wSpread = 0;
        if(currentWeaponTier >= 1) { wShotCount = 3; this.isParallel = true; wDamage = 25; }
        if(currentWeaponTier >= 2) { wFireRate = 7; }
        if(currentWeaponTier >= 3) { wShotCount = 4; this.isParallel = false; wSpread = 0.8; wDamage = 20; }
        if(currentWeaponTier >= 4) { wShotCount = 5; wSpread = 0.7; wDamage = 18; }
        if(currentWeaponTier >= 5) { this.effects.incendiary = true; wFireRate = 6; }
        if(currentWeaponTier >= 6) { wShotCount = 6; wSpread = 0.7; wFireRate = 5.5; wDamage = 18; } 
    } else if (this.weaponType === 'shotgun') {
        wDamage = 60; wFireRate = 60; wShotCount = 4; wSpread = 1; 
        if(currentWeaponTier >= 1) { wShotCount = 5; }
        if(currentWeaponTier >= 2) { wSpread = 0.9; }
        if(currentWeaponTier >= 3) { wFireRate = 50; }
        if(currentWeaponTier >= 4) { this.effects.explosive = true; wDamage = 40; }
        if(currentWeaponTier >= 5) { wShotCount = 6; }
        if(currentWeaponTier >= 6) { wShotCount = 8; wSpread = 0.8; wDamage = 50; }
    }

    if (this.parts.gun.hp <= 0) { this.backupGun = true; wDamage *= 0.55; wFireRate *= 2.2; } else this.backupGun = false;
    
    this.damage = wDamage * elementDmgMult * this.damageMultiplier;
    this.fireRate = Math.max(1, (wFireRate / elementFRMult) / this.fireRateMultiplier);
    this.shotCount = wShotCount;
    this.spreadAngle = wSpread;

    if (this.effects.armor) this.damage *= (0.75 * this.defenseMultiplier);
    
    this.x += (mouse.x - this.x) * this.speed; this.y += (mouse.y - this.y) * this.speed;
    this.x = Math.max(30, Math.min(width - 30, this.x));
    this.y = Math.max(30, Math.min(height - 30, this.y));

    if (this.effects.invincible) { this.invincibleTimer--; if (this.invincibleTimer <= 0) this.effects.invincible = false; }
    
    if (this.effects.regen && frameCount % 90 === 0) {
        let worst = null; let minPct = 1;
        for (let k in this.parts) { let p = this.parts[k]; if (p.hp > 0 && p.hp < p.max && (p.hp/p.max) < minPct) { worst = k; minPct = p.hp/p.max; } }
        if (worst) { this.parts[worst].hp += 4 * this.defenseMultiplier; drawDamageModel(this.parts); } 
    }

    if (this.effects.supernova && frameCount % 300 === 0) {
      spawnParticles(this.x, this.y, '#ff4444', 100);
      enemies.forEach(enemy => { enemy.hp -= 350 * this.damageMultiplier; if (enemy.hp <= 0) killEnemy(enemy); });
    }

    this.fireTimer++;
    if (this.fireTimer >= this.fireRate) {
      this.shoot(); this.fireTimer = 0;
      if (this.weaponType !== 'base') playRealisticGun(this.weaponType);
    }
  }

  shoot() {
    const color = ELEMENTS[this.element];
    const angleStep = this.shotCount > 1 ? this.spreadAngle / (this.shotCount - 1) : 0;
    let special = { 
        isSlug: this.isSlug, splinter: this.effects.splinter, plasmaArea: this.effects.plasmaArea, 
        bigExplosion: this.effects.bigExplosion, homing: this.effects.homing, incendiary: this.effects.incendiary, bossHunter: false
    };

    if (this.isParallel) {
        for (let i = 0; i < this.shotCount; i++) {
            let offset = (i - (this.shotCount - 1) / 2) * 20; 
            const vy = -38 * this.bulletSpeedMult;
            bullets.push(new Bullet(this.x + offset, this.y - 45, 0, vy, color, false, this.element, this.effects.explosive, this.damage, special));
        }
    } else {
        for (let i = 0; i < this.shotCount; i++) {
            const angle = this.shotCount > 1 ? (-this.spreadAngle/2 + i * angleStep) : 0;
            const vx = Math.sin(angle) * 7.0 * this.bulletSpeedMult; 
            const vy = -Math.cos(angle) * 38 * this.bulletSpeedMult;
            bullets.push(new Bullet(this.x, this.y - 45, vx, vy, color, false, this.element, this.effects.explosive, this.damage, special));
        }
    }

    if (this.weaponType === 'sniper' && !this.effects.bigExplosion) {
        bullets.push(new Bullet(this.x - 0, this.y - 20, -8, -30, color, false, this.element, false, this.damage * 0.50));
        bullets.push(new Bullet(this.x + 0, this.y - 20, 8, -30, color, false, this.element, false, this.damage * 0.50));
    }
  }

  draw() {
    ctx.save(); ctx.translate(this.x, this.y); 
    if (this.rotation) ctx.rotate(this.rotation);
    ctx.scale(2.6, 2.6);
    if (this.isCrashing) {
        let crashScale = Math.max(0.01, 1 - (60 - this.crashTimer) / 60);
        ctx.scale(crashScale, crashScale);
    }

    if (this.effects.invincible) {
        ctx.shadowBlur = 20; ctx.shadowColor = '#00d4ff'; ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(0, 0, 24 + Math.sin(frameCount * 0.2) * 2, 0, Math.PI*2); ctx.stroke();
    }

    // ‚îÄ‚îÄ TWIN ENGINE PODS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const engAlive = this.parts.engine.hp > 0 && !this.isCrashing;
    
    // Left engine pod
    ctx.fillStyle = '#0a1a2a';
    ctx.beginPath(); ctx.moveTo(-16, -8); ctx.lineTo(-14, -8); ctx.lineTo(-14, 20); ctx.lineTo(-16, 20); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 0.5; ctx.stroke();
    // Left engine exhaust
    if (engAlive) {
        let lEH = 10 + Math.random() * 8;
        let lGrad = ctx.createLinearGradient(-15, 20, -15, 20+lEH);
        lGrad.addColorStop(0, '#00d4ff'); lGrad.addColorStop(1, 'rgba(0,180,255,0)');
        ctx.fillStyle = lGrad;
        ctx.beginPath(); ctx.moveTo(-17, 20); ctx.lineTo(-15, 20+lEH); ctx.lineTo(-13, 20); ctx.fill();
    }
    // Right engine pod
    ctx.fillStyle = '#0a1a2a';
    ctx.beginPath(); ctx.moveTo(14, -8); ctx.lineTo(16, -8); ctx.lineTo(16, 20); ctx.lineTo(14, 20); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 0.5; ctx.stroke();
    if (engAlive) {
        let rEH = 10 + Math.random() * 8;
        let rGrad = ctx.createLinearGradient(15, 20, 15, 20+rEH);
        rGrad.addColorStop(0, '#00d4ff'); rGrad.addColorStop(1, 'rgba(0,180,255,0)');
        ctx.fillStyle = rGrad;
        ctx.beginPath(); ctx.moveTo(13, 20); ctx.lineTo(15, 20+rEH); ctx.lineTo(17, 20); ctx.fill();
    }

    // ‚îÄ‚îÄ LEFT WING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const lwAlive = this.parts.leftWing.hp > 0;
    const lwPct = lwAlive ? this.parts.leftWing.hp / this.parts.leftWing.max : 0;
    ctx.fillStyle = lwAlive ? (lwPct > 0.5 ? '#1a3a5a' : '#3a1a1a') : '#111';
    ctx.beginPath();
    ctx.moveTo(-8, 0); ctx.lineTo(-28, 16); ctx.lineTo(-26, 22); ctx.lineTo(-14, 16);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = lwAlive ? '#00d4ff' : '#333'; ctx.lineWidth = 0.5; ctx.stroke();
    if (lwAlive) {
        ctx.fillStyle = '#00d4ff'; ctx.globalAlpha = 0.3 * lwPct;
        ctx.beginPath(); ctx.moveTo(-10, 3); ctx.lineTo(-24, 16); ctx.lineTo(-14, 16); ctx.closePath(); ctx.fill();
        ctx.globalAlpha = 1;
    }

    // ‚îÄ‚îÄ RIGHT WING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const rwAlive = this.parts.rightWing.hp > 0;
    const rwPct = rwAlive ? this.parts.rightWing.hp / this.parts.rightWing.max : 0;
    ctx.fillStyle = rwAlive ? (rwPct > 0.5 ? '#1a3a5a' : '#3a1a1a') : '#111';
    ctx.beginPath();
    ctx.moveTo(8, 0); ctx.lineTo(28, 16); ctx.lineTo(26, 22); ctx.lineTo(14, 16);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = rwAlive ? '#00d4ff' : '#333'; ctx.lineWidth = 0.5; ctx.stroke();
    if (rwAlive) {
        ctx.fillStyle = '#00d4ff'; ctx.globalAlpha = 0.3 * rwPct;
        ctx.beginPath(); ctx.moveTo(10, 3); ctx.lineTo(24, 16); ctx.lineTo(14, 16); ctx.closePath(); ctx.fill();
        ctx.globalAlpha = 1;
    }

    // ‚îÄ‚îÄ MAIN HULL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const bodyAlive = this.parts.body.hp > 0;
    const bodyPct = bodyAlive ? this.parts.body.hp / this.parts.body.max : 0;
    ctx.shadowBlur = bodyAlive ? 15 : 0; ctx.shadowColor = '#00d4ff';
    ctx.fillStyle = bodyAlive ? (bodyPct > 0.5 ? '#1a3060' : (bodyPct > 0.25 ? '#402010' : '#500010')) : '#111';
    ctx.beginPath();
    ctx.moveTo(0, -26);  // nose tip
    ctx.lineTo(8, -12);
    ctx.lineTo(8, -2);
    ctx.lineTo(12, 2);
    ctx.lineTo(12, 14);
    ctx.lineTo(-12, 14);
    ctx.lineTo(-12, 2);
    ctx.lineTo(-8, -2);
    ctx.lineTo(-8, -12);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = bodyAlive ? '#00d4ff' : '#333'; ctx.lineWidth = 0.6; ctx.stroke();

    // ‚îÄ‚îÄ GUN / MUZZLE POINTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (this.parts.gun.hp > 0) {
        ctx.shadowBlur = 8; ctx.shadowColor = '#00ffcc';
        // Left muzzle
        ctx.fillStyle = '#aaccff';
        ctx.fillRect(-14, -18, 3, 10);
        // Right muzzle
        ctx.fillRect(11, -18, 3, 10);
        // Center nose cannon tip
        ctx.fillStyle = '#00ffcc';
        ctx.fillRect(-1, -30, 2, 8);
    } else {
        ctx.fillStyle = '#333'; ctx.fillRect(-6, -26, 5, 8); ctx.fillRect(1, -26, 5, 8);
    }

    // ‚îÄ‚îÄ COCKPIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (bodyAlive) {
        ctx.fillStyle = '#0088ff'; ctx.shadowBlur = 6; ctx.shadowColor = '#0088ff';
        ctx.beginPath(); ctx.ellipse(0, -8, 5, 8, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#88ccff';
        ctx.beginPath(); ctx.ellipse(-1, -10, 2, 4, 0, 0, Math.PI*2); ctx.fill();
    }

    // ‚îÄ‚îÄ ELEMENT GLOW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (this.element !== 'NONE' && bodyAlive && !this.isCrashing) {
        ctx.shadowBlur = 12; ctx.shadowColor = ELEMENTS[this.element]; 
        ctx.strokeStyle = ELEMENTS[this.element]; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0,-26); ctx.lineTo(8,-12); ctx.lineTo(12,2); ctx.lineTo(12,14); 
        ctx.lineTo(-12,14); ctx.lineTo(-12,2); ctx.lineTo(-8,-12); ctx.closePath(); ctx.stroke();
        ctx.shadowBlur = 0;
    }
    ctx.restore();
  }
}

class SupportShip {
  constructor(x, y, vx = 0, vy = -36, rotation = 0, delay = 0, pattern = 'linear') { 
      this.x = x; this.y = y; this.vx = vx; this.vy = vy; 
      this.rotation = rotation; this.marked = false; this.fireTimer = 14; 
      this.delay = delay; this.pattern = pattern; 
  }
  update() {
    if (this.delay > 0) { this.delay--; return; } 

    this.x += this.vx; this.y += this.vy; 
    if (this.y < -400 || this.y > height + 400 || this.x < -400 || this.x > width + 400) this.marked = true;

    this.fireTimer++;
    if (this.fireTimer >= 5) {
      this.fireTimer = 0;
      for(let i = -4; i <= 5; i++) {
          let angle = this.rotation - Math.PI/2 + (i * 0.12);
          bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*56, Math.sin(angle)*56, '#00ffcc', false, 'NONE', false, 60));
      }
      playRealisticGun('support');
    }
  }
  draw() {
    if (this.delay > 0) return; 

    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.scale(6, 6); ctx.shadowBlur = 15; ctx.shadowColor = '#00ffcc';
    ctx.fillStyle = '#113355'; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-15, 10); ctx.lineTo(15, 10); ctx.fill();
    ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#00ffff'; ctx.fillRect(-3, -10, 6, 12);
    ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.moveTo(-8, 10); ctx.lineTo(-8, 20); ctx.lineTo(-4, 10); ctx.fill();
    ctx.beginPath(); ctx.moveTo(8, 10); ctx.lineTo(8, 20); ctx.lineTo(4, 10); ctx.fill(); ctx.restore();
  }
}

class Enemy {
  constructor(waveDiff, formationType = false, startX, startY, startX2, startY2, delay = 0) {
    let maxType = 2; if (wave >= 4) maxType = 4; if (wave >= 7) maxType = 6;
    this.type = Math.floor(Math.random() * (maxType + 1));
    this.formationType = formationType;
    this.subType = 'normal';
    if (this.type >= 3) this.subType = 'tank'; 
    
    this.isCrashing = false;
    this.crashTimer = 0;
    this.returning = false;
    this.returnTargetX = null;
    
    let baseHp = (35 + (this.type * 9)) * 2; 
    this.hp = baseHp * Math.pow(1.08, waveDiff - 1); 
    this.maxHp = this.hp; 
    this.size = 55;
    this.vx = 0; 
    this.targetY = 80 + Math.random() * 200;
    this.xOffset = Math.random() * 200; 
    this.rotation = 0;
    
    if (formationType === 'bomber') {
      this.behavior = 'bomber';
      this.subType = 'bomber';
      this.x = Math.random() * (width - 150) + 75;
      this.y = -150;
      this.hp = 2000 * Math.pow(1.08, waveDiff - 1); 
      this.maxHp = this.hp;
      this.size = 85;
      this.speed = 1.0 * Math.pow(1.02, waveDiff - 1);
      this.damage = 40;
      this.fireInterval = 50;
      this.rotation = Math.PI;
    } else if (formationType === 'ace_pilot') {
      this.behavior = 'ace_pilot';
      this.subType = 'ace';
      this.dir = Math.random() > 0.5 ? 1 : -1; // 1=left‚Üíright, -1=right‚Üíleft
      this.x = this.dir === 1 ? -140 : width + 140;
      this.y = 80 + Math.random() * (height * 0.38);
      this.baseY = this.y;
      this.hp = 900 * Math.pow(1.10, waveDiff - 1);
      this.maxHp = this.hp;
      this.size = 60;
      this.speed = 22; // fast fly-by
      this.damage = 18;
      this.fireInterval = 1; // not used via timer
      this.flyPhase = 'active';
      this.waitTimer = 0;
      this.shot25 = false;
      this.shot75 = false;
    } else if (formationType === 'boss_missile') {
      this.behavior = 'boss_missile';
      this.subType = 'boss_missile';
      this.x = startX; this.y = startY;
      this.hp = 120; // Player can shoot it down relatively easily
      this.maxHp = 120;
      this.speed = 4;
      this.damage = 300; // Heavy damage to player
      this.size = 50;
      this.fireInterval = 9999;
    } else if (formationType === 'fighter-wing') {
      this.behavior = 'fighter-wing';
      this.x = startX; this.y = startY;
      this.fireInterval = 60;
    } else if (this.formationType === 'side-sweep') {
      this.behavior = 'side-sweep';
      this.x = startX; this.y = startY;
      this.startY = startY;
      this.fireInterval = 55;
      this.sideSweepPhase = 0;
    } else if (this.formationType === 'diagonal-kette') {
      this.behavior = 'diagonal-kette';
      this.x = startX; this.y = startY - 50;
      this.rotation = Math.PI;
      this.fireInterval = 80;
    } else if (this.formationType === 'box') {
      this.behavior = 'box';
      this.x = startX; this.y = startY - 50;
      this.rotation = Math.PI;
      this.fireInterval = 90;
    } else if (this.formationType === 'column-sweep') {
      this.behavior = 'column-sweep';
      this.x = startX || Math.random() * (width - 200) + 100;
      this.y = startY || -150;
      this.rotation = Math.PI;
      this.vy = 0;
      this.fireInterval = 70;
    } else {
      this.x = Math.random() * (width - 80) + 40;
      this.y = -150;
      this.behavior = 'homing';
      this.fireInterval = 100;
    }

    if(this.formationType !== 'bomber' && this.formationType !== 'ace_pilot' && this.formationType !== 'boss_missile') {
       this.speed = 5.5; // uniform speed for all normal enemies regardless of formation
       this.damage = Math.min(50, 20 * Math.pow(1.08, waveDiff - 1));
    }
    this.fireTimer = Math.random() * this.fireInterval;
    this.slowed = false; this.stunned = false; this.stunTimer = 0; this.burnTimer = 0;
  }

  update() {
    if (this.isCrashing) {
        this.crashTimer--;
        this.y += 6;
        this.rotation += 0.3;
        spawnParticles(this.x, this.y, '#ff4400', 4);
        spawnParticles(this.x, this.y, '#222222', 4);
        if (this.crashTimer <= 0) { finalizeKillEnemy(this); }
        return;
    }

    if (this.stunned) { this.stunTimer--; if (this.stunTimer <= 0) this.stunned = false; else return; }
    if (this.burnTimer > 0) { 
        this.burnTimer--; this.hp -= 1.5 * player.damageMultiplier; 
        if(frameCount % 5 === 0) spawnParticles(this.x, this.y, '#ff4400', 3);
        if (this.hp <= 0) { killEnemy(this); return; } 
    }
    
    const speedMult = this.slowed ? 0.40 : 1; 

    if (this.returning) {
        if (!this.returnTargetX) {
            this.returnTargetX = width * 0.2 + Math.random() * (width * 0.6);
            this.returnTargetY = height * 0.1 + Math.random() * (height * 0.3);
            this.rotation = Math.atan2(this.returnTargetY - this.y, this.returnTargetX - this.x);
        }

        let targetRotation = Math.atan2(this.returnTargetY - this.y, this.returnTargetX - this.x);
        let diff = targetRotation - this.rotation;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        this.rotation += diff * 0.05;

        this.x += Math.cos(this.rotation) * this.speed * 1.5 * speedMult;
        this.y += Math.sin(this.rotation) * this.speed * 1.5 * speedMult;

        if (Math.hypot(this.returnTargetX - this.x, this.returnTargetY - this.y) < 50) {
            this.returning = false;
            this.returnTargetX = null;
        }
    } else {
        if (this.behavior === 'bomber') {
           this.y += this.speed * speedMult;
           this.rotation = Math.PI / 2; // Always face downward
           if (this.y > height + 100) { this.returning = true; }
        } else if (this.behavior === 'ace_pilot') {
           if (this.flyPhase === 'waiting') {
               this.waitTimer++;
               if (this.waitTimer >= 300) { // 5 seconds
                   this.waitTimer = 0;
                   this.flyPhase = 'active';
                   this.dir *= -1; // Re-enter from opposite side
                   this.x = this.dir === 1 ? -140 : width + 140;
                   this.y = 80 + Math.random() * (height * 0.38);
                   this.baseY = this.y;
                   this.shot25 = false;
                   this.shot75 = false;
               }
           } else {
               // Smooth fly-by with gentle arc
               this.x += this.dir * this.speed * speedMult;
               this.y = this.baseY + Math.sin(frameCount * 0.025 + this.xOffset) * 55;
               // rotation for drawing (facing direction of travel)
               let dy = Math.cos(frameCount * 0.025 + this.xOffset) * 55 * 0.025;
               this.rotation = Math.atan2(dy, this.dir * this.speed);
               
               // Fire triple burst at 25% and 75% screen traversal
               let pct = this.dir === 1 ? this.x / width : (width - this.x) / width;
               if (!this.shot25 && pct > 0.25) { this.shot25 = true; this.shootAceTriple(); }
               if (!this.shot75 && pct > 0.75) { this.shot75 = true; this.shootAceTriple(); }
               
               // Off-screen ‚Üí waiting phase
               if ((this.dir === 1 && this.x > width + 140) || (this.dir === -1 && this.x < -140)) {
                   this.flyPhase = 'waiting';
                   this.waitTimer = 0;
               }
           }
        } else if (this.behavior === 'boss_missile') {
           this.rotation = Math.atan2(player.y - this.y, player.x - this.x);
           this.x += Math.cos(this.rotation) * this.speed * speedMult;
           this.y += Math.sin(this.rotation) * this.speed * speedMult;
           if (frameCount % 3 === 0) spawnParticles(this.x, this.y, '#888888', 2);
        } else if (this.behavior === 'fighter-wing') {
           // Aces of the Luftwaffe stijl: Vloeiende S-bocht (Figure-8 achtig)
           this.x += this.side * this.speed * speedMult;
           let sineOff = Math.sin(frameCount * 0.03 + this.xOffset) * 120; // Veel diepere S-curve
           let prevSine = Math.sin((frameCount - 1) * 0.03 + this.xOffset) * 120;
           this.y += (sineOff - prevSine) * speedMult;
           
           let yVel = (sineOff - prevSine);
           // Neus draait dynamischer mee in de S-bocht
           this.rotation = Math.PI + Math.atan2(yVel, this.side * this.speed) * 0.8;
           if (this.x > width + 150 || this.x < -150 || this.y > height + 100) this.returning = true;
           
        } else if (this.behavior === 'side-sweep') {
           // Graceful U-Turn: Duikt diep het scherm in en veert weer omhoog
           let prevX = this.x;
           let prevY = this.y;
           this.x += this.side * this.speed * speedMult;
           let travelWidth = width + 300;
           let entryX = this.side === 1 ? -150 : width + 150;
           let progress = (this.x - entryX) / (this.side === 1 ? travelWidth : -travelWidth);
           progress = Math.max(0, Math.min(1, progress));
           
           let arcY = this.startY + Math.sin(progress * Math.PI) * 450; // Duikt 450px diep in!
           this.y = arcY;
           
           // Calculate velocity-based rotation from actual movement
           let velX = this.x - prevX;
           let velY = this.y - prevY;
           this.rotation = Math.atan2(velY, velX);
           
           if ((this.side === 1 && this.x > width + 150) || (this.side === -1 && this.x < -150)) { this.returning = true; }
           
        } else if (this.behavior === 'diagonal-kette' || this.behavior === 'box') {
           // Naar voren (hard!), maar met een dreigende flauwe bocht er in
           this.y += this.speed * speedMult; 
           let curveSpeed = this.behavior === 'box' ? 0.04 : 0.02;
           let curveWidth = this.behavior === 'box' ? 3 : 1.5;
           
           // Schuift zachtjes van links naar rechts
           let prevX = this.x;
           this.x += Math.sin(frameCount * curveSpeed + this.xOffset) * curveWidth * speedMult;
           let prevY = this.y - this.speed * speedMult; // Previous Y before movement
           
           // Calculate rotation based on actual velocity
           let velX = this.x - prevX;
           let velY = this.speed * speedMult;
           this.rotation = Math.atan2(velY, velX);
           
           if (this.y > height + 80) { this.returning = true; }
           
        } else if (this.behavior === 'column-sweep') {
          // Lijn vliegend: Nu ook met een flauwe slinger in de lucht
          const dir = this.vy === -1 ? -1 : 1;
          this.y += this.speed * speedMult * dir;
          
          // Slingerend vliegen in plaats van rigide rechtdoor
          let prevX = this.x;
          this.x += Math.sin(frameCount * 0.025 + this.xOffset) * 1.5 * speedMult;
          
          // Calculate velocity-based rotation
          let velX = this.x - prevX;
          let velY = this.speed * speedMult * dir;
          this.rotation = Math.atan2(velY, velX);

          if (dir === 1 && this.y > height + 80) { this.vy = -1; } 
          else if (dir === -1 && this.y < -80) { this.returning = true; }
        } else {
          if (this.y < this.targetY) {
            this.y += this.speed * speedMult * 0.9;
            this.rotation = Math.PI / 2; // Face downward while ascending
          } else { 
            if (this.subType === 'tank') {
               this.x += (player.x - this.x) * 0.02 * speedMult;
               this.y += (player.y - this.y - 300) * 0.01 * speedMult; 
               this.rotation = Math.atan2(player.y - this.y, player.x - this.x) - Math.PI/2;
            } else {
               let prevX = this.x;
               let prevY = this.y;
               this.x += (player.x - this.x) * 0.008 * speedMult; 
               this.x += Math.cos(frameCount * 0.022 + this.xOffset) * 2.0;
               // Calculate velocity-based rotation
               let velX = this.x - prevX;
               let velY = (player.y - prevY) * 0.008 * speedMult;
               this.rotation = Math.atan2(velY, velX);
            }
          }
        }
    }

    if (!this.returning) {
        enemies.forEach(other => {
            if (other !== this && !other.isBoss && !other.isCrashing) {
                let dx = this.x - other.x; let dy = this.y - other.y;
                let dist = Math.hypot(dx, dy);
                let minDist = this.size + 15;
                if (dist < minDist && dist > 0) {
                    this.x += (dx / dist) * 1.5;
                    this.y += (dy / dist) * 1.5;
                }
            }
        });
    }
    
    if (!inIntermission && this.subType !== 'boss_missile' && this.subType !== 'ace') {
        let distToPlayer = Math.hypot(this.x - player.x, this.y - player.y);
        let shootRange = height * 0.75;
        this.fireTimer--;
        if (this.fireTimer <= 0 && distToPlayer < shootRange && this.y > -50 && this.y < height + 50) { 
            this.fireTimer = this.fireInterval; 
            if (this.subType === 'bomber' || this.subType === 'ace' || Math.random() < 0.6) this.shoot();
        }
    }
  }

  shootAceTriple() {
    // Triple shot aimed downward into the screen
    let downAngle = Math.PI / 2 + (Math.random() - 0.5) * 0.3; // mostly down
    for (let i = -1; i <= 1; i++) {
      let a = downAngle + i * 0.22;
      let b = new Bullet(this.x, this.y, Math.cos(a) * 11, Math.sin(a) * 11, '#00ffdd', true, 'NONE', false, this.damage);
      b.size = 7; bullets.push(b);
    }
    playRealisticGun('support');
  }

  shoot() {
    if (this.subType === 'bomber') {
        for (let i=0; i<8; i++) {
            let a = (i/8)*Math.PI*2;
            bullets.push(new Bullet(this.x, this.y+20, Math.cos(a)*8, Math.sin(a)*8, '#ffaa00', true, 'NONE', false, this.damage));
        }
        playEnemyGun('tank');
        return;
    }
    
    if (this.subType === 'ace') {
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*12, Math.sin(angle)*12, '#ffffff', true, 'NONE', false, this.damage));
        playEnemyGun('speedy');
        return;
    }

    const angle = Math.atan2(player.y - this.y, player.x - this.x);
    const spd = this.subType === 'tank' ? 7.0 : 9.0;
    let b = new Bullet(this.x, this.y + 20, Math.cos(angle)*spd, Math.sin(angle)*spd, '#ff5555', true, 'NONE', false, this.damage);
    b.size = this.subType === 'tank' ? 9 : 7;
    bullets.push(b);
    playEnemyGun(this.subType || 'normal');
  }
  
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); 
    
    if (this.subType === 'ace') {
        // Ace pilot uses its own internal rotation+flip, skip generic rotation
        let renderScale = 2.5;
        if (this.isCrashing) {
            let crashScale = Math.max(0.01, 1 - (22 - this.crashTimer)/22);
            ctx.scale(renderScale * crashScale, renderScale * crashScale);
        } else {
            ctx.scale(renderScale, renderScale);
        }
    } else if (this.subType === 'boss_missile') {
         ctx.rotate(this.rotation + Math.PI/2);
    } else {
         ctx.rotate(this.rotation);
    }
    
    let renderScale = this.subType === 'bomber' ? 3.0 : 2.0;
    if (this.subType === 'ace') { /* already handled above */ } else
    if (this.isCrashing) {
        let crashScale = Math.max(0.01, 1 - (22 - this.crashTimer)/22);
        ctx.scale(renderScale * crashScale, renderScale * crashScale);
    } else {
        ctx.scale(renderScale, renderScale);
    }

    if (this.subType === 'bomber') {
        ctx.shadowBlur = 40; ctx.shadowColor = '#ff6600';
        ctx.fillStyle = '#442211';
        ctx.beginPath(); ctx.moveTo(-20, 10); ctx.lineTo(20, 10); ctx.lineTo(30, -10); ctx.lineTo(0, -30); ctx.lineTo(-30, -10); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, -10, 8, 0, Math.PI*2); ctx.fill();
    } else if (this.subType === 'ace') {
        // Don't draw when waiting off-screen
        if (this.flyPhase === 'waiting') { ctx.restore(); return; }
        // ACE PILOT: sleek fighter, player-sized, cyan/gold colors
        ctx.save();
        // Tilt based on vertical component of motion for banking effect
        let tilt = this.rotation * (this.dir === 1 ? 1 : -1) * 0.5;
        ctx.rotate(tilt);
        // flip horizontally based on flight direction
        ctx.scale(this.dir, 1);
        ctx.shadowBlur = 25; ctx.shadowColor = '#00ffcc';
        
        // Engine exhaust glow
        let flameH = 12 + Math.random() * 8;
        let grad = ctx.createLinearGradient(0, 14, 0, 14 + flameH);
        grad.addColorStop(0, '#00ffcc'); grad.addColorStop(1, 'rgba(0,255,180,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.moveTo(-4, 14); ctx.lineTo(0, 14 + flameH); ctx.lineTo(4, 14); ctx.fill();

        // Main fuselage
        ctx.fillStyle = '#0d2244';
        ctx.beginPath();
        ctx.moveTo(0, -24);    // nose
        ctx.lineTo(6, -10);
        ctx.lineTo(8, 12);
        ctx.lineTo(-8, 12);
        ctx.lineTo(-6, -10);
        ctx.closePath(); ctx.fill();
        
        // Gold cockpit stripe
        ctx.fillStyle = '#ffd700';
        ctx.beginPath(); ctx.ellipse(0, -10, 5, 9, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#001122';
        ctx.beginPath(); ctx.ellipse(0, -10, 3.5, 7, 0, 0, Math.PI*2); ctx.fill();
        
        // Left swept wing
        ctx.fillStyle = '#1a3a6a';
        ctx.beginPath();
        ctx.moveTo(-6, 2);
        ctx.lineTo(-26, 14);
        ctx.lineTo(-26, 20);
        ctx.lineTo(-8, 14);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 0.8; ctx.stroke();
        
        // Right swept wing
        ctx.beginPath();
        ctx.moveTo(6, 2);
        ctx.lineTo(26, 14);
        ctx.lineTo(26, 20);
        ctx.lineTo(8, 14);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 0.8; ctx.stroke();
        
        // Tail fins
        ctx.fillStyle = '#0d2244';
        ctx.beginPath();
        ctx.moveTo(-4, 10); ctx.lineTo(-14, 18); ctx.lineTo(-8, 18); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(4, 10); ctx.lineTo(14, 18); ctx.lineTo(8, 18); ctx.closePath(); ctx.fill();
        
        // Fuselage gold trim
        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-6, -10); ctx.lineTo(-8, 12); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(6, -10); ctx.lineTo(8, 12); ctx.stroke();
        
        // Gun barrels
        ctx.fillStyle = '#aaaaaa';
        ctx.fillRect(-12, -5, 4, 12);
        ctx.fillRect(8, -5, 4, 12);
        
        ctx.restore();
    } else if (this.subType === 'boss_missile') {
        ctx.shadowBlur = 15; ctx.shadowColor = '#ff2200';
        ctx.fillStyle = '#aa0000';
        ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-10, 10); ctx.lineTo(10, 10); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, -15, 6, 0, Math.PI*2); ctx.fill();
        let flameH = 10 + Math.random() * 15;
        ctx.fillStyle = '#ffeedd';
        ctx.beginPath(); ctx.moveTo(-5, 10); ctx.lineTo(0, 10 + flameH); ctx.lineTo(5, 10); ctx.fill();
    } else {
        // SPACE SHOOTER ENEMY DESIGNS
        const isTank = this.subType === 'tank';
        if (isTank) {
            // BOMBER SPACESHIP: large, imposing, dangerous
            ctx.shadowBlur = 40; ctx.shadowColor = '#ff2200';
            
            // Main fuselage body - large oval shape
            ctx.fillStyle = '#330000';
            ctx.beginPath();
            ctx.moveTo(0, -32);     // nose cone
            ctx.bezierCurveTo(18, -24, 28, -8, 28, 8);
            ctx.bezierCurveTo(28, 20, 18, 28, 0, 32);
            ctx.bezierCurveTo(-18, 28, -28, 20, -28, 8);
            ctx.bezierCurveTo(-28, -8, -18, -24, 0, -32);
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle = '#ff4400'; ctx.lineWidth = 1.2; ctx.stroke();
            
            // Nose armor plating
            ctx.fillStyle = '#550000';
            ctx.beginPath(); ctx.moveTo(-8, -28); ctx.lineTo(0, -36); ctx.lineTo(8, -28); ctx.closePath(); ctx.fill();
            
            // Wings (bomb racks)
            ctx.fillStyle = '#220000';
            // Left wing
            ctx.beginPath(); ctx.moveTo(-20, -4); ctx.lineTo(-42, 0); ctx.lineTo(-42, 8); ctx.lineTo(-20, 4); ctx.closePath(); ctx.fill();
            ctx.strokeStyle = '#ff6600'; ctx.lineWidth = 0.8; ctx.stroke();
            // Right wing
            ctx.beginPath(); ctx.moveTo(20, -4); ctx.lineTo(42, 0); ctx.lineTo(42, 8); ctx.lineTo(20, 4); ctx.closePath(); ctx.fill();
            ctx.stroke();
            
            // Bomb/missile pods on wings
            ctx.fillStyle = '#444';
            ctx.fillRect(-40, -3, 8, 6);
            ctx.fillRect(32, -3, 8, 6);
            
            // Engine exhausts
            let eGrad = ctx.createLinearGradient(0, 28, 0, 45);
            eGrad.addColorStop(0, '#ff6600'); eGrad.addColorStop(0.5, '#ff4400'); eGrad.addColorStop(1, 'rgba(255,50,0,0)');
            ctx.fillStyle = eGrad;
            ctx.beginPath(); ctx.moveTo(-10, 28); ctx.lineTo(-12, 45); ctx.lineTo(-8, 28); ctx.fill();
            ctx.beginPath(); ctx.moveTo(10, 28); ctx.lineTo(12, 45); ctx.lineTo(8, 28); ctx.fill();
            
            // Cockpit window
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.ellipse(0, -12, 6, 4, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#00ff44';
            ctx.beginPath(); ctx.ellipse(0, -12, 3, 2, 0, 0, Math.PI*2); ctx.fill();
            
            // Hull vents/details
            ctx.strokeStyle = '#ff3300'; ctx.lineWidth = 0.5;
            for (let i = -2; i <= 2; i++) {
              if (i === 0) continue;
              ctx.beginPath(); ctx.moveTo(i*9, -8); ctx.lineTo(i*9, 12); ctx.stroke();
            }
        } else {
            // INTERCEPTOR: sleek, fast, aggressive
            const colors = [
              ['#440000','#ff4444','#ff3300'], // red
              ['#003311','#44ff88','#00ff44'], // green  
              ['#220044','#aa44ff','#8800ff'], // purple
            ];
            let ci = Math.min(2, Math.floor(this.type / 2));
            let [hull, glow, accent] = colors[ci];
            ctx.shadowBlur = 25; ctx.shadowColor = glow;
            // Engine exhaust
            let eH = 16 + Math.random() * 8;
            let eGrad = ctx.createLinearGradient(0, 14, 0, 14 + eH);
            eGrad.addColorStop(0, glow); eGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = eGrad;
            ctx.beginPath(); ctx.moveTo(-5, 14); ctx.lineTo(0, 14+eH); ctx.lineTo(5, 14); ctx.fill();
            // Hull - sleek fighter shape
            ctx.fillStyle = this.slowed ? '#0044aa' : hull;
            ctx.beginPath();
            ctx.moveTo(0, -26);  // nose tip
            ctx.lineTo(7, -12);
            ctx.lineTo(8, 14);
            ctx.lineTo(-8, 14);
            ctx.lineTo(-7, -12);
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle = glow; ctx.lineWidth = 0.7; ctx.stroke();
            // Swept wings
            ctx.fillStyle = hull;
            ctx.beginPath(); ctx.moveTo(-7, -4); ctx.lineTo(-26, 10); ctx.lineTo(-22, 16); ctx.lineTo(-8, 10); ctx.closePath(); ctx.fill();
            ctx.strokeStyle = glow; ctx.lineWidth = 0.5; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(7, -4); ctx.lineTo(26, 10); ctx.lineTo(22, 16); ctx.lineTo(8, 10); ctx.closePath(); ctx.fill();
            ctx.stroke();
            // Cockpit
            ctx.fillStyle = accent;
            ctx.beginPath(); ctx.ellipse(0, -8, 4, 7, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.beginPath(); ctx.ellipse(-1, -10, 1.5, 2.5, 0, 0, Math.PI*2); ctx.fill();
            // Nose gun barrel (clearly visible muzzle)
            ctx.fillStyle = '#cccccc';
            ctx.fillRect(-2, -30, 4, 8);
            ctx.fillStyle = accent;
            ctx.fillRect(-1, -32, 2, 4); // muzzle flash point
        }
    }
    ctx.restore();
  }
}

class Boss {
  constructor(waveNum) {
    this.waveNum = waveNum; this.isBoss = true;
    let opMult = 1 + (currentWeaponTier * 0.25); // was 0.2, slightly more HP per tier
    this.currentPhase = 0; 
    this.parts = [];
    let totalBossHp = 0;
    this.isCrashing = false; this.crashTimer = 0;
    
    if (waveNum === 3) {
      this.name = "IRON HAWK FORTRESS";
      // Phase 0: Twin rear engine nacelles (visible at bottom of fuselage)
      this.parts.push({id:'eng_l', relX:-36, relY:80, hp:2200*opMult, maxHp:2200*opMult, radius:22, color:'#44ff44', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_r', relX:36, relY:80, hp:2200*opMult, maxHp:2200*opMult, radius:22, color:'#44ff44', isDead:false, phase:0, label:'ENGINE'});
      // Phase 1: Wing-tip gun pods
      this.parts.push({id:'gun_l', relX:-200, relY:65, hp:2000*opMult, maxHp:2000*opMult, radius:22, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
      this.parts.push({id:'gun_r', relX:200, relY:65, hp:2000*opMult, maxHp:2000*opMult, radius:22, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
      // Phase 2: Cockpit/hull
      this.parts.push({id:'hull', relX:0, relY:-40, hp:1000*opMult, maxHp:1000*opMult, radius:28, color:'#ff2200', isDead:false, phase:2, label:'HULL'});
      totalBossHp = 11400 * opMult;
    } else if (waveNum === 6) {
      this.name = "STEEL CARRIER FORTRESS";
      // Phase 0: Engines ‚Äî sponsons on the sides
      this.parts.push({id:'eng_fl', relX:-250, relY:20, hp:2800*opMult, maxHp:2800*opMult, radius:24, color:'#44aaff', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_fr', relX:250, relY:20, hp:2800*opMult, maxHp:2800*opMult, radius:24, color:'#44aaff', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_rl', relX:-150, relY:60, hp:2800*opMult, maxHp:2800*opMult, radius:20, color:'#44aaff', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_rr', relX:150, relY:60, hp:2800*opMult, maxHp:2800*opMult, radius:20, color:'#44aaff', isDead:false, phase:0, label:'ENGINE'});
      // Phase 1: Battery turrets on deck
      this.parts.push({id:'bat_l', relX:-160, relY:-20, hp:3500*opMult, maxHp:3500*opMult, radius:26, color:'#ff8800', isDead:false, phase:1, label:'BATTERY'});
      this.parts.push({id:'bat_c', relX:0, relY:-100, hp:3500*opMult, maxHp:3500*opMult, radius:26, color:'#ff8800', isDead:false, phase:1, label:'BATTERY'});
      this.parts.push({id:'bat_r', relX:160, relY:-20, hp:3500*opMult, maxHp:3500*opMult, radius:26, color:'#ff8800', isDead:false, phase:1, label:'BATTERY'});
      // Phase 2: Bridge
      this.parts.push({id:'hull', relX:0, relY:-100, hp:1667*opMult, maxHp:1667*opMult, radius:38, color:'#ff2200', isDead:false, phase:2, label:'HULL'});
      totalBossHp = 25600 * opMult;
    } else if (waveNum === 9) {
      this.name = "DOOM ZEPPELIN";
      // Phase 0: Engine nacelles under gondola
      this.parts.push({id:'nac_l', relX:-105, relY:100, hp:4000*opMult, maxHp:4000*opMult, radius:22, color:'#ff6600', isDead:false, phase:0, label:'PROPELLER'});
      this.parts.push({id:'nac_c', relX:0, relY:120, hp:4000*opMult, maxHp:4000*opMult, radius:22, color:'#ff6600', isDead:false, phase:0, label:'PROPELLER'});
      this.parts.push({id:'nac_r', relX:105, relY:100, hp:4000*opMult, maxHp:4000*opMult, radius:22, color:'#ff6600', isDead:false, phase:0, label:'PROPELLER'});
      // Phase 1: Turrets on side fins and gondola
      this.parts.push({id:'tur_ll', relX:-235, relY:5, hp:3500*opMult, maxHp:3500*opMult, radius:22, color:'#ff8800', isDead:false, phase:1, label:'TURRET'});
      this.parts.push({id:'tur_l', relX:-80, relY:85, hp:3500*opMult, maxHp:3500*opMult, radius:22, color:'#ff8800', isDead:false, phase:1, label:'TURRET'});
      this.parts.push({id:'tur_r', relX:80, relY:85, hp:3500*opMult, maxHp:3500*opMult, radius:22, color:'#ff8800', isDead:false, phase:1, label:'TURRET'});
      this.parts.push({id:'tur_rr', relX:235, relY:5, hp:3500*opMult, maxHp:3500*opMult, radius:22, color:'#ff8800', isDead:false, phase:1, label:'TURRET'});
      // Phase 2: Gondola command center
      this.parts.push({id:'hull', relX:0, relY:105, hp:2000*opMult, maxHp:2000*opMult, radius:38, color:'#ff2200', isDead:false, phase:2, label:'GONDOLA'});
      totalBossHp = 28000 * opMult;
    } else if (waveNum === 10) {
      this.name = "FINAL COLOSSUS";
      this.parts.push({id:'eng_ll', relX:-200, relY:100, hp:6000*opMult, maxHp:6000*opMult, radius:38, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_l', relX:-110, relY:120, hp:6000*opMult, maxHp:6000*opMult, radius:35, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_c', relX:0, relY:130, hp:7000*opMult, maxHp:7000*opMult, radius:40, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_r', relX:110, relY:120, hp:6000*opMult, maxHp:6000*opMult, radius:35, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'eng_rr', relX:200, relY:100, hp:6000*opMult, maxHp:6000*opMult, radius:38, color:'#00ff66', isDead:false, phase:0, label:'ENGINE'});
      this.parts.push({id:'can_ll', relX:-190, relY:-50, hp:5500*opMult, maxHp:5500*opMult, radius:30, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'can_l', relX:-100, relY:-80, hp:5500*opMult, maxHp:5500*opMult, radius:30, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'can_c', relX:0, relY:-110, hp:6000*opMult, maxHp:6000*opMult, radius:34, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'can_r', relX:100, relY:-80, hp:5500*opMult, maxHp:5500*opMult, radius:30, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'can_rr', relX:190, relY:-50, hp:5500*opMult, maxHp:5500*opMult, radius:30, color:'#ff8800', isDead:false, phase:1, label:'CANNON'});
      this.parts.push({id:'core', relX:0, relY:0, hp:4667*opMult, maxHp:4667*opMult, radius:90, color:'#ff0000', isDead:false, phase:2, label:'CORE'});
      totalBossHp = 80000 * opMult;
    }
    
    this.hp = totalBossHp; this.maxHp = totalBossHp;
    this.speed = waveNum === 10 ? 4.4 : (waveNum === 9 ? 3.2 : 2.4);
    this.x = width / 2; this.y = -400;
    this.targetY = waveNum === 6 ? 120 : (waveNum === 10 ? 150 : 170);
    this.introPhase = true;
    this.fireTimer = 0; this.pattern = 0; this.patternTimer = 0;
    this.attackPhaseTimer = 0; this.attackInterval = 60; 
    this.inAttack = false; this.attackBurstTimer = 0;
    this.burnTimer = 0; this.hitCount = 0; this.direction = 1; this.slowed = false;
    this.stunTimer = 0; this.spinAngle = 0;
    this.acePilotTimer = 0;
  }
  
  checkCurrentPhase() {
    let phaseParts = this.parts.filter(p => p.phase === this.currentPhase && !p.isDead);
    if (phaseParts.length === 0) {
      const prevPhase = this.currentPhase;
      this.currentPhase++;
      // Stun only when engines are destroyed (phase 0‚Üí1), NOT when guns destroyed (1‚Üí2, that causes spinning)
      if (prevPhase === 0) {
        this.stunTimer = 120; // 2-second stun for engine destruction only
      }
      if (this.currentPhase === 1) { 
        let msg = this.waveNum === 10 ? "ENGINES DOWN! DESTROY THE CANNONS!" : "ENGINES DOWN! TARGET THE GUNS!";
        showNotification(msg); cameraShake = 20; 
      }
      else if (this.currentPhase === 2) { 
        let msg = this.waveNum === 10 ? "CANNONS DESTROYED! TARGET THE CORE!" : "GUNS DESTROYED! TARGET THE HULL!";
        showNotification(msg); cameraShake = 30; 
      }
    }
  }
  
  update() {
    if (this.isCrashing) {
        this.crashTimer--;
        this.y += 3.0;
        this.x += Math.sin(this.crashTimer * 0.2) * 5;
        spawnParticles(this.x + (Math.random()-0.5)*150, this.y + (Math.random()-0.5)*150, '#ff4400', 10);
        spawnParticles(this.x + (Math.random()-0.5)*150, this.y, '#222222', 15);
        if (this.crashTimer <= 0) { finalizeKillEnemy(this); }
        return;
    }

    if (this.burnTimer > 0) { 
      this.burnTimer--; 
      if (this.currentPhase <= 2) {
        let activeParts = this.parts.filter(p => p.phase === this.currentPhase && !p.isDead);
        if (activeParts.length > 0) {
          let burnTarget = activeParts[Math.floor(Math.random() * activeParts.length)];
          burnTarget.hp -= 2.4 * player.damageMultiplier;
          if(frameCount%5===0) spawnParticles(this.x + burnTarget.relX, this.y + burnTarget.relY, '#ff4400', 3);
          if (burnTarget.hp <= 0) { burnTarget.isDead = true; burnTarget.hp = 0; this.checkCurrentPhase(); }
        }
      } else {
        this.hp -= 2.4 * player.damageMultiplier;
        if(frameCount%5===0) spawnParticles(this.x, this.y, '#ff4400', 3);
      }
    }
    
    if (this.currentPhase !== undefined && this.currentPhase !== 99 && this.currentPhase > 2) return;
    
    // 3-second stun when a part is destroyed
    if (this.stunTimer > 0) {
        this.stunTimer--;
        spawnParticles(this.x, this.y, '#00ffff', 2);
        return;
    }
    
    let baseSpeedMult = this.slowed ? 0.60 : 1.0;
    let totalEngines = this.parts.filter(p => p.label === 'ENGINE' || p.label === 'PROPELLER').length;
    let aliveEngines = this.parts.filter(p => (p.label === 'ENGINE' || p.label === 'PROPELLER') && !p.isDead).length;
    if (totalEngines > 0) {
        baseSpeedMult *= (0.3 + 0.7 * (aliveEngines / totalEngines));
    }
    
    // Spinning/crashing motion when engines AND guns are dead (phase 2 = hull/core)
    let enginesAllDead = aliveEngines === 0;
    let aliveGuns = this.parts.filter(p => ['GUN','BATTERY','TURRET','CANNON'].includes(p.label) && !p.isDead).length;
    let gunsAllDead = aliveGuns === 0;
    let isSpinning = enginesAllDead && gunsAllDead;
    
    if (this.introPhase) {
        if (this.y < this.targetY) { this.y += 5.0 * baseSpeedMult; } 
        else { this.y = this.targetY; this.introPhase = false; }
    } else if (isSpinning) {
        // Dramatic spinning/crashing motion
        this.spinAngle += 0.05;
        this.x += Math.sin(frameCount * 0.07) * 9 * baseSpeedMult;
        this.y = this.targetY + Math.sin(frameCount * 0.12) * 40 + Math.sin(frameCount * 0.035) * 20;
        spawnParticles(this.x + (Math.random()-0.5)*100, this.y + (Math.random()-0.5)*80, '#ff4400', 3);
    } else {
        if (this.waveNum === 6) {
            this.x += this.speed * 2.5 * this.direction * baseSpeedMult;
            if(this.x < width*0.2 || this.x > width*0.8) this.direction *= -1;
        } else if (this.waveNum === 9) {
            this.x += Math.sin(frameCount * 0.036) * 6.0 * baseSpeedMult;
            this.y = this.targetY + Math.sin(frameCount * 0.060) * 60;
        } else if (this.waveNum === 10) {
            this.x += this.speed * 4.5 * this.direction * baseSpeedMult;
            this.y = this.targetY + Math.sin(frameCount * 0.050) * 80;
            if(this.x < width*0.1 || this.x > width*0.9) { this.direction *= -1; }
        } else {
            this.x += this.speed * 3.5 * this.direction * baseSpeedMult;
            if(this.x < width*0.15 || this.x > width*0.85) { this.direction *= -1; }
        }
    }
    
    // Boss 2 (wave 6): spawn ace pilot - only 1 at a time, 10sec cooldown after destroyed
    if (this.waveNum === 6 && !this.introPhase && !inIntermission) {
        let activeAce = enemies.some(e => e.subType === 'ace' && !e.isCrashing);
        if (!activeAce) {
            this.acePilotTimer++;
            if (this.acePilotTimer >= 600) { // 10 sec cooldown after ace is destroyed
                this.acePilotTimer = 0;
                enemies.push(new Enemy(wave, 'ace_pilot'));
                showNotification("ACE PILOT LAUNCHED!");
            }
        } else {
            this.acePilotTimer = 0; // reset timer while ace is alive
        }
    }
    
    if (!inIntermission && !this.introPhase) {
        this.patternTimer++;
        this.attackPhaseTimer++;
        let numPatterns = this.waveNum === 10 ? 4 : (this.waveNum === 9 ? 5 : (this.waveNum === 6 ? 4 : 3));
        
        let activeGunsCount = this.parts.filter(p => !p.isDead && ['GUN', 'BATTERY', 'TURRET', 'CANNON'].includes(p.label)).length;
        let isRageMode = (this.currentPhase === 1 && activeGunsCount === 1);

        if (this.attackPhaseTimer >= this.attackInterval) {
            this.attackPhaseTimer = 0;
            this.inAttack = true;
            this.attackBurstTimer = 0;
            this.pattern = (this.pattern + 1) % numPatterns;
            // Increased cooldown between attack strikes
            this.attackInterval = this.waveNum === 10 ? 180 + Math.random() * 90 : (this.waveNum === 9 ? 120 + Math.random() * 70 : 110 + Math.random() * 60);
            if (isRageMode) this.attackInterval = 45; 
        }
        
        if (this.inAttack) {
            this.attackBurstTimer++;
            this.fireTimer++;
            
            let fireInterval = this.waveNum === 10 ? (this.pattern === 2 ? 160 : (this.pattern === 1 ? 120 : 80)) : (this.waveNum === 3 ? 26 : (this.waveNum === 6 ? 20 : 16));
            
            if (this.currentPhase === 0) {
                fireInterval *= 6; 
            } else if (isRageMode) {
                fireInterval = 6; 
            } else if (this.currentPhase === 1) {
                fireInterval = Math.max(4, Math.floor(fireInterval * 0.8)); 
            }

            if (this.fireTimer >= fireInterval) { this.fireTimer = 0; this.shoot(); }
            
            let burstDuration = this.waveNum === 10 ? 110 : 90;          
            if (isRageMode) burstDuration = 5; 
            if (this.currentPhase === 0) burstDuration = Math.floor(burstDuration * 1.5); 

            if (this.attackBurstTimer >= burstDuration) { this.inAttack = false; }
        }
    }
  }
  
  shoot() {
    playEnemyGun('tank');
    let angle = Math.atan2(player.y - this.y, player.x - this.x);
    let activeGuns = this.parts.filter(p => !p.isDead && ['GUN', 'BATTERY', 'TURRET', 'CANNON'].includes(p.label));
    
    if (activeGuns.length === 0) return; 
    
    // Helper: get muzzle position at barrel tip (barrel length = part.radius)
    const muzzle = (g) => {
        let cx = this.x + g.relX, cy = this.y + g.relY;
        let ba = Math.atan2(player.y - cy, player.x - cx);
        return { x: cx + Math.cos(ba) * g.radius, y: cy + Math.sin(ba) * g.radius, angle: ba };
    };

    // RAGE MODE - last gun standing: all bosses fire desperately
    if (this.currentPhase === 1 && activeGuns.length === 1) {
        let g = activeGuns[0];
        let m = muzzle(g);
        
        if (this.waveNum === 3) {
            for(let i = -4; i <= 4; i++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle + i*0.1)*13, Math.sin(m.angle + i*0.1)*13, '#ff0000', true, 'NONE', false, 55);
                b.size = 9; bullets.push(b);
            }
        } else if (this.waveNum === 6) {
            for(let i = -2; i <= 2; i++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle + i*0.12)*14, Math.sin(m.angle + i*0.12)*14, '#ff0000', true, 'NONE', false, 90);
                b.size = 13; bullets.push(b);
            }
        } else if (this.waveNum === 9) {
            for(let i = -5; i <= 5; i++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle + i*0.18)*12, Math.sin(m.angle + i*0.18)*12, '#ff6600', true, 'NONE', false, 70);
                b.size = 10; bullets.push(b);
            }
        } else {
            for(let i = -3; i <= 3; i++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle + i*0.12)*14, Math.sin(m.angle + i*0.12)*14, '#ff0000', true, 'NONE', false, 60);
                b.size = 11; bullets.push(b);
            }
        }
        return; 
    }

    if (this.waveNum === 3) {
      // === BOSS 1: IRON HAWK - Volume of bullets ===
      if (this.currentPhase === 0) {
        activeGuns.forEach(g => {
            let m = muzzle(g);
            // Phase 0: 2√ó firepower = 2 shots per gun
            for (let s = 0; s < 2; s++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle + (s-0.5)*0.15)*8, Math.sin(m.angle + (s-0.5)*0.15)*8, '#88ff88', true, 'NONE', false, 35); b.size=7; bullets.push(b);
            }
        });
      } else if (this.pattern === 0) {
        activeGuns.forEach(g => {
            let m = muzzle(g);
            for(let i=-2; i<=2; i++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle+i*0.14)*10, Math.sin(m.angle+i*0.14)*10, '#ffaa00', true, 'NONE', false, 50); b.size=8; bullets.push(b);
            }
        });
      } else if (this.pattern === 1) {
        activeGuns.forEach(g => {
            let m = muzzle(g);
            for (let i=-1; i<=1; i++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle+i*0.2)*11, Math.sin(m.angle+i*0.2)*11, '#ff3300', true, 'NONE', false, 55); b.size=8; bullets.push(b);
            }
        });
      } else if (this.pattern === 2) {
        activeGuns.forEach(g => {
            let m = muzzle(g);
            let b = new Bullet(m.x, m.y, Math.cos(m.angle)*12, Math.sin(m.angle)*12, '#ff6600', true, 'NONE', false, 70, {isMissile:true}); b.size=11; bullets.push(b);
        });
      }
    } else if (this.waveNum === 6) {
      // === BOSS 2: STEEL CARRIER - Accurate heavy hits ===
      if (this.currentPhase === 0) {
        // Phase 0: 2√ó = 2 shots per battery
        activeGuns.forEach(g => {
            let m = muzzle(g);
            for (let s = -1; s <= 1; s += 2) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle+s*0.1)*10, Math.sin(m.angle+s*0.1)*10, '#88ff88', true, 'NONE', false, 40); b.size=8; bullets.push(b);
            }
        });
      } else if (this.pattern === 0) {
        activeGuns.forEach(g => {
            let m = muzzle(g);
            let b = new Bullet(m.x, m.y, Math.cos(m.angle)*12, Math.sin(m.angle)*12, '#ffcc00', true, 'NONE', false, 70); b.size=11; bullets.push(b);
        });
      } else if (this.pattern === 1) {
        activeGuns.forEach((g) => {
            let m = muzzle(g);
            let b = new Bullet(m.x, m.y, Math.cos(m.angle)*11, Math.sin(m.angle)*11, '#ff4400', true, 'NONE', false, 100, {isMissile:true}); b.size=11; bullets.push(b);
        });
      } else if (this.pattern === 2) {
        activeGuns.forEach(g => {
            let m = muzzle(g);
            for (let i=-1; i<=1; i++) {
              let b = new Bullet(m.x, m.y, Math.cos(m.angle+i*0.18)*11, Math.sin(m.angle+i*0.18)*11, '#00ffff', true, 'NONE', false, 55); b.size=8; bullets.push(b);
            }
        });
      } else if (this.pattern === 3) {
        activeGuns.forEach(g => {
          let m = muzzle(g);
          let b = new Bullet(m.x, m.y, Math.cos(m.angle)*13, Math.sin(m.angle)*13, '#ff8800', true, 'NONE', false, 85); b.size=13; bullets.push(b);
        });
      }
    } else if (this.waveNum === 9) {
      // === BOSS 3: DOOM ZEPPELIN - Shotgun type ===
      activeGuns.forEach((g, gIdx) => {
          let m = muzzle(g);
          
          if (this.currentPhase === 0) {
            // Phase 0: 2√ó = both even AND odd guns fire (all fire, was every other)
            let b = new Bullet(m.x, m.y, Math.cos(m.angle)*9, Math.sin(m.angle)*9, '#88ff88', true, 'NONE', false, 35); b.size=7; bullets.push(b);
          } else if (this.pattern === 0) {
            if (gIdx % 2 !== 0) return;
            for(let i=-1; i<=1; i++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle+i*0.28)*9, Math.sin(m.angle+i*0.28)*9, '#ff0000', true, 'NONE', false, 80); b.size=10; bullets.push(b);
            }
          } else if (this.pattern === 1) {
            if (gIdx % 2 === 0) return;
            for(let i=-1; i<=1; i++) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle+i*0.30)*8, Math.sin(m.angle+i*0.30)*8, '#ff6600', true, 'NONE', false, 65, {isMissile:true}); b.size=11; bullets.push(b);
            }
          } else if (this.pattern === 2) {
            for (let i=-1; i<=1; i++) {
                if (gIdx % 2 !== 0 && i !== 0) continue;
                let b = new Bullet(m.x, m.y, Math.cos(m.angle+i*0.24)*9, Math.sin(m.angle+i*0.24)*9, '#ff2200', true, 'NONE', false, 70); b.size=9; bullets.push(b);
            }
          } else if (this.pattern === 3) {
            let b = new Bullet(m.x, m.y, Math.cos(m.angle)*13, Math.sin(m.angle)*13, '#ffcc00', true, 'NONE', false, 80); b.size=10; bullets.push(b);
          } else {
            if (gIdx % 2 !== 0) return;
            let b = new Bullet(m.x, m.y, Math.cos(m.angle)*9, Math.sin(m.angle)*9, '#ff8800', true, 'NONE', false, 95, {isMissile:true}); b.size=13; bullets.push(b);
          }
      });
    } else if (this.waveNum === 10) {
        activeGuns.forEach((g, idx) => {
            let m = muzzle(g);

            if (this.currentPhase === 0) {
                // Phase 0: 2√ó = all cannons fire regardless of idx
                let b = new Bullet(m.x, m.y, Math.cos(m.angle)*7, Math.sin(m.angle)*7, '#ff0000', true, 'NONE', false, 60);
                b.size = 9; bullets.push(b);
            } else if (this.pattern === 0) {
                let b = new Bullet(m.x, m.y, Math.cos(m.angle)*7, Math.sin(m.angle)*7, '#ff0000', true, 'NONE', false, 60);
                b.size = 9; bullets.push(b);
            } else if (this.pattern === 1) {
                if (idx % 2 === 0) {
                    let b = new Bullet(m.x, m.y, Math.cos(m.angle)*3.5, Math.sin(m.angle)*3.5, '#ff8800', true, 'NONE', true, 90, { bigExplosion: true });
                    b.size = 18; bullets.push(b);
                }
            } else if (this.pattern === 2) {
                if (idx === 0 || idx === activeGuns.length - 1) {
                    enemies.push(new Enemy(wave, 'boss_missile', m.x, m.y));
                }
            } else {
                if (idx % 2 !== 0) {
                    let b = new Bullet(m.x, m.y, Math.cos(m.angle)*6, Math.sin(m.angle)*6, '#ff0000', true, 'NONE', false, 60);
                    b.size = 9; bullets.push(b);
                } else if (Math.random() < 0.5) {
                    let b = new Bullet(m.x, m.y, Math.cos(m.angle)*3, Math.sin(m.angle)*3, '#ff8800', true, 'NONE', true, 90, { bigExplosion: true });
                    b.size = 18; bullets.push(b);
                }
            }
        });
    }
  }
  
  draw() {
    ctx.save(); ctx.translate(this.x, this.y);
    
    // Spin dramatically when engines AND guns are both destroyed
    let _aliveEng = this.parts.filter(p => (p.label === 'ENGINE' || p.label === 'PROPELLER') && !p.isDead).length;
    let _aliveGun = this.parts.filter(p => ['GUN','BATTERY','TURRET','CANNON'].includes(p.label) && !p.isDead).length;
    if (_aliveEng === 0 && _aliveGun === 0 && !this.isCrashing) {
        ctx.rotate(this.spinAngle || 0);
    }
    
    if (this.isCrashing) {
        let crashScale = Math.max(0.01, 1 - (75 - this.crashTimer)/75);
        ctx.scale(crashScale, crashScale);
        ctx.rotate(Math.sin(this.crashTimer * 0.1) * 0.2);
    }

    if (this.waveNum === 10) {
      ctx.shadowBlur = 30; ctx.shadowColor = '#ff0000';
      ctx.fillStyle = '#1a0000';
      ctx.beginPath(); ctx.ellipse(0, 0, 250, 140, 0, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#ff2200'; ctx.lineWidth = 3; ctx.stroke();
      [-230,-150,150,230].forEach(ox => {
        ctx.fillStyle = '#110000'; ctx.fillRect(ox > 0 ? ox-10 : ox, -25, 20, 130);
        ctx.strokeStyle = '#882200'; ctx.lineWidth = 1.5; ctx.strokeRect(ox > 0 ? ox-10 : ox, -25, 20, 130);
      });
      ctx.fillStyle = '#2a0000'; ctx.fillRect(-100, -130, 200, 40);
      ctx.strokeStyle = '#ff4400'; ctx.lineWidth = 2; ctx.strokeRect(-100,-130,200,40);
      const pulse = Math.sin(frameCount * 0.3) * 0.5 + 0.5;
      ctx.shadowBlur = 40 * pulse; ctx.shadowColor = '#ff0000';
      ctx.fillStyle = `rgba(255,${Math.floor(50*pulse)},0,0.6)`;
      ctx.beginPath(); ctx.arc(0, 10, 45, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#660000'; ctx.lineWidth = 1;
      for (let i=-200; i<=200; i+=80) { ctx.beginPath(); ctx.moveTo(i,-100); ctx.lineTo(i,120); ctx.stroke(); }
    } else if (this.waveNum === 3) {
      // IRON HAWK: Aggressive hawk-shaped fighter, swept wings, twin nacelles
      ctx.shadowBlur = 20; ctx.shadowColor = '#44ff44';
      // Main fuselage ‚Äî elongated hawk body
      ctx.fillStyle = '#1a3a1a';
      ctx.beginPath();
      ctx.moveTo(0, -120);   // nose
      ctx.lineTo(30, -60);
      ctx.lineTo(50, 80);
      ctx.lineTo(-50, 80);
      ctx.lineTo(-30, -60);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = '#336633'; ctx.lineWidth = 2; ctx.stroke();
      // Swept wings (hawk shape)
      ctx.fillStyle = '#122a12';
      ctx.beginPath(); ctx.moveTo(-40, -20); ctx.lineTo(-220, 50); ctx.lineTo(-200, 90); ctx.lineTo(-40, 60); ctx.closePath(); ctx.fill();
      ctx.strokeStyle = '#224422'; ctx.lineWidth = 1.5; ctx.stroke();
      ctx.beginPath(); ctx.moveTo(40, -20); ctx.lineTo(220, 50); ctx.lineTo(200, 90); ctx.lineTo(40, 60); ctx.closePath(); ctx.fill();
      ctx.stroke();
      // Wing-tip gun pods (phase 1 guns are at tips)
      [-200, 200].forEach(wx => {
          ctx.fillStyle = '#1a4a1a';
          ctx.beginPath(); ctx.ellipse(wx, 65, 20, 35, 0, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = '#44aa44'; ctx.lineWidth = 1.5; ctx.stroke();
      });
      // Twin rear engines
      ctx.fillStyle = '#0d200d';
      ctx.fillRect(-55, 60, 38, 50); ctx.strokeStyle = '#335533'; ctx.lineWidth = 2; ctx.strokeRect(-55, 60, 38, 50);
      ctx.fillRect(17, 60, 38, 50); ctx.strokeRect(17, 60, 38, 50);
      // Cockpit
      ctx.fillStyle = '#2a6a2a';
      ctx.beginPath(); ctx.ellipse(0, -60, 18, 30, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#88ff88'; ctx.beginPath(); ctx.ellipse(-3, -68, 7, 12, 0, 0, Math.PI*2); ctx.fill();
      // Fuselage detail lines
      ctx.strokeStyle = '#336633'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(-20, -40); ctx.lineTo(-30, 70); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(20, -40); ctx.lineTo(30, 70); ctx.stroke();
    } else if (this.waveNum === 6) {
      // STEEL CARRIER: Wide armored carrier with bridge tower, armored hull plates
      ctx.shadowBlur = 20; ctx.shadowColor = '#4488ff';
      // Main carrier deck ‚Äî wide flat armored hull
      ctx.fillStyle = '#0d1e2e';
      ctx.beginPath();
      ctx.moveTo(-240, -70); ctx.lineTo(240, -70);
      ctx.lineTo(260, 0); ctx.lineTo(240, 80);
      ctx.lineTo(-240, 80); ctx.lineTo(-260, 0);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = '#1a3a5a'; ctx.lineWidth = 2; ctx.stroke();
      // Armored hull plates / panels
      ctx.strokeStyle = '#224466'; ctx.lineWidth = 1;
      for (let i = -200; i <= 200; i += 80) {
          ctx.strokeRect(i - 35, -60, 70, 130);
      }
      // Side sponsons (gun mount housings) 
      ctx.fillStyle = '#0a1825';
      ctx.fillRect(-270, -30, 40, 100); ctx.strokeStyle = '#1a3a5a'; ctx.lineWidth = 1.5; ctx.strokeRect(-270, -30, 40, 100);
      ctx.fillRect(230, -30, 40, 100); ctx.strokeRect(230, -30, 40, 100);
      // Bridge tower
      ctx.fillStyle = '#172636';
      ctx.fillRect(-45, -140, 90, 80);
      ctx.strokeStyle = '#2a4a6a'; ctx.lineWidth = 2; ctx.strokeRect(-45, -140, 90, 80);
      ctx.fillStyle = '#0d1e30'; ctx.fillRect(-30, -150, 60, 20); ctx.strokeRect(-30, -150, 60, 20);
      // Bridge windows
      for (let wx = -35; wx <= 35; wx += 20) {
          ctx.fillStyle = '#2266aa'; ctx.fillRect(wx, -130, 12, 8);
      }
      // Antenna mast
      ctx.strokeStyle = '#3a6a9a'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(0, -150); ctx.lineTo(0, -190); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-20, -170); ctx.lineTo(20, -170); ctx.stroke();
      // Deck markings
      ctx.strokeStyle = '#336688'; ctx.lineWidth = 1; ctx.setLineDash([15, 10]);
      ctx.beginPath(); ctx.moveTo(-230, 10); ctx.lineTo(230, 10); ctx.stroke();
      ctx.setLineDash([]);
    } else if (this.waveNum === 9) {
      // DOOM ZEPPELIN: Massive armored airship with gondola, ribs, tail fins
      ctx.shadowBlur = 20; ctx.shadowColor = '#ff6600';
      // Main envelope (blimp body)
      ctx.fillStyle = '#2a1008';
      ctx.beginPath(); ctx.ellipse(0, -15, 200, 105, 0, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#662211'; ctx.lineWidth = 2; ctx.stroke();
      // Envelope structural ribs
      ctx.strokeStyle = '#441a08'; ctx.lineWidth = 1.5;
      for (let i = -4; i <= 4; i++) { 
          ctx.beginPath(); ctx.ellipse(0, -15, 200, 105, i * 0.22, 0, Math.PI*2); ctx.stroke();
      }
      // Nose cone detail
      ctx.fillStyle = '#3a1a0a';
      ctx.beginPath(); ctx.ellipse(-195, -15, 12, 30, 0, 0, Math.PI*2); ctx.fill();
      // Gondola (belly of the ship)
      ctx.fillStyle = '#1a0808';
      ctx.beginPath();
      ctx.moveTo(-100, 75); ctx.lineTo(100, 75);
      ctx.lineTo(110, 110); ctx.lineTo(80, 130); ctx.lineTo(-80, 130); ctx.lineTo(-110, 110);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = '#ff4400'; ctx.lineWidth = 1.5; ctx.stroke();
      // Gondola windows
      for (let wx = -70; wx <= 70; wx += 35) {
          ctx.fillStyle = '#ff2200'; ctx.beginPath(); ctx.arc(wx, 100, 7, 0, Math.PI*2); ctx.fill();
      }
      // Side fins
      ctx.fillStyle = '#220a00';
      ctx.beginPath(); ctx.moveTo(-190, 20); ctx.lineTo(-240, -40); ctx.lineTo(-240, 50); ctx.closePath(); ctx.fill();
      ctx.strokeStyle = '#441100'; ctx.stroke();
      ctx.beginPath(); ctx.moveTo(190, 20); ctx.lineTo(240, -40); ctx.lineTo(240, 50); ctx.closePath(); ctx.fill();
      ctx.stroke();
      // Tail fins (top)
      ctx.fillStyle = '#1a0600';
      ctx.beginPath(); ctx.moveTo(-80, -95); ctx.lineTo(-120, -140); ctx.lineTo(-60, -95); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(80, -95); ctx.lineTo(120, -140); ctx.lineTo(60, -95); ctx.closePath(); ctx.fill();
      // Engine nacelles on gondola
      ctx.fillStyle = '#0a0808';
      ctx.fillRect(-120, 88, 30, 25); ctx.strokeStyle = '#ff4400'; ctx.lineWidth = 1; ctx.strokeRect(-120, 88, 30, 25);
      ctx.fillRect(90, 88, 30, 25); ctx.strokeRect(90, 88, 30, 25);
    }
    
    for (let part of this.parts) {
      ctx.save(); ctx.translate(part.relX, part.relY);
      if (part.isDead) {
          ctx.fillStyle = '#1a1a1a';
          if (frameCount % 8 === 0) spawnParticles(this.x + part.relX, this.y + part.relY, '#ff4400', 2);
      } else {
          const isCurrentTarget = (part.phase === this.currentPhase);
          ctx.fillStyle = part.isDead ? '#111' : (isCurrentTarget ? part.color : '#444455');
      }
      
      if (part.label === 'ENGINE' || part.label === 'PROPELLER') {
          ctx.beginPath(); ctx.arc(0, 0, part.radius, 0, Math.PI*2); ctx.fill();
      } else if (part.label === 'GUN' || part.label === 'BATTERY' || part.label === 'TURRET' || part.label === 'CANNON') {
          ctx.fillRect(-part.radius*0.7, -part.radius*0.7, part.radius*1.4, part.radius*1.4);
          // Barrel always visible ‚Äî tracks player when alive, spins when dead
          const barrelAngle = Math.atan2(player.y-(this.y+part.relY), player.x-(this.x+part.relX));
          ctx.save();
          if (part.isDead) {
              // Spinning-out-of-control destroyed turret
              if (!part._spinAngle) part._spinAngle = 0;
              part._spinAngle += 0.12;
              ctx.rotate(part._spinAngle);
              ctx.fillStyle = '#444'; ctx.fillRect(-4, -part.radius, 8, part.radius * 0.8);
          } else {
              ctx.rotate(barrelAngle + Math.PI/2); // +PI/2 because barrel rect points UP at default
              ctx.fillStyle = part.phase === this.currentPhase ? '#888' : '#555';
              ctx.fillRect(-4, -part.radius, 8, part.radius);
          }
          ctx.restore();
      } else { 
          ctx.beginPath(); ctx.arc(0, 0, part.radius*0.6, 0, Math.PI*2); ctx.fill();
      }
      

// VISUAL TARGET INDICATOR
             if (!part.isDead && part.phase === this.currentPhase) {
          ctx.save();
          // Gebruik cyaan voor Boss 10 omdat de boss zelf al rood is!
          let crossColor = this.waveNum === 10 ? '#00ffff' : '#ff0000';
          ctx.strokeStyle = crossColor; 
          ctx.lineWidth = 4;
          ctx.shadowColor = crossColor;
          ctx.shadowBlur = 15;
          ctx.setLineDash([12, 12]);
          ctx.lineDashOffset = -frameCount * 1.5; // Draait lekker snel
          ctx.beginPath();
          let glowRadius = part.radius + 15 + Math.sin(frameCount * 0.2) * 5;
          ctx.arc(0, 0, glowRadius, 0, Math.PI*2);
          ctx.stroke();
          
          ctx.setLineDash([]);
          ctx.lineWidth = 3;
          let crossLen = 16;
          ctx.beginPath();
          ctx.moveTo(0, -glowRadius - crossLen); ctx.lineTo(0, -glowRadius - 4);
          ctx.moveTo(0, glowRadius + 4); ctx.lineTo(0, glowRadius + crossLen);
          ctx.moveTo(-glowRadius - crossLen, 0); ctx.lineTo(-glowRadius - 4, 0);
          ctx.moveTo(glowRadius + 4, 0); ctx.lineTo(glowRadius + crossLen, 0);
          ctx.stroke();
          ctx.restore();
      }
      ctx.restore();
    }
    
    if(this.slowed) { ctx.fillStyle = 'rgba(0,100,255,0.15)'; ctx.beginPath(); ctx.arc(0,0,260,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
}

class SecretBoss {
  constructor() {
    this.isBoss = true; this.isSecret = true; 
    let opMult = 1 + (currentWeaponTier * 0.15);
    this.name = "EUGENBURG DOOM-ENTITY";
    this.currentPhase = 0; 
    this.isCrashing = false; this.crashTimer = 0;
    
    this.parts = [];
    let totalBossHp = 0;
    
    // Phase 0: 4 Engines (2 aan elke zijkant - Tank Treads)
    let engineHp = 6000 * opMult;
    this.parts.push({id:'eng_tl', relX:-130, relY:-30, hp:engineHp, maxHp:engineHp, radius:28, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    this.parts.push({id:'eng_bl', relX:-130, relY:50, hp:engineHp, maxHp:engineHp, radius:28, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    this.parts.push({id:'eng_tr', relX:130, relY:-30, hp:engineHp, maxHp:engineHp, radius:28, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    this.parts.push({id:'eng_br', relX:130, relY:50, hp:engineHp, maxHp:engineHp, radius:28, color:'#335533', isDead:false, phase:0, label:'ENGINE'});
    totalBossHp += engineHp * 4;
    
    // Phase 1: E√©n Massieve Centrale Turret
    let gunHp = 10000 * opMult;
    this.parts.push({id:'turret', relX:0, relY:-20, hp:gunHp, maxHp:gunHp, radius:55, color:'#ff8800', isDead:false, phase:1, label:'GUN'});
    totalBossHp += gunHp;
    
    // Phase 2: Core (center)
    let coreHp = 2333 * opMult;
    this.parts.push({id:'core', relX:0, relY:0, hp:coreHp, maxHp:coreHp, radius:70, color:'#ff2200', isDead:false, phase:2, label:'CORE'});
    totalBossHp += coreHp;
    
    this.hp = totalBossHp; this.maxHp = totalBossHp;
    this.x = width / 2; this.y = -300;
    this.targetY = 180;
    this.introPhase = true;
    this.speed = 3.5; this.burnTimer = 0; this.hitCount = 0; this.slowed = false;
    this.direction = 1;
    this.stunTimer = 0; this.spinAngle = 0;
    this.missileBurstCount = 0; this.missileBurstTimer = 0; this.missileReady = true;
    this.bombTimer = 0;
  }
  
  checkCurrentPhase() {
    let phaseParts = this.parts.filter(p => p.phase === this.currentPhase && !p.isDead);
    if (phaseParts.length === 0) {
      const prevPhase = this.currentPhase;
      this.currentPhase++;
      if (prevPhase === 0) {
        this.stunTimer = 120; // 2-second stun on engine clear
      }
      if (this.currentPhase === 1) { 
        showNotification("TREADS DOWN! DESTROY THE TURRET!"); cameraShake = 20; 
      }
      else if (this.currentPhase === 2) { 
        showNotification("TURRET DOWN! TARGET THE CORE!"); cameraShake = 30; 
      }
    }
  }
  
  update() {
    if (this.isCrashing) {
        this.crashTimer--;
        this.y += 3.0;
        this.x += Math.sin(this.crashTimer * 0.2) * 5;
        spawnParticles(this.x + (Math.random()-0.5)*150, this.y + (Math.random()-0.5)*150, '#ff4400', 10);
        spawnParticles(this.x + (Math.random()-0.5)*150, this.y, '#222222', 15);
        if (this.crashTimer <= 0) { finalizeKillEnemy(this); }
        return;
    }

    if (this.burnTimer > 0) { 
      this.burnTimer--; 
      if (this.currentPhase <= 2) {
        let activeParts = this.parts.filter(p => p.phase === this.currentPhase && !p.isDead);
        if (activeParts.length > 0) {
          let burnTarget = activeParts[Math.floor(Math.random() * activeParts.length)];
          burnTarget.hp -= 2.4 * player.damageMultiplier;
          if(frameCount%5===0) spawnParticles(this.x + burnTarget.relX, this.y + burnTarget.relY, '#ff4400', 3);
          if (burnTarget.hp <= 0) { burnTarget.isDead = true; burnTarget.hp = 0; this.checkCurrentPhase(); }
        }
      }
    }
    
    if (this.currentPhase > 2) return;
    
    if (this.stunTimer > 0) {
        this.stunTimer--;
        spawnParticles(this.x, this.y, '#00ffff', 2);
        return;
    }
    
    let baseSpeedMult = this.slowed ? 0.60 : 1.0;
    let totalEngines = this.parts.filter(p => p.label === 'ENGINE').length;
    let aliveEngines = this.parts.filter(p => p.label === 'ENGINE' && !p.isDead).length;
    if (totalEngines > 0) {
        baseSpeedMult *= (0.3 + 0.7 * (aliveEngines / totalEngines));
    }
    
    let aliveGuns = this.parts.filter(p => p.label === 'GUN' && !p.isDead).length;
    let isSpinning = aliveEngines === 0 && aliveGuns === 0;
    
    if (this.introPhase) {
        if (this.y < this.targetY) { this.y += 5.0 * baseSpeedMult; } 
        else { this.y = this.targetY; this.introPhase = false; }
    } else if (isSpinning) {
        // Dramatic crashing spin for the WHOLE SHIP
        this.spinAngle += 0.04;
        this.x += Math.sin(frameCount * 0.09) * 10 * baseSpeedMult;
        this.y = this.targetY + Math.sin(frameCount * 0.15) * 50 + Math.sin(frameCount * 0.04) * 25;
        spawnParticles(this.x + (Math.random()-0.5)*120, this.y + (Math.random()-0.5)*100, '#ff4400', 3);
    } else {
        // Figure-8 ‚Äî use self-tracked time so stun/phase-changes don't teleport the ship
        if (this.moveT === undefined) {
            // Initialise t so the figure-8 starts from current x position instead of center
            this.moveT = Math.asin(Math.max(-1, Math.min(1, (this.x - width/2) / (width * 0.35))));
        }
        this.moveT += 0.025 * baseSpeedMult;
        this.x = width/2 + Math.sin(this.moveT) * (width * 0.35);
        this.y = this.targetY + Math.sin(this.moveT * 2) * 60;
    }
    
    if (!inIntermission && !this.introPhase) {
        let turretAlive = this.parts.some(p => p.label === 'GUN' && !p.isDead);
        
        if (turretAlive) {
            // Turret alive: fire missiles
            this.missileBurstTimer++;
            if (this.missileReady && this.missileBurstTimer >= 60) {
                this.missileReady = false;
                this.missileBurstCount = 0;
                this.missileBurstTimer = 0;
            }
            if (!this.missileReady) {
                if (this.missileBurstCount < 1 && this.missileBurstTimer % 12 === 0) {
                    this.shootMissile();
                    this.missileBurstCount++;
                    if (this.missileBurstCount >= 1) {
                        this.missileReady = true;
                        this.missileBurstTimer = 0;
                    }
                }
            }
        }
        
        if (aliveEngines === 0 && turretAlive) {
            // Engines dead AND turret alive: drop bombs
            this.bombTimer++;
            if (this.bombTimer >= 300) {
                this.bombTimer = 0;
                this.dropBombs();
            }
        }
        // When turret is dead, no attacks ‚Äî only core exposed
    }
  }
  
shootMissile() {
    playEnemyGun('missile');
    let activeGuns = this.parts.filter(p => !p.isDead && p.label === 'GUN');
    // Als de turret nog leeft schieten we daaruit, anders uit de core
    let fireParts = activeGuns.length > 0 ? activeGuns : this.parts.filter(p => p.label === 'CORE');
    
    fireParts.forEach(g => {
        let bx = this.x + g.relX; 
        let by = this.y + g.relY;
        let ba = Math.atan2(player.y - by, player.x - bx);
        
        // We maken 4 raketten aan
        for (let i = 0; i < 4; i++) {
            // De 'spread' bepaalt de afstand tussen de raketten. 
            // -150, -50, 50, 150 zorgt voor een breedte van 300 pixels totaal.
            let offset = -150 + (i * 100); 
            
            // Bereken de positie loodrecht op de schietrichting zodat ze netjes naast elkaar staan
            let spawnX = bx + Math.cos(ba + Math.PI/2) * offset;
            let spawnY = by + Math.sin(ba + Math.PI/2) * offset;

            let b = new Bullet(
                spawnX, 
                spawnY, 
                Math.cos(ba) * 32, // Snelheid (20% slomer dan de originele 40)
                Math.sin(ba) * 32, 
                '#ff6600', 
                true, 
                'NONE', 
                false, 
                120, 
                {isMissile: true, wobbleRocket: true}
            );
            
            b.size = 60; // Bijna zo groot als het spelersschip
            bullets.push(b);
        }
    });
  }
  
  dropBombs() {
    let numBombs = 2 + Math.floor(Math.random() * 2);
    for (let i = 0; i < numBombs; i++) {
        let bx = this.x + (Math.random() - 0.5) * 200;
        let by = this.y + 20;
        let b = new Bullet(bx, by, (Math.random()-0.5)*2, 10, '#ff3300', true, 'NONE', true, 110, {isBomb: true});
        b.size = 40; bullets.push(b);
    }
  }
  
  draw() {
    ctx.save(); ctx.translate(this.x, this.y);
    
    // De body tolt wanneer phase 2 aan is.
    let _sbEngAlive = this.parts.filter(p => p.label === 'ENGINE' && !p.isDead).length;
    let _sbGunAlive = this.parts.filter(p => p.label === 'GUN' && !p.isDead).length;
    if (_sbEngAlive === 0 && _sbGunAlive === 0 && !this.isCrashing) {
        ctx.rotate(this.spinAngle || 0);
    }
    
    if (this.isCrashing) {
        let crashScale = Math.max(0.01, 1 - (75 - this.crashTimer)/75);
        ctx.scale(crashScale, crashScale);
        ctx.rotate(Math.sin(this.crashTimer * 0.1) * 0.2);
    }
    
    // --- NIEUW: Flying Tank Visuals ---
    ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000';
    
    // Tank chassis
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-110, -90, 220, 180); 
    ctx.strokeStyle = '#551111'; ctx.lineWidth = 4; ctx.strokeRect(-110, -90, 220, 180);
    
    // Front armor slope
    ctx.fillStyle = '#220000';
    ctx.beginPath(); ctx.moveTo(-110, 90); ctx.lineTo(-80, 130); ctx.lineTo(80, 130); ctx.lineTo(110, 90); ctx.closePath(); ctx.fill();
    ctx.stroke();
    
    // Treads (De bases voor de zij-engines)
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(-150, -70, 40, 140); 
    ctx.fillRect(110, -70, 40, 140);  
    ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
    ctx.strokeRect(-150, -70, 40, 140);
    ctx.strokeRect(110, -70, 40, 140);
    
    // Teken alle onderdelen
    for (let part of this.parts) {
      ctx.save(); ctx.translate(part.relX, part.relY);
      
      if (part.isDead && part.label !== 'GUN') {
          ctx.fillStyle = '#1a1a1a';
          if (frameCount % 8 === 0) spawnParticles(this.x + part.relX, this.y + part.relY, '#ff4400', 2);
      } else {
          const isCurrentTarget = (part.phase === this.currentPhase);
          ctx.fillStyle = part.isDead ? '#111' : (isCurrentTarget ? part.color : '#444455');
      }
      
      if (part.label === 'ENGINE') {
          if (!part.isDead) {
              ctx.beginPath(); ctx.arc(0, 0, part.radius, 0, Math.PI*2); ctx.fill();
              ctx.fillStyle = '#00ff66'; ctx.beginPath(); ctx.arc(0, 0, part.radius*0.4, 0, Math.PI*2); ctx.fill();
          }
      } else if (part.label === 'GUN') {
          // --- TANK TURRET: always visible ---
          if (part.isDead) {
              // Spinning out of control
              if (!part._spinAngle) part._spinAngle = 0;
              part._spinAngle += 0.18;
              ctx.save(); ctx.rotate(part._spinAngle);
              ctx.fillStyle = '#2a2a2a';
              ctx.beginPath(); ctx.arc(0, 0, part.radius, 0, Math.PI*2); ctx.fill(); 
              ctx.fillStyle = '#111'; ctx.fillRect(-15, 0, 30, part.radius + 50);
              ctx.restore();
          } else {
              ctx.beginPath(); ctx.arc(0, 0, part.radius, 0, Math.PI*2); ctx.fill();
              ctx.strokeStyle = '#555'; ctx.lineWidth = 5; ctx.stroke();
              // Barrel always visible, tracks player
              const barrelAngle = Math.atan2(player.y-(this.y+part.relY), player.x-(this.x+part.relX));
              ctx.save(); ctx.rotate(barrelAngle - Math.PI/2); // barrel rect extends in +y, so subtract PI/2
              ctx.fillStyle = part.phase === this.currentPhase ? '#444' : '#2a2a2a';
              ctx.fillRect(-20, -part.radius, 40, part.radius + 60);
              ctx.fillStyle = '#111'; ctx.fillRect(-25, part.radius + 40, 50, 25);
              ctx.restore();
          }
      } else if (part.label === 'CORE') {
          if (!part.isDead) {
              ctx.beginPath(); ctx.arc(0, 0, part.radius, 0, Math.PI*2); ctx.fill();
          }
      }
      
      // VISUAL TARGET INDICATOR
      if (!part.isDead && part.phase === this.currentPhase) {
          ctx.save();
          let crossColor = '#ff00ff';
          ctx.strokeStyle = crossColor; 
          ctx.lineWidth = 4;
          ctx.shadowColor = crossColor;
          ctx.shadowBlur = 15;
          ctx.setLineDash([12, 12]);
          ctx.lineDashOffset = -frameCount * 1.5;
          ctx.beginPath();
          let glowRadius = part.radius + 15 + Math.sin(frameCount * 0.2) * 5;
          ctx.arc(0, 0, glowRadius, 0, Math.PI*2);
          ctx.stroke();
          
          ctx.setLineDash([]);
          ctx.lineWidth = 3;
          let crossLen = 16;
          ctx.beginPath();
          ctx.moveTo(0, -glowRadius - crossLen); ctx.lineTo(0, -glowRadius - 4);
          ctx.moveTo(0, glowRadius + 4); ctx.lineTo(0, glowRadius + crossLen);
          ctx.moveTo(-glowRadius - crossLen, 0); ctx.lineTo(-glowRadius - 4, 0);
          ctx.moveTo(glowRadius + 4, 0); ctx.lineTo(glowRadius + crossLen, 0);
          ctx.stroke();
          ctx.restore();
      }
      ctx.restore();
    }
    
    if(this.slowed) { ctx.fillStyle = 'rgba(0,100,255,0.15)'; ctx.beginPath(); ctx.arc(0,0,260,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
}

class Bullet {
  constructor(x, y, vx, vy, color, isEnemy, element = 'NONE', explosive = false, damage = 10, special = {}) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.color = color; this.isEnemy = isEnemy; this.element = element; this.explosive = explosive;
    this.marked = false; this.size = isEnemy ? (explosive && special && special.bigExplosion ? 18 : 7) : (explosive ? 6 : 4.5); this.life = 55; this.damage = damage;
    this.special = special; this.hitList = new Set();
  }
update() {
    if (this.special && this.special.homing && !this.isEnemy) {
        let nearest = null; let minDist = 400;
        enemies.forEach(e => { let d = Math.hypot(this.x - e.x, this.y - e.y); if (d < minDist && !e.isCrashing) { minDist = d; nearest = e; } });
        if (nearest) {
            let tA = Math.atan2(nearest.y - this.y, nearest.x - this.x);
            let cA = Math.atan2(this.vy, this.vx);
            let diff = tA - cA;
            while (diff > Math.PI) diff -= Math.PI * 2; while (diff < -Math.PI) diff += Math.PI * 2;
            cA += diff * 0.30; 
            let spd = Math.hypot(this.vx, this.vy);
            this.vx = Math.cos(cA) * spd; this.vy = Math.sin(cA) * spd;
        }
    }

// --- NIEUW: Wobble Rocket logica (schommelt rond zijn basis-lijn) ---
    if (this.special && this.special.wobbleRocket) {
        if (this.special.baseAngle === undefined) {
            this.special.baseAngle = Math.atan2(this.vy, this.vx);
            this.special.baseSpeed = Math.hypot(this.vx, this.vy);
            // Gebruik de X-positie voor een unieke variatie per raket
            this.special.curveTime = (this.x * 0.5); 
        }
        this.special.curveTime += 0.35;
        
        // De 'wobble' (recoil effect)
        let currentAngle = this.special.baseAngle + Math.sin(this.special.curveTime) * 0.2;
        
        this.vx = Math.cos(currentAngle) * this.special.baseSpeed;
        this.vy = Math.sin(currentAngle) * this.special.baseSpeed;
    }

    this.x += this.vx; this.y += this.vy; if (!this.isEnemy) this.life--;
    
    if (this.special && this.special.isMissile && frameCount % 4 === 0) {
        let trailSize = this.size > 40 ? 4 : 2;
        spawnParticles(this.x, this.y - 10, '#aaaaaa', trailSize); spawnParticles(this.x, this.y - 12, '#ff4400', trailSize/2);
    }
    if (this.special && this.special.isBomb && frameCount % 6 === 0) {
        spawnParticles(this.x, this.y, '#ff6600', 3); spawnParticles(this.x, this.y, '#ffaa00', 2);
    }

    if (this.x < -60 || this.x > width+60 || this.y < -60 || this.y > height+60 || (!this.isEnemy && this.life <= 0)) {
      if (this.explosive && !this.isEnemy) {
        spawnParticles(this.x, this.y, this.color, 48);
        // ... (rest van je originele explosie logica blijft hetzelfde hieronder)
        enemies.forEach(other => { 
            if (other.isCrashing) return;
            if (other.isBoss) {
                for (let part of other.parts) {
                    if (!part.isDead && Math.hypot(this.x - (other.x + part.relX), this.y - (other.y + part.relY)) < 115) {
                        part.hp -= this.damage * 1.7;
                        if (part.hp <= 0) { part.isDead = true; part.hp = 0; spawnParticles(other.x + part.relX, other.y + part.relY, '#ffaa00', 80); }
                    }
                }
            } else {
                if (Math.hypot(this.x - other.x, this.y - other.y) < 115) { 
                    other.hp -= this.damage * 1.7; if (other.hp <= 0) killEnemy(other); 
                } 
            }
        });
      }
      this.marked = true;
    }
  }

  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.shadowBlur = 11; ctx.shadowColor = this.color;
    if (!this.isEnemy && !this.explosive) {
        ctx.rotate(Math.atan2(this.vy, this.vx) + Math.PI/2);
    } else if (this.special && this.special.isMissile) {
        ctx.rotate(Math.atan2(this.vy, this.vx) + Math.PI/2);
    }

    if (this.special && this.special.isSlug) {
        ctx.fillStyle = '#ffeedd'; ctx.fillRect(-4, -18, 8, 36); ctx.shadowBlur = 15; ctx.shadowColor = '#ffffaa';
    } else if (this.special && this.special.isBomb) {
        // ... (jouw originele bom code) ...
        ctx.shadowBlur = 25; ctx.shadowColor = '#ff4400';
        ctx.fillStyle = '#222222'; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#ff2200'; ctx.fillRect(-this.size, -3, this.size*2, 6);
        ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, 0, this.size*0.35, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#ffcc00'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, -this.size); ctx.lineTo(4, -this.size - 10); ctx.stroke();
        if (frameCount % 4 < 2) { ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(4, -this.size-10, 3, 0, Math.PI*2); ctx.fill(); }
    } else if (this.special && this.special.isMissile) {
        // --- NIEUW: Gigantische raket tekening ---
        if (this.size >= 50) { 
            ctx.shadowBlur = 30; ctx.shadowColor = '#ff4400';
            ctx.fillStyle = '#aa0000';
            ctx.beginPath(); 
            ctx.moveTo(0, this.size); 
            ctx.lineTo(this.size*0.3, 0); 
            ctx.lineTo(this.size*0.3, -this.size*0.8); 
            ctx.lineTo(-this.size*0.3, -this.size*0.8); 
            ctx.lineTo(-this.size*0.3, 0); 
            ctx.fill();
            ctx.fillStyle = '#ffaa00'; 
            ctx.fillRect(-this.size*0.2, -this.size*0.8, this.size*0.4, this.size*0.2);
            // Engine vuur
            ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(0, -this.size*0.8, 6, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.fillStyle = '#ff8800'; ctx.beginPath(); ctx.moveTo(0, 8); ctx.lineTo(4, 0); ctx.lineTo(4, -12); ctx.lineTo(-4, -12); ctx.lineTo(-4, 0); ctx.fill();
            ctx.fillStyle = '#ff2200'; ctx.fillRect(-2, -16, 4, 4);
        }
    } else if (this.isEnemy) { 
        // ... (rest van de draw functie is hetzelfde) ...
        if (this.explosive && this.special && this.special.bigExplosion) {
            ctx.shadowBlur = 20; ctx.shadowColor = '#ff6600';
            ctx.fillStyle = '#ff3300'; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, 0, this.size*0.6, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fill(); 
        }
    } else { 
        if(this.explosive) { ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0,0,this.size*1.5, 0, Math.PI*2); ctx.fill(); } 
        ctx.fillStyle = this.color; ctx.fillRect(-2.5, -13, 5, 26); 
    }
    ctx.restore();
  }
}

class EnemyDescent {
  constructor(x, y, isBoss = false, isPlayer = false) {
    this.x = x; this.y = y; this.isBoss = isBoss; this.isPlayer = isPlayer;
    this.vy = 3.0 + Math.random() * 1.6; this.vx = (Math.random() - 0.5) * 0.6; 
    this.life = 1.0; this.marked = false; this.flameTimer = 0;
  }
  update() {
    this.x += this.vx; this.y += this.vy; this.life -= 0.024; this.flameTimer++;
    if (this.flameTimer >= 1) {
      const flameColors = ['#ff6600', '#ffaa00', '#ff4400', '#ffdd00'];
      const color = flameColors[Math.floor(Math.random() * flameColors.length)];
      spawnParticles(this.x, this.y, color, 3 + Math.floor(Math.random() * 2));
      this.flameTimer = 0;
    }
    if (this.life <= 0 || this.y > height + 100) this.marked = true;
  }
  draw() {
    if (this.life <= 0) return;
    ctx.save(); ctx.globalAlpha = this.life * 0.8;
    const flameColors = ['#ff4400', '#ff8800', '#ffaa00', '#ffdd00'];
    for (let i = 0; i < flameColors.length; i++) {
      const radius = 12 - i * 3;
      if (radius <= 0) continue;
      ctx.fillStyle = flameColors[i]; ctx.beginPath(); ctx.arc(this.x, this.y, radius, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1.0; ctx.restore();
  }
}

class Wreck {
  constructor(x, y, type = 'normal', rotation = 0) {
    this.x = x; this.y = y; this.type = type; this.rotation = rotation;
    this.vy = 1.0 + Math.random() * 3.0; this.vx = (Math.random() - 0.5) * 6;
    this.angularVel = (Math.random() - 0.5) * 0.2; this.life = 1.0; this.marked = false; this.smokeTimer = 0;
  }
  update() {
    this.x += this.vx; this.y += this.vy; this.rotation += this.angularVel; this.life -= 0.016; this.smokeTimer++;
    if (this.smokeTimer >= 2) {
      spawnParticles(this.x, this.y, this.type === 'boss' ? '#ff4400' : '#888888', 1); spawnParticles(this.x, this.y, '#444444', 1);
      this.smokeTimer = 0;
    }
    if (this.life <= 0) this.marked = true;
  }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.globalAlpha = this.life;
    if (this.type === 'tank') {
      ctx.fillStyle = '#333'; ctx.beginPath(); ctx.moveTo(-14, 12); ctx.lineTo(14, 12); ctx.lineTo(22, -8); ctx.lineTo(0, -26); ctx.lineTo(-22, -8); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#ff4400'; ctx.fillRect(-8, 5, 16, 8);
    } else if (this.type === 'boss') {
      ctx.fillStyle = '#1a1a1a'; ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ff4400'; ctx.beginPath(); ctx.arc(Math.random() * 20 - 10, Math.random() * 20 - 10, 15, 0, Math.PI * 2); ctx.fill();
    } else {
      ctx.fillStyle = '#444'; ctx.fillRect(-8, -12, 16, 24); ctx.fillStyle = '#ff6600'; ctx.fillRect(-6, -8, 12, 4);
    }
    ctx.globalAlpha = 1.0; ctx.restore();
  }
}

class Wingman {
  constructor(side) {
    this.side = side;  // -1 = left,  +1 = right
    // Start offscreen
    this.x = side < 0 ? -220 : width + 220;
    this.y = player.y;
    this.isEntering = true;
    this.marked = false;
    this.isCrashing = false;
    this.crashTimer = 0;
    this.fireTimer = 0;
    // Full part structure matching player
    this.parts = {
      body:      { hp:400, max:400 },
      leftWing:  { hp:270, max:270 },
      rightWing: { hp:270, max:270 },
      engine:    { hp:330, max:330 },
      gun:       { hp:300, max:300 }
    };
  }

  totalHp()    { return Object.values(this.parts).reduce((s,p)=>s+p.hp,0); }
  maxTotalHp() { return Object.values(this.parts).reduce((s,p)=>s+p.max,0); }

  takeDamage(amount) {
    if (this.isCrashing) return;
    // Distribute to first alive part (priority: gun‚Üíengine‚Üíwings‚Üíbody)
    for (let k of ['gun','engine','leftWing','rightWing','body']) {
      if (this.parts[k].hp > 0) {
        this.parts[k].hp -= amount;
        break;
      }
    }
    // No sound effect for wingmen - removed playImpactSound()
    updateWingmanHUD();
    if (this.totalHp() <= 0) {
      this.isCrashing = true;
      this.crashTimer = 60;
      spawnParticles(this.x, this.y, '#ff4400', 30);
    }
  }

  update() {
    if (this.isCrashing) {
      this.crashTimer--;
      this.y += 5;
      this.x += this.side * 1.5;
      spawnParticles(this.x, this.y, '#ff4400', 4);
      spawnParticles(this.x, this.y, '#444', 3);
      if (this.crashTimer <= 0) { this.marked = true; updateWingmanHUD(); }
      return;
    }

    // Formation target: one full player-width gap from player edge
    // Player visual half-width ‚âà 73px, full width ‚âà 146px, wingman half ‚âà 58px ‚Üí offset 277
    const formX = player.x + this.side * 277;
    const formY = player.y;

    if (this.isEntering) {
      const dx = formX - this.x, dy = formY - this.y;
      const dist = Math.hypot(dx, dy);
      if (dist < 8) { this.isEntering = false; this.x = formX; this.y = formY; }
      else { const spd = 14; this.x += (dx/dist)*spd; this.y += (dy/dist)*spd; }
    } else {
      this.x += (formX - this.x) * 0.28;
      this.y += (formY - this.y) * 0.28;
    }

    // Shoot straight up ‚Äî 6 shots / sec (every 10 frames at 60fps, 2x faster)
    this.fireTimer++;
    if (this.fireTimer >= 10 && !inIntermission) {
      this.fireTimer = 0;
      this.shoot();
    }
    updateWingmanHUD();
  }

  shoot() {
    const color = '#44ff88';
    const dmg = 28;
    const s = 2.08; // visual scale (2.6 * 0.8)
    const muzzleY = this.y - 18 * s * 0.5;
    if (wingmanTier === 0) {
      bullets.push(new Bullet(this.x, muzzleY - 10, 0, -38, color, false, 'NONE', false, dmg));
    } else if (wingmanTier === 1) {
      // Double parallel
      bullets.push(new Bullet(this.x - 14*s*0.5, muzzleY, 0, -38, color, false, 'NONE', false, dmg));
      bullets.push(new Bullet(this.x + 11*s*0.5, muzzleY, 0, -38, color, false, 'NONE', false, dmg));
    } else if (wingmanTier === 2) {
      // Scatter
      bullets.push(new Bullet(this.x - 14*s*0.5, muzzleY, -3, -38, color, false, 'NONE', false, dmg));
      bullets.push(new Bullet(this.x + 11*s*0.5, muzzleY,  3, -38, color, false, 'NONE', false, dmg));
    } else {
      // Triple scatter
      bullets.push(new Bullet(this.x - 18, muzzleY, -5, -38, color, false, 'NONE', false, dmg));
      bullets.push(new Bullet(this.x,      muzzleY - 8, 0, -38, color, false, 'NONE', false, dmg));
      bullets.push(new Bullet(this.x + 18, muzzleY,  5, -38, color, false, 'NONE', false, dmg));
    }
    playRealisticGun('support');
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    let sc = 2.08; // 2.6 * 0.8
    if (this.isCrashing) {
      let cs = Math.max(0.01, 1 - (60 - this.crashTimer) / 60);
      ctx.scale(sc * cs, sc * cs);
    } else {
      ctx.scale(sc, sc);
    }

    const engOk = this.parts.engine.hp > 0 && !this.isCrashing;

    // Left engine pod
    ctx.fillStyle = '#0a2a0a';
    ctx.beginPath(); ctx.moveTo(-16,-8); ctx.lineTo(-14,-8); ctx.lineTo(-14,20); ctx.lineTo(-16,20); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#44ff44'; ctx.lineWidth = 0.5; ctx.stroke();
    if (engOk) {
      let eH = 10 + Math.random()*8;
      let g = ctx.createLinearGradient(-15,20,-15,20+eH);
      g.addColorStop(0,'#44ff44'); g.addColorStop(1,'rgba(0,200,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.moveTo(-17,20); ctx.lineTo(-15,20+eH); ctx.lineTo(-13,20); ctx.fill();
    }
    // Right engine pod
    ctx.fillStyle = '#0a2a0a';
    ctx.beginPath(); ctx.moveTo(14,-8); ctx.lineTo(16,-8); ctx.lineTo(16,20); ctx.lineTo(14,20); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#44ff44'; ctx.lineWidth = 0.5; ctx.stroke();
    if (engOk) {
      let eH = 10 + Math.random()*8;
      let g = ctx.createLinearGradient(15,20,15,20+eH);
      g.addColorStop(0,'#44ff44'); g.addColorStop(1,'rgba(0,200,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.moveTo(13,20); ctx.lineTo(15,20+eH); ctx.lineTo(17,20); ctx.fill();
    }

    // Left wing
    const lwOk = this.parts.leftWing.hp > 0;
    ctx.fillStyle = lwOk ? '#0d2a0d' : '#111';
    ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(-28,16); ctx.lineTo(-26,22); ctx.lineTo(-14,16); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = lwOk ? '#44ff44' : '#333'; ctx.lineWidth = 0.5; ctx.stroke();

    // Right wing
    const rwOk = this.parts.rightWing.hp > 0;
    ctx.fillStyle = rwOk ? '#0d2a0d' : '#111';
    ctx.beginPath(); ctx.moveTo(8,0); ctx.lineTo(28,16); ctx.lineTo(26,22); ctx.lineTo(14,16); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = rwOk ? '#44ff44' : '#333'; ctx.lineWidth = 0.5; ctx.stroke();

    // Hull
    const bOk = this.parts.body.hp > 0;
    const bPct = bOk ? this.parts.body.hp/this.parts.body.max : 0;
    ctx.shadowBlur = bOk ? 12 : 0; ctx.shadowColor = '#44ff44';
    ctx.fillStyle = bOk ? (bPct>0.5?'#0a2a14':(bPct>0.25?'#1a2a0a':'#2a1a0a')) : '#111';
    ctx.beginPath();
    ctx.moveTo(0,-26); ctx.lineTo(8,-12); ctx.lineTo(8,-2); ctx.lineTo(12,2); ctx.lineTo(12,14);
    ctx.lineTo(-12,14); ctx.lineTo(-12,2); ctx.lineTo(-8,-2); ctx.lineTo(-8,-12);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = bOk ? '#44ff44' : '#333'; ctx.lineWidth = 0.6; ctx.stroke();

    // Gun / muzzle
    if (this.parts.gun.hp > 0) {
      ctx.shadowBlur = 6; ctx.shadowColor = '#44ff88';
      ctx.fillStyle = '#aaffaa';
      ctx.fillRect(-14,-18,3,10); ctx.fillRect(11,-18,3,10);
      ctx.fillStyle = '#44ff88'; ctx.fillRect(-1,-30,2,8);
    }
    // Cockpit
    if (bOk) {
      ctx.fillStyle = '#006622'; ctx.shadowBlur = 5; ctx.shadowColor = '#44ff44';
      ctx.beginPath(); ctx.ellipse(0,-8,5,8,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#88ffcc'; ctx.beginPath(); ctx.ellipse(-1,-10,2,4,0,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
}

let escortShips = []; // kept for legacy compat, unused

function spawnWingman() {
  // Spawn 2 wingmen immediately (left and right) instead of 1 for 1
  const usedSides = wingmen.filter(w=>!w.marked).map(w=>w.side);
  
  // Spawn left wingman if not present
  if (!usedSides.includes(-1)) {
    wingmen.push(new Wingman(-1));
  }
  
  // Spawn right wingman if not present
  if (!usedSides.includes(1)) {
    wingmen.push(new Wingman(1));
  }
  
  showNotification("WINGMEN INBOUND!");
  playAudioFile(audioFiles.wingmanReady);
  updateWingmanHUD();
}

function updateWingmanHUD() {
  const hud = document.getElementById('wingman-hud');
  const activeWingmen = wingmen.filter(w=>!w.marked);
  if (activeWingmen.length === 0) { hud.style.display = 'none'; return; }
  hud.style.display = 'block';
  document.getElementById('wingman-tier-text').textContent = 'TIER ' + wingmanTier + (wingmanTier>=3?' (MAX)':'');

  // Left wingman bar
  const lw = activeWingmen.find(w=>w.side===-1);
  const lFill = document.getElementById('wingman-left-fill');
  const lBar  = document.getElementById('wingman-left-bar');
  lBar.style.display = lw ? 'block':'none';
  if (lw && !lw.isCrashing) lFill.style.width = Math.max(0, lw.totalHp()/lw.maxTotalHp()*100)+'%';

  const rw = activeWingmen.find(w=>w.side===1);
  const rFill = document.getElementById('wingman-right-fill');
  const rBar  = document.getElementById('wingman-right-bar');
  rBar.style.display = rw ? 'block':'none';
  if (rw && !rw.isCrashing) rFill.style.width = Math.max(0, rw.totalHp()/rw.maxTotalHp()*100)+'%';
}

class Drop {
  constructor(x, y, type) { this.x = x; this.y = y; this.vy = 4.4; this.type = type; this.marked = false; }
  update() { this.y += this.vy; if(this.y > height) this.marked = true; }
  draw() {
    ctx.save(); ctx.translate(this.x, this.y); ctx.shadowBlur = 16;
    if (this.type === 'HEAL') { 
        ctx.fillStyle = '#00ff00'; ctx.shadowColor = '#00ff00'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.fillText('+', 0, 8); ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.stroke(); 
    } 
    else if (this.type === 'CARD') { 
        ctx.fillStyle = '#ff44aa'; ctx.shadowColor = '#ff44aa'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 18px Arial'; ctx.textAlign = 'center'; ctx.fillText('‚òÖ', 0, 7); 
    } 
    else if (this.type === 'SUPPORT') { 
        ctx.fillStyle = '#00d4ff'; ctx.shadowColor = '#00d4ff'; ctx.beginPath(); ctx.moveTo(0, -13); ctx.lineTo(9, 7); ctx.lineTo(0, 3); ctx.lineTo(-9, 7); ctx.fill(); 
    }
    else if (this.type === 'MEDAL') { 
        ctx.fillStyle = '#ffaa00'; ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.fillText('‚òÖ', 0, 4);
    }
    else if (this.type === 'SCORE_COIN') { 
        ctx.fillStyle = '#0088ff'; ctx.shadowColor = '#00d4ff'; ctx.shadowBlur = 15;
        ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#c0c0c0'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText('$', 0, 5);
    }
    else if (this.type === 'ESCORT') { 
        ctx.fillStyle = '#00ffcc'; ctx.shadowColor = '#00ffcc'; ctx.shadowBlur = 14;
        ctx.beginPath(); ctx.moveTo(-8,-12); ctx.lineTo(8,-12); ctx.lineTo(12,8); ctx.lineTo(-12,8); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.fillText('ESC', 0, 3);
    }
    else if (this.type === 'UPGRADE') {
        ctx.fillStyle = '#ffd700'; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 16;
        ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText('‚ñ≤', 0, 5);
    }
    else if (this.type === 'WINGMAN_HEAL') {
        // Green cross with small wing shape
        ctx.shadowColor = '#44ff44'; ctx.shadowBlur = 16;
        ctx.strokeStyle = '#44ff44'; ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.arc(0,0,13,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle = '#44ff44'; ctx.font = 'bold 18px Arial'; ctx.textAlign = 'center'; ctx.fillText('‚ô¶', 0, 7);
        ctx.fillStyle = '#00ff88'; ctx.font = 'bold 9px Arial'; ctx.fillText('WG', 0, -3);
    }
    else if (this.type === 'WINGMAN_UPGRADE') {
        ctx.fillStyle = '#88ff44'; ctx.shadowColor = '#88ff44'; ctx.shadowBlur = 16;
        ctx.beginPath(); ctx.arc(0,0,13,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#002200'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.fillText('W‚ñ≤', 0, 5);
    }
    ctx.restore();
  }
}

class Particle {
  constructor(x, y, color) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 18; this.vy = (Math.random() - 0.5) * 18; this.life = 1.0; this.color = color; this.size = 1.6 + Math.random() * 2.4; }
  update() { this.x += this.vx; this.y += this.vy; this.life -= 0.09; }
  draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
}

class GalaxyBackground {
  constructor() { this.layers = []; this.initLayers(); }
  initLayers() {
    this.layers = []; 
    this.layers.push({ speed: 0.2, stars: [], color: () => `rgba(${200 + Math.random() * 55}, ${200 + Math.random() * 55}, ${255}, ${0.3 + Math.random() * 0.4})`, size: () => 0.5 + Math.random() * 1.5, count: 300 });
    this.layers.push({ speed: 0.6, clouds: [], color: () => ['rgba(100, 50, 200, 0.15)', 'rgba(150, 50, 255, 0.15)', 'rgba(200, 100, 255, 0.15)', 'rgba(50, 100, 255, 0.15)'][Math.floor(Math.random()*4)], size: () => 30 + Math.random() * 70, count: 15 });
    this.layers.push({ speed: 1.0, stars: [], color: () => `rgba(${255}, ${200 + Math.random() * 55}, ${100 + Math.random() * 155}, ${0.5 + Math.random() * 0.3})`, size: () => 1 + Math.random() * 2, count: 200 });
    
    this.layers.push({ 
        speed: 1.4, objects: [], 
        createObject: () => { 
            const rand = Math.random();
            if (rand < 0.2) return { type: 'earth', size: 60 + Math.random()*40, color: '#2266cc' };
            if (rand < 0.4) return { type: 'sun', size: 100 + Math.random()*50, color: '#ffaa00' };
            if (rand < 0.6) return { type: 'station', size: 40 + Math.random()*30, color: '#888888' };
            if (rand < 0.8) return { type: 'planet', size: 80 + Math.random()*40, color: `hsl(${Math.random() * 360}, 60%, 40%)` };
            return { type: 'galaxy', size: 50 + Math.random() * 50, color: `rgba(${100 + Math.random() * 155}, ${50 + Math.random() * 100}, ${200 + Math.random() * 55}, 0.6)` };
        }, 
        count: 8 
    });
    this.layers.push({ speed: 2.0, stars: [], color: () => `rgba(255, 255, 255, ${0.7 + Math.random() * 0.3})`, size: () => 2 + Math.random() * 3, count: 100 });
    for (let layer of this.layers) {
      if (layer.stars) for (let i = 0; i < layer.count; i++) layer.stars.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, size: layer.size(), color: layer.color() });
      if (layer.clouds) for (let i = 0; i < layer.count; i++) layer.clouds.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, size: layer.size(), color: layer.color() });
      if (layer.objects) for (let i = 0; i < layer.count; i++) { const obj = layer.createObject(); layer.objects.push({ x: Math.random() * width, y: Math.random() * height * 2 - height, ...obj }); }
    }
  }
  update() {
    for (let layer of this.layers) {
      const speed = layer.speed;
      if (layer.stars) for (let star of layer.stars) { star.y += speed * 0.5; if (star.y > height + 50) { star.y = -50; star.x = Math.random() * width; } }
      if (layer.clouds) for (let cloud of layer.clouds) { cloud.y += speed * 0.5; if (cloud.y > height + 100) { cloud.y = -100; cloud.x = Math.random() * width; } }
      if (layer.objects) for (let obj of layer.objects) { 
          obj.y += speed * 0.5; 
          if (obj.y > height + 150) { 
              obj.y = -150; obj.x = Math.random() * width; 
              const newObj = this.layers[3].createObject(); 
              obj.type = newObj.type; obj.size = newObj.size; obj.color = newObj.color; 
          } 
      }
    }
  }
  draw() {
    for (let layer of this.layers) {
      if (layer.stars) for (let star of layer.stars) { ctx.fillStyle = star.color; ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill(); }
      if (layer.clouds) for (let cloud of layer.clouds) { ctx.fillStyle = cloud.color; ctx.beginPath(); ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2); ctx.fill(); }
      if (layer.objects) for (let obj of layer.objects) {
        if (obj.type === 'earth') {
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, '#3399ff'); gradient.addColorStop(1, '#002200'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(obj.x-10, obj.y-10, obj.size*0.4, 0, Math.PI * 2); ctx.fill();
        } else if (obj.type === 'sun') {
            ctx.shadowBlur = 50; ctx.shadowColor = '#ff5500';
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(0.2, '#ffdd00'); gradient.addColorStop(1, '#ff3300'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        } else if (obj.type === 'station') {
            ctx.fillStyle = '#666'; ctx.fillRect(obj.x - obj.size, obj.y - obj.size/4, obj.size*2, obj.size/2);
            ctx.fillStyle = '#444'; ctx.fillRect(obj.x - obj.size/4, obj.y - obj.size, obj.size/2, obj.size*2);
            ctx.fillStyle = '#00ffff'; ctx.fillRect(obj.x - 5, obj.y - 5, 10, 10);
        } else if (obj.type === 'planet') { 
            const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.size); 
            gradient.addColorStop(0, obj.color); gradient.addColorStop(1, 'rgba(0,0,0,0.7)'); 
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill(); 
        } else { 
            ctx.fillStyle = obj.color; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2); ctx.fill(); 
        }
      }
    }
  }
}

let player, bullets = [], enemies = [], drops = [], particles = [], allies = [], wrecks = [];
let mouse = { x: 0, y: 0 }; let galaxyBackground;

function selectElement(element) {
  currentElement = element;
  document.getElementById('element-selection').style.display = 'none';
  document.getElementById('weapon-selection').style.display = 'flex';
}

function selectWeapon(weaponId) {
  currentWeapon = weaponId;
  currentWeaponTier = 0;
  document.getElementById('weapon-selection').style.display = 'none';
  initGame();
}

function initGame() {
  const allAudio = document.querySelectorAll('audio');
  allAudio.forEach(audio => { audio.pause(); audio.currentTime = 0; });
  
  resize(); 
  player = new Player(); 
  player.element = currentElement;
  player.weaponType = currentWeapon;
  drawDamageModel(player.parts); 
  
  bullets = []; enemies = []; drops = []; particles = []; allies = []; wrecks = []; escortShips = [];
  wingmen = []; wingmanTier = 0;
  score = 0; xp = 0; xpNeeded = 1000; wave = 1; waveTimer = 0; currentLevel = 1; bossActive = false; elementPower = 0; 
  pendingSupportPasses = 0; supportPassTimer = 0; bossSupportsUsed = 0; supportSpawnDelay = 0; globalFormationIdCounter = 0;
  superPowerMeter = 0; superPowerReady = false; aceSpawnedThisWave = false;
  equippedCards = [null, null, null];
  inIntermission = false; intermissionTimer = 0;
  
  gameRunning = true; 
  galaxyBackground = new GalaxyBackground(); 
  startBGM('normal'); 
  updateCardsDisplay(); updateElementBar(); updateUI(); updateSuperPowerUI();
  requestAnimationFrame(animate);
}

function spawnDiagonalKette() {
    globalFormationIdCounter++;
    const dir = Math.random() > 0.5 ? 1 : -1; 
    const cx = Math.random() * (width - 300) + 150;
    const spacing = 90; 
    for (let i = 0; i < 3; i++) {
        let e = new Enemy(wave, 'diagonal-kette', cx + dir * i * spacing * 0.6, -150 - i * spacing * 0.8);
        e.speed = (3.6 + Math.random() * 0.8) * 2; // 2x zo snel
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    }
}

function spawnBox() {
    globalFormationIdCounter++;
    const cx = Math.random() * (width - 250) + 125;
    const offsets = [[-70,-60],[70,-60],[-70,60],[70,60]];
    offsets.forEach(([ox, oy]) => {
        let e = new Enemy(wave, 'box', cx + ox, oy - 150);
        e.speed = (3.4 + Math.random() * 0.6) * 2.3; // Iets OP (2.3x zo snel)
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    });
}

function spawnColumnSweep() {
    globalFormationIdCounter++;
    const cx = Math.random() * (width - 200) + 100;
    for (let i = 0; i < 4; i++) {
        let e = new Enemy(wave, 'column-sweep', cx, -150 - i * 100);
        e.vy = 0; 
        e.rotation = Math.PI;
        e.speed = (3.8 + Math.random() * 0.6) * 2; // 2x zo snel
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    }
}

function spawnFighterWing() {
    globalFormationIdCounter++;
    const side = Math.random() > 0.5 ? 1 : -1;
    const startX = side === 1 ? -150 : width + 150;
    const startY = Math.random() * (height * 0.4);
    for (let i = 0; i < 4; i++) {
        let e = new Enemy(wave, 'fighter-wing', startX - side * i * 60, startY - i * 40);
        e.side = side;
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    }
}

function spawnSideSweep() {
    globalFormationIdCounter++;
    const side = Math.random() > 0.5 ? 1 : -1;
    const startX = side === 1 ? -150 : width + 150;
    const startY = 80 + Math.random() * (height * 0.35);
    for (let i = 0; i < 3; i++) {
        let e = new Enemy(wave, 'side-sweep', startX - side * i * 90, startY);
        e.side = side;
        e.formationId = globalFormationIdCounter;
        enemies.push(e);
    }
}

function spawnLogic() {
  if (bossActive || inIntermission || waveTimer >= FRAMES_PER_WAVE) return;

  let isReturningActive = enemies.some(e => e.returning);
  if (isReturningActive) return;

  let activeFormations = new Set();
  enemies.forEach(e => { if (e.formationId && !e.isCrashing) activeFormations.add(e.formationId); });
  
  // 1.5x meer vijanden: Verhoog het maximum aantal formaties tegelijk
  const maxFormations = wave >= 7 ? 3 : 2; 
  
  // Snellere kans op spawnen als we onder het limiet zitten
  if (activeFormations.size < maxFormations || (activeFormations.size < maxFormations && Math.random() < 0.05)) {
    const formType = Math.random();
    
    // 70% vanaf de zijkanten (side-sweep & fighter-wing)
    if (formType < 0.35) spawnSideSweep();
    else if (formType < 0.70) spawnFighterWing();
    
    // 30% van voren (diagonal, box, column)
    else if (formType < 0.80) spawnDiagonalKette();
    else if (formType < 0.90) spawnBox();
    else spawnColumnSweep();
  }

  if (wave >= 2 && Math.random() < 0.004) {
      let bomberCount = enemies.filter(e => e.subType === 'bomber').length;
      if (bomberCount === 0) enemies.push(new Enemy(wave, 'bomber'));
  }

  if (wave % 3 === 2 && !aceSpawnedThisWave && waveTimer === 450) {
      enemies.push(new Enemy(wave, 'ace_pilot'));
      aceSpawnedThisWave = true;
      showNotification("ACE PILOT INCOMING!");
  }
}

function checkCollisions() {
  for(let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    if (b.marked) continue;
    
    if (!b.isEnemy) {
      for(let j = enemies.length - 1; j >= 0; j--) {
        let e = enemies[j];
        if (e.isCrashing) continue; 
        if (!e.isBoss && b.hitList && b.hitList.has(e)) continue;

        let hitBox = e.isBoss ? (e.isSecret ? 100 : 68) : e.size;
        
        let finalDamage = b.damage;
        if (e.isBoss && b.special && b.special.bossHunter) finalDamage *= 2.0;
        
        if (e.isBoss) {
            let hitEngine = false;
            for (let part of e.parts) {
                if (b.hitList && b.hitList.has(part)) continue;
                if (part.isDead || part.phase !== e.currentPhase) continue;
                if (Math.hypot(b.x - (e.x + part.relX), b.y - (e.y + part.relY)) < part.radius + 22) {
                    hitEngine = true;
                    part.hp -= finalDamage;
                    if (e.currentPhase === 99) e.hp -= finalDamage; 
                    playAudioFile(audioFiles.explosion);
                    if (part.hp <= 0) {
                        part.isDead = true; part.hp = 0;
                        playAudioFile(audioFiles.bossExplosion);
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#ff4400', 120);
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#000000', 60);
                        cameraShake = 18;
                        notifyPartDestroyed(e, part);
                        if (e.checkCurrentPhase) e.checkCurrentPhase();
                    } else {
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#ffffff', 8);
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#00ffff', 12);
                        spawnParticles(e.x + part.relX, e.y + part.relY, '#ffaa00', 15);
                    }
                    if (b.hitList) b.hitList.add(part);
                    break; 
                }
            }
            if (!hitEngine) continue; 
        } else {
            if (Math.hypot(b.x - e.x, b.y - e.y) >= hitBox + 12) continue;
            e.hp -= finalDamage; 
            spawnParticles(b.x, b.y, '#ffaa00', 6);
            if (b.hitList) b.hitList.add(e);
        }
          
        if (!e.isBoss && e.subType !== 'ace') {
          if (player.element === 'FIRE' || player.effects.burn || b.special.incendiary) e.burnTimer = 50;
          if ((player.element === 'WATER' || player.effects.slow)) { e.slowed = true; setTimeout(() => e.slowed = false, 2300); }
          if ((player.element === 'EARTH' && Math.random() < 0.15) || player.effects.stun) { e.stunned = true; e.stunTimer = 34; }
        }
        
        if (player.effects.chain) {
           let nearest = null; let minDist = 200;
           enemies.forEach(other => { if(other !== e && !other.isBoss && !other.isCrashing) { let d = Math.hypot(e.x - other.x, e.y - other.y); if(d < minDist) { minDist = d; nearest = other; } } });
           if (nearest) { nearest.hp -= b.damage * 0.8; spawnParticles((e.x + nearest.x)/2, (e.y + nearest.y)/2, '#00ffff', 5); if(nearest.hp <= 0) killEnemy(nearest); }
        }
        if (player.effects.pushback && !e.isBoss) { e.y -= 1; }

        if (b.explosive || (b.special && b.special.plasmaArea) || (b.special && b.special.bigExplosion)) {
            let radius = (b.special && b.special.bigExplosion) ? 150 : 100;
            let dmgMult = (b.special && b.special.bigExplosion) ? 1.5 : 1.2;
            spawnParticles(b.x, b.y, b.color, (b.special && b.special.bigExplosion) ? 80 : 48);
            
            enemies.forEach(other => {
                if(other.isCrashing) return;
                if (other.isBoss) {
                    for (let part of other.parts) {
                        if (!part.isDead && part.phase === other.currentPhase) {
                            if (Math.hypot(b.x - (other.x + part.relX), b.y - (other.y + part.relY)) < radius) {
                                part.hp -= finalDamage * dmgMult;
                                if (other.currentPhase === 99) other.hp -= finalDamage * dmgMult;
                                playAudioFile(audioFiles.explosion);
                                if (part.hp <= 0) { 
                                    part.isDead = true; part.hp = 0; 
                                    playAudioFile(audioFiles.bossExplosion);
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#ffaa00', 150);
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#000000', 80);
                                    notifyPartDestroyed(other, part);
                                    if (other.checkCurrentPhase) other.checkCurrentPhase();
                                } else {
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#ffffff', 10);
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#00ffff', 15);
                                    spawnParticles(other.x + part.relX, other.y + part.relY, '#ffaa00', 20);
                                }
                            }
                        }
                    }
                } else {
                    if (Math.hypot(b.x - other.x, b.y - other.y) < radius) {
                        other.hp -= finalDamage * dmgMult;
                        if (other.hp <= 0) killEnemy(other);
                    }
                }
            });
        }

        if (b.special && b.special.splinter && !b.special.isSplinterPiece) {
            for(let k=0; k<5; k++) {
                let ang = Math.random() * Math.PI * 2;
                let sb = new Bullet(b.x, b.y, Math.cos(ang)*16, Math.sin(ang)*16, '#ffaa00', false, 'NONE', false, b.damage * 0.4, {isSplinterPiece: true});
                bullets.push(sb);
            }
        }

        if (!player.effects.pierce || (b.special && b.special.isSplinterPiece)) { b.marked = true; }
        
        if (e.hp <= 0 && !e.isBoss) killEnemy(e);
      }
    } else {
      if (player.effects.invincible || player.isCrashing) { b.marked = true; continue; }
      
      let damage = b.damage; 
      if (player.effects.elementArmor || player.effects.armor) damage *= (0.85 / player.defenseMultiplier); 
      if (player.effects.shield) damage *= 0.80;
      
      let hitRadius = 46;
      if (b.explosive && b.special && b.special.bigExplosion) hitRadius = 85;

      if (Math.hypot(b.x - player.x, b.y - player.y) < hitRadius) {
        player.takeDamage(damage, b.x - player.x, b.y - player.y); b.marked = true;
        if (b.explosive) {
            spawnParticles(b.x, b.y, '#ff4400', 60);
            spawnParticles(b.x, b.y, '#ffff00', 40);
            cameraShake = 15;
        } else {
            spawnParticles(player.x, player.y, '#ff6600', 20); 
        }
      }
      // Check wingman hits
      if (!b.marked) {
        wingmen.forEach(w => {
          if (w.marked || w.isCrashing || w.isEntering) return;
          if (Math.hypot(b.x - w.x, b.y - w.y) < 40) {
            w.takeDamage(damage);
            b.marked = true;
            spawnParticles(w.x, w.y, '#44ff44', 8);
          }
        });
      }
    }
  }
  
  enemies.forEach(e => {
    if (e.isCrashing) return;
    if (e.isBoss) {
        if (e.currentPhase !== undefined && e.currentPhase !== 99 && e.currentPhase > 2) { killEnemy(e); }
        else if (e.currentPhase === 99 && e.hp <= 0) { killEnemy(e); }
        // Boss collision: trades 20% of player HP per second as damage
        if (Math.hypot(e.x - player.x, e.y - player.y) < 150) {
            let tradeHp = player.parts.body.max * 0.20 / 60;
            player.takeDamage(tradeHp, e.x - player.x, e.y - player.y);
        }
    } else {
        if (player.effects.invincible || player.isCrashing) return; 
        
        let crashHitRadius = e.subType === 'boss_missile' ? e.size + 100 : e.size + 100;
        if (!e.isBoss && Math.hypot(e.x - player.x, e.y - player.y) < crashHitRadius) {
            let dmg;
            if (e.subType === 'tank') {
                // Tank: double damage (2x base 70 = 140)
                dmg = 140;
            } else if (e.subType === 'bomber') {
                dmg = 100;
            } else if (e.subType === 'boss_missile') {
                dmg = 150;
            } else {
                // Regular enemy: trade their HP with yours
                dmg = Math.min(e.hp, player.parts.body.max * 0.15);
            }
            player.takeDamage(dmg, e.x - player.x, e.y - player.y); 
            e.hp = 0; spawnParticles(player.x, player.y, '#ff0000', 25); killEnemy(e);
        }
    }
  });

  drops.forEach(d => { if (!d.marked && Math.hypot(d.x - player.x, d.y - player.y) < 64) { d.marked = true; collectDrop(d.type); } });
}

function startIntermission(isBoss) {
    inIntermission = true;
    intermissionTimer = 0;
    intermissionIsBoss = isBoss;
    if (isBoss && bgmAudio) {
        bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null;
    }
}

function killEnemy(e) {
  if (e.isCrashing) return;
  e.isCrashing = true;
  e.crashTimer = e.isBoss ? 75 : 22;
  
  // SPEEL GELUIDEN DIRECT AF BIJ DE CRASH
  if (e.isBoss) {
    playAudioFile(audioFiles.bossDefeated);
    playAudioFile(audioFiles.bossExplosion);
  } else {
    playAudioFile(audioFiles.explosion);
    playAudioFile(audioFiles.enemyHit);
  }
}

function finalizeKillEnemy(e) {
  score += e.isBoss ? 5000 : (e.subType === 'bomber' ? 500 : 150); 

  if (e.isBoss) {
    // GELUIDEN ZIJN HIER VERWIJDERD
    spawnParticles(e.x, e.y, '#ff4400', 100);
    spawnParticles(e.x, e.y, '#000000', 50);
    for (let i = 0; i < 4; i++) wrecks.push(new EnemyDescent(e.x + (Math.random() - 0.5) * 80, e.y, true, false));
    
    for (let i = 0; i < 25; i++) drops.push(new Drop(e.x + (Math.random()-0.5)*150, e.y + (Math.random()-0.5)*150, 'SCORE_COIN'));
    
    enemies = enemies.filter(en => en !== e);
    bossActive = false;
    if (e.isSecret) {
        enemies = []; // Clear all enemies immediately
        bossActive = true;
        setTimeout(() => { victoryScreen(); }, 1500);
    } else {
        wave++; startBGM('normal'); 
        startIntermission(false); 
    }
  } else {
    // GELUID IS HIER VERWIJDERD
    spawnParticles(e.x, e.y, '#ff8844', 15);
    spawnParticles(e.x, e.y, '#ff4400', 8);
    wrecks.push(new EnemyDescent(e.x, e.y, false, false));
    enemies = enemies.filter(en => en !== e);
    
    if (Math.random() < (e.subType === 'bomber' ? 0.85 : (e.subType === 'ace' ? 1.0 : 0.13))) { drops.push(new Drop(e.x, e.y, 'MEDAL')); }
    if (e.subType === 'bomber' || e.subType === 'ace' || Math.random() < 0.008) { drops.push(new Drop(e.x, e.y, 'ESCORT')); }
    if (Math.random() < 0.009) { drops.push(new Drop(e.x, e.y, 'HEAL')); }
    if (Math.random() < 0.025) { drops.push(new Drop(e.x, e.y, 'UPGRADE')); }
    if (wingmen.filter(w=>!w.marked).length > 0 && Math.random() < 0.018) { drops.push(new Drop(e.x, e.y, 'WINGMAN_HEAL')); }
    if (wingmanTier < 3 && wingmen.filter(w=>!w.marked).length > 0 && Math.random() < 0.02) { drops.push(new Drop(e.x, e.y, 'WINGMAN_UPGRADE')); }
    
    if (!superPowerReady) {
      superPowerMeter += e.subType === 'bomber' ? 5 : 1;
      if (superPowerMeter >= getSuperPowerNeeded()) {
        superPowerMeter = getSuperPowerNeeded();
        superPowerReady = true;
      }
      updateSuperPowerUI();
    }
  }
  updateUI();
}

function updateSuperPowerUI() {
  const fill = document.getElementById('super-power-fill');
  const text = document.getElementById('super-power-text');
  const btn = document.getElementById('super-activate-btn');
  if (!fill) return;
  fill.style.width = (superPowerMeter / getSuperPowerNeeded() * 100) + '%';
  if (superPowerReady) {
    text.textContent = 'READY!';
    text.style.color = '#ffcc00';
    btn.style.display = 'block';
  } else {
    text.textContent = superPowerMeter + ' / ' + getSuperPowerNeeded() + ' KILLS';
    text.style.color = '#aaa';
    btn.style.display = 'none';
  }
}

function activateSquadron() {
  if (!superPowerReady) return;
  superPowerReady = false;
  superPowerMeter = 0;
  updateSuperPowerUI();
  showNotification("SQUADRON INBOUND!");
  setTimeout(() => { if (gameRunning) playAudioFile(audioFiles.support); }, 1);
  supportSpawnDelay = 120; 
}

function updateSupportWaves() {
  if (supportSpawnDelay > 0) {
      supportSpawnDelay--;
      if (supportSpawnDelay === 0) {
          pendingSupportPasses = 1;
      }
      return;
  }

  if (pendingSupportPasses > 0 && allies.length === 0) {
    playEngineFlyby(); 
    const formations = [
        { x: width * 0.1, yBase: height + 280 },
        { x: width * 0.28, yBase: height + 180 },
        { x: width * 0.5,  yBase: height + 100 }, 
        { x: width * 0.72, yBase: height + 180 },
        { x: width * 0.9, yBase: height + 280 }, 
    ];
    formations.forEach((pos, i) => {
        allies.push(new SupportShip(pos.x, pos.yBase, 0, -40, 0, i * 4));
    });
    pendingSupportPasses--;
  }
}

function collectDrop(type) {
  if (type === 'HEAL') {
    Object.keys(player.parts).forEach(k => { player.parts[k].hp = Math.min(player.parts[k].max, player.parts[k].hp + player.parts[k].max * 0.52); });
    drawDamageModel(player.parts); showNotification("SYSTEMS REPAIRED");
    playAudioFile(audioFiles.heal);
  } else if (type === 'ESCORT') { 
    spawnWingman();
  } else if (type === 'UPGRADE') {
    if (currentWeaponTier < 6) {
        currentWeaponTier++; showNotification("WEAPON TIER " + currentWeaponTier + " UNLOCKED!");
        playAudioFile(audioFiles.weaponTierIncrease);
    } else {
        score += 2500; showNotification("MAX TIER! +2500 SCORE"); playUpgradeSound();
    }
  } else if (type === 'WINGMAN_HEAL') {
    const aliveWingmen = wingmen.filter(w=>!w.marked && !w.isCrashing);
    if (aliveWingmen.length > 0) {
      aliveWingmen.forEach(w => {
        Object.keys(w.parts).forEach(k => { w.parts[k].hp = Math.min(w.parts[k].max, w.parts[k].hp + w.parts[k].max * 0.5); });
      });
      showNotification("WINGMAN REPAIRED!");
      playAudioFile(audioFiles.wingmanRepaired);
      updateWingmanHUD();
    }
  } else if (type === 'WINGMAN_UPGRADE') {
    if (wingmanTier < 3) {
      wingmanTier++;
      showNotification("WINGMAN TIER " + wingmanTier + " UNLOCKED!");
      playAudioFile(audioFiles.wingmanUpgraded);
      updateWingmanHUD();
    } else {
      score += 1500; showNotification("WINGMAN MAX TIER! +1500 SCORE"); playUpgradeSound();
    }
  } else if (type === 'SCORE_COIN') {
    score += 500; playUpgradeSound();
  } else if (type === 'MEDAL') {
    xp += 150; score += 50; playUpgradeSound();
    if (xp >= xpNeeded) {
        xp -= xpNeeded; xpNeeded = Math.floor(xpNeeded * 1.5);
        currentLevel++; playUpgradeSound();
        showNotification("LEVEL UP!");
        setTimeout(() => {
            if (currentElement === 'NONE') { currentElement = ['FIRE', 'WATER', 'EARTH', 'AIR'][Math.floor(Math.random()*4)]; player.element = currentElement; }
            const elementCards = ELEMENT_CARDS[currentElement];
            const card = {...elementCards[Math.floor(Math.random() * elementCards.length)], rarity: RARITIES[Math.min(4, Math.floor(Math.random() * 5 + wave * 0.22))]};
            showCardPickup(card);
        }, 500);
    }
  } else if (type === 'CARD') {
    if (currentElement === 'NONE') { currentElement = ['FIRE', 'WATER', 'EARTH', 'AIR'][Math.floor(Math.random()*4)]; player.element = currentElement; }
    const elementCards = ELEMENT_CARDS[currentElement];
    const card = {...elementCards[Math.floor(Math.random() * elementCards.length)], rarity: RARITIES[Math.min(4, Math.floor(Math.random() * 5 + wave * 0.22))]};
    showCardPickup(card);
  }
  updateUI();
}

function showCardPickup(card) {
  isPaused = true; pendingCard = card; playUpgradeSound();
  document.getElementById('card-name').textContent = card.name; document.getElementById('card-desc').textContent = card.desc;
  document.getElementById('card-rarity').textContent = card.rarity.toUpperCase(); document.getElementById('card-rarity').style.backgroundColor = RARITY_COLORS[card.rarity];
  document.querySelector('.card-preview-icon').textContent = currentElement === 'FIRE' ? 'üî•' : currentElement === 'WATER' ? 'üíß' : currentElement === 'EARTH' ? 'üåç' : 'üå™Ô∏è';
  document.getElementById('card-pickup').style.display = 'flex';
}

function acceptCard() {
  if (pendingCard.effect === 'burn') player.effects.burn = true; if (pendingCard.effect === 'explosive') player.effects.explosive = true;
  if (pendingCard.effect === 'revive') { for(let k in player.parts) { if(player.parts[k].hp <= 0) { player.parts[k].hp = player.parts[k].max; drawDamageModel(player.parts); break; } } }
  if (pendingCard.effect === 'shield') player.effects.shield = true; if (pendingCard.effect === 'slow') player.effects.slow = true;
  if (pendingCard.effect === 'stun') player.effects.stun = true; if (pendingCard.effect === 'armor') player.effects.armor = true;
  if (pendingCard.effect === 'regen') player.effects.regen = true; if (pendingCard.effect === 'speed') player.effects.speed = 0.12;
  if (pendingCard.effect === 'dodge') player.effects.dodge = true; if (pendingCard.effect === 'supernova') player.effects.supernova = true;
  if (pendingCard.effect === 'chain') player.effects.chain = true; if (pendingCard.effect === 'pushback') player.effects.pushback = true;
  
  let rMult = pendingCard.rarity === 'mythic' ? 2 : (pendingCard.rarity === 'legendary' ? 1.5 : (pendingCard.rarity === 'epic' ? 1.3 : (pendingCard.rarity === 'rare' ? 1.2 : 1.1)));
  if (currentElement === 'FIRE') player.damageMultiplier *= rMult;
  if (currentElement === 'WATER') player.fireRateMultiplier *= rMult;
  if (currentElement === 'AIR') player.speedMultiplier *= rMult;
  if (currentElement === 'EARTH') player.defenseMultiplier *= rMult;

  let added = false;
  for (let i = 0; i < 3; i++) { if (!equippedCards[i]) { equippedCards[i] = pendingCard; added = true; break; } }
  if (!added) {
    let worst = 0; for (let i = 1; i < 3; i++) { if (RARITIES.indexOf(equippedCards[i].rarity) < RARITIES.indexOf(equippedCards[worst].rarity)) worst = i; }
    if (RARITIES.indexOf(pendingCard.rarity) >= RARITIES.indexOf(equippedCards[worst].rarity)) equippedCards[worst] = pendingCard;
  }
  updateCardsDisplay(); document.getElementById('card-pickup').style.display = 'none'; isPaused = false; pendingCard = null;
}

function updateCardsDisplay() {
  const slots = document.querySelectorAll('.card-slot');
  slots.forEach((slot, i) => {
    slot.className = 'card-slot';
    if (equippedCards[i]) { const c = equippedCards[i]; slot.innerHTML = `<div style="font-size:26px;margin-bottom:4px;">${{common:'‚ô¶', rare:'‚ô£', epic:'‚ô†', legendary:'‚ô•', mythic:'‚òÖ'}[c.rarity] || '?'}</div><div>${c.name}</div><div style="font-size:10px;color:${RARITY_COLORS[c.rarity]}">${c.rarity}</div>`; slot.classList.add(`card-rarity-${c.rarity}`); } 
    else { slot.innerHTML = 'EMPTY'; slot.classList.add('empty'); }
  });
}

function updateElementBar() {
  document.getElementById('element-bar-fill').style.width = (elementPower / maxElementPower * 100) + '%';
  document.getElementById('element-text').textContent = currentElement !== 'NONE' ? `${ELEMENT_NAMES[currentElement]} POWER: ${Math.floor(elementPower)}` : "ELEMENT POWER";
}

function spawnParticles(x, y, color, count) { for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color)); }

function notifyPartDestroyed(boss, part) {
  const label = part.label;
  const isEngine = label === 'ENGINE' || label === 'PROPELLER';
  const isGun = ['GUN','BATTERY','TURRET','CANNON'].includes(label);
  if (isEngine) {
    const alive = boss.parts.filter(p => (p.label==='ENGINE'||p.label==='PROPELLER') && !p.isDead).length;
    playAudioFile(alive === 0 ? audioFiles.enginesAllGone : audioFiles.oneEngineGone);
  } else if (isGun) {
    const alive = boss.parts.filter(p => ['GUN','BATTERY','TURRET','CANNON'].includes(p.label) && !p.isDead).length;
    playAudioFile(alive === 0 ? audioFiles.allTurretsGone : audioFiles.oneTurretGone);
  }
}

const BOSS_INTROS = {
  3:  { name: "IRON HAWK FORTRESS",    sub: "Destroy the engine nacelles ‚Äî cut off its power!" },
  6:  { name: "STEEL CARRIER FORTRESS",sub: "Knock out the sponson engines before its batteries open fire!" },
  9:  { name: "DOOM ZEPPELIN",         sub: "Target the propeller nacelles under the gondola ‚Äî bring it DOWN!" },
  11: { name: "EUGENBURG DOOM-ENTITY", sub: "Unknown class ‚Äî annihilate the treads. All weapons free!" },
};

function showBossIntro(waveNum) {
  const intro = BOSS_INTROS[waveNum];
  if (!intro) return;
  const overlay = document.getElementById('boss-intro-overlay');
  document.getElementById('boss-intro-name').textContent = intro.name;
  document.getElementById('boss-intro-sub').textContent = intro.sub;
  overlay.style.display = 'flex';
  setTimeout(() => { overlay.style.display = 'none'; }, 3000);
  // Play boss intro audio 1 second later
  setTimeout(() => { playAudioFile(audioFiles.bossIntro); }, 1000);
}

function showNotification(text) {
  const el = document.getElementById('notification'); el.innerText = text; el.style.opacity = 1;
  document.getElementById('notification').style.color = '#ffd700'; document.getElementById('notification').style.textShadow = '0 0 20px #ffaa00';
  setTimeout(() => el.style.opacity = 0, 2000);
}

function updateUI() {
  document.getElementById('score').innerText = score; 
  document.getElementById('wave').innerText = wave > 11 ? 11 : wave;
  document.getElementById('level').innerText = currentLevel;
  document.getElementById('weapon-tier-display').innerText = "WEAPON TIER: " + currentWeaponTier + (currentWeaponTier === 6 ? " (MAX)" : "");
  document.getElementById('wave-timer-fill').style.width = Math.max(0, 100 - (waveTimer / FRAMES_PER_WAVE * 100)) + '%';
  document.getElementById('xp-bar-fill').style.width = Math.min(100, (xp / xpNeeded) * 100) + '%';
}

function showGameOver() {
  gameRunning = false; 
  if (bgmAudio) { bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null; }
  if(bgmInterval) clearInterval(bgmInterval);
  
  spawnParticles(player.x, player.y, '#ff8800', 80);
  spawnParticles(player.x, player.y, '#ff4400', 40);
  wrecks.push(new EnemyDescent(player.x, player.y, false, true));
  
  setTimeout(() => {
    document.getElementById('game-over').style.display = 'flex'; 
    document.getElementById('end-title').innerText = "CRITICAL FAILURE"; 
    document.getElementById('end-title').style.color = "#ff4444";
    document.getElementById('end-desc').innerText = "ALL SYSTEMS DESTROYED"; 
    document.getElementById('end-btn').innerText = "RETRY MISSION"; 
    document.getElementById('final-score').innerText = `FINAL SCORE: ${score}`;
    document.getElementById('end-btn').onclick = restartGame;
  }, 600);
}

function victoryScreen() {
  gameRunning = false; 
  if (bgmAudio) { bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null; }
  if(bgmInterval) clearInterval(bgmInterval);
  playAudioFile(audioFiles.missionAccomplished);
  document.getElementById('game-over').style.display = 'flex'; 
  document.getElementById('end-title').innerText = `VICTORY ACHIEVED`; document.getElementById('end-title').style.color = "#00ffaa";
  document.getElementById('end-desc').innerText = "THE GALAXY IS SAFE."; document.getElementById('end-btn').innerText = `RESTART GAME`; document.getElementById('final-score').innerText = `FINAL SCORE: ${score}`;
  document.getElementById('end-btn').onclick = restartGame;
}

function restartGame() { 
  if (bgmAudio) { bgmAudio.pause(); bgmAudio.currentTime = 0; bgmAudio = null; }
  const allAudio = document.querySelectorAll('audio');
  allAudio.forEach(audio => { audio.pause(); audio.currentTime = 0; });
  
  document.getElementById('game-over').style.display = 'none'; 
  document.getElementById('start-screen').style.display = 'flex'; 
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; width = canvas.width; height = canvas.height; if (galaxyBackground) galaxyBackground.initLayers(); }
window.addEventListener('resize', resize); 
document.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
document.addEventListener('keydown', e => {
  if (e.code === 'Space' && gameRunning) {
    e.preventDefault();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    if (superPowerReady && !isPaused && !player.isCrashing) activateSquadron();
  }
});

function animate(timestamp) {
  if (!gameRunning) return; 
  requestAnimationFrame(animate); 
  if (isPaused) return;

  if (!timestamp) timestamp = performance.now();
  if (timestamp - lastTimestamp < 16) return; 
  lastTimestamp = timestamp;

  frameCount++; 
  
  let shakeX = 0, shakeY = 0;
  if (cameraShake > 0) { shakeX = (Math.random() - 0.5) * cameraShake; shakeY = (Math.random() - 0.5) * cameraShake; cameraShake *= 0.92; }
  
  ctx.save(); ctx.translate(shakeX, shakeY);
  ctx.fillStyle = '#020205'; ctx.fillRect(0, 0, width, height);

  if (galaxyBackground) { galaxyBackground.update(); galaxyBackground.draw(); }

  if (player.isCrashing) {
      ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
      ctx.fillRect(0, 0, width, height);
  }

if (inIntermission) {
      intermissionTimer++;
      // Vroegtijdige algemene waarschuwing (optioneel) op 60 frames
      if (intermissionTimer === 60) { 
          if (!intermissionIsBoss) {
              showNotification("WAVE " + wave);
          } else {
              showNotification("‚ö† WARNING ‚ö†");
              document.getElementById('notification').style.color = '#ff0000'; 
              document.getElementById('notification').style.textShadow = '0 0 20px #ff0000';
          }
      }

      // Timer verdubbeld naar 180! Hier spawnt de boss, muziek start √©n de intro speelt tegelijk
      if (intermissionTimer >= 180) { 
          inIntermission = false; waveTimer = 0; cardDroppedThisWave = false; aceSpawnedThisWave = false;
          
          if (intermissionIsBoss) {
              wave++; bossActive = true; bossSupportsUsed = 0;
              
              // Toon NU de Boss intro samen met de muziek
              const nextWaveNum = wave;
              showBossIntro(nextWaveNum);
              
              if (wave === 3) startBGM('boss1'); 
              else if (wave === 6) startBGM('boss2'); 
              else if (wave === 9) startBGM('boss3'); 
              else if (wave === 11) startBGM('secret');
              
              if (wave === 11) enemies.push(new SecretBoss()); else enemies.push(new Boss(wave)); 
          }
      }
      updateUI();

  } else if (!bossActive && wave <= 10) {
    if (waveTimer < FRAMES_PER_WAVE) {
        waveTimer++;
        let isDamaged = false; for(let k in player.parts){ if(player.parts[k].hp < player.parts[k].max) isDamaged = true; }
        if (isDamaged && (waveTimer === 300 || waveTimer === 650)) drops.push(new Drop(Math.random() * (width - 160) + 80, -30, 'HEAL'));
        
        if (waveTimer === 500 && !cardDroppedThisWave && Math.random() < 0.10) { drops.push(new Drop(Math.random() * (width - 160) + 80, -30, 'CARD')); cardDroppedThisWave = true; }
    }

    if (waveTimer >= FRAMES_PER_WAVE && !inIntermission) {
        waveTimer = 0; let nextWave = wave + 1;
        // Secret boss triggert nu op wave 11
        if (nextWave === 3 || nextWave === 6 || nextWave === 9 || nextWave === 11) { 
            startIntermission(true); 
        } else { 
            wave++; startIntermission(false); 
        }
    }
    updateUI();
  }

  spawnLogic(); updateSupportWaves(); player.update();
  bullets.forEach(b => b.update()); enemies.forEach(e => e.update()); allies.forEach(a => a.update()); drops.forEach(d => d.update()); particles.forEach(p => p.update()); wrecks.forEach(w => w.update());
  wingmen.forEach(w => w.update());
  checkCollisions();

  player.draw();
  for (let i = wingmen.length - 1; i >= 0; i--) { if (wingmen[i].marked) { wingmen.splice(i,1); updateWingmanHUD(); continue; } wingmen[i].draw(); }
  for (let i = bullets.length - 1; i >= 0; i--) { if (bullets[i].marked) { bullets.splice(i, 1); continue; } bullets[i].draw(); }
  for (let i = enemies.length - 1; i >= 0; i--) { enemies[i].draw(); }
  for (let i = allies.length - 1; i >= 0; i--) { if (allies[i].marked) { allies.splice(i, 1); continue; } allies[i].draw(); }
  for (let i = drops.length - 1; i >= 0; i--) { if (drops[i].marked) { drops.splice(i, 1); continue; } drops[i].draw(); }
  for (let i = wrecks.length - 1; i >= 0; i--) { if (wrecks[i].marked) { wrecks.splice(i, 1); continue; } wrecks[i].draw(); }
  for (let i = particles.length - 1; i >= 0; i--) { if (particles[i].life <= 0) { particles.splice(i, 1); continue; } particles[i].draw(); }
  for (let i = escortShips.length - 1; i >= 0; i--) { if (escortShips[i].marked) { escortShips.splice(i, 1); continue; } escortShips[i].draw(); }
  
  ctx.restore();
}
</script>
</body>
</html>